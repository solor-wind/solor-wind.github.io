

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/solor-wind.jpg">
  <link rel="icon" href="/img/solor-wind.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#006cbf">
  <meta name="author" content="gpf">
  <meta name="keywords" content="">
  
    <meta name="description" content="OS课程的理论部分，知识点太过细碎，不完善">
<meta property="og:type" content="article">
<meta property="og:title" content="OS理论笔记">
<meta property="og:url" content="https://solor-wind.github.io/2024/07/02/OS%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="solor-wind&#39;s blog">
<meta property="og:description" content="OS课程的理论部分，知识点太过细碎，不完善">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E5%BC%82%E5%B8%B8-%E9%99%B7%E9%98%B1%E4%B8%8E%E4%B8%AD%E6%96%AD.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/MIPS%E5%90%AF%E5%8A%A8stage1.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/MIPS%E5%90%AF%E5%8A%A8stage2.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E6%AD%BB%E9%94%81.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE1.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE2.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/IO%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E8%BD%AE%E8%AF%A2IO.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E4%B8%AD%E6%96%ADIO.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E7%A3%81%E7%9B%98%E6%A6%82%E5%BF%B5.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/RAID%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/RAID4.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/RAID5.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/RAID6.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E6%96%87%E4%BB%B6%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E4%BD%8D%E5%9B%BE%E6%B3%95.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5%E6%B3%95.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/FAT-DOS.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/FAT2.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/EXT2.png">
<meta property="og:image" content="https://solor-wind.github.io/img/OS/%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9inode.png">
<meta property="article:published_time" content="2024-07-01T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-19T03:15:08.051Z">
<meta property="article:author" content="gpf">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://solor-wind.github.io/img/OS/%E5%BC%82%E5%B8%B8-%E9%99%B7%E9%98%B1%E4%B8%8E%E4%B8%AD%E6%96%AD.png">
  
  
  
  <title>OS理论笔记 - solor-wind&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"solor-wind.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>solor-wind&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/sth.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="OS理论笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-02 00:00" pubdate>
          2024年7月2日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          106 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">OS理论笔记</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p>
</blockquote>
<h2 id="引论">引论</h2>
<h3 id="操作系统的作用">操作系统的作用</h3>
<ol type="1">
<li>用户与计算机硬件系统的接口（API/GUI）</li>
<li>系统资源的管理
<ul>
<li>分配、控制处理机</li>
<li>内存的分配与回收</li>
<li>I/O设备的分配与操纵</li>
<li>文件的存取、共享和保护</li>
</ul></li>
<li>实现对计算机资源的抽象</li>
</ol>
<p>UI：User Interface，用户界面</p>
<p>API：Application Programming
Interface，应用程序编程接口。API相同，同一源码重新编译后即可运行</p>
<p>ABI：Application Binary
Interface，应用程序二进制接口。ABI相同，同一源码无须重新编译即可运行</p>
<p>ISA：Instruction Set Architecture，指令集架构。</p>
<h3 id="操作系统的进化">操作系统的进化</h3>
<h4 id="批处理">批处理</h4>
<p>把用户提交的作业成批送入计算机，由作业调度程序自动选择作业运行。</p>
<ul>
<li>无须人工参与，节省排队时间</li>
<li>同一时刻仅一个软件（作业）独占所有资源</li>
<li>CPU等待IO完成，浪费时间</li>
</ul>
<p>联机批处理：主机高速CPU运行监督程序，负责IO</p>
<p>脱机批处理：增加一台不与主机直接相连而专门用于与输入/输出设备打交道的卫星机</p>
<h4 id="多道程序设计">多道程序设计</h4>
<p>允许多个程序同时进入内存并运行。使CPU得到充分利用，同时也改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（即单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p>
<ul>
<li>系统吞吐量大</li>
<li>资源利用率高</li>
<li>平均周转时间长</li>
<li>无法提供交互能力</li>
</ul>
<h3 id="分时系统">分时系统</h3>
<p>多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。</p>
<ul>
<li>支持多用户、多程序同时运行</li>
</ul>
<p>分时技术：把处理机的运行时间分成很短的时间片，时间片轮流把处理机分配给各联机作业使用</p>
<h3 id="其他">其他</h3>
<figure>
<img src="/img/OS/异常-陷阱与中断.png" srcset="/img/loading.gif" lazyload alt="异常-陷阱与中断" />
<figcaption aria-hidden="true">异常-陷阱与中断</figcaption>
</figure>
<p>微内核：内核中只包括中断处理、进程通信（IPC）、基本调度等。文件系统、网络功能、内存管理、设备管理等作为服务在微内核上运行。</p>
<ul>
<li>易于实现、可靠性高、可移植性好、配置灵活、适应分布式环境</li>
<li>速度较慢</li>
</ul>
<h2 id="系统引导">系统引导</h2>
<h3 id="bootloader">Bootloader</h3>
<p>引导加载程序是系统加电后运行的第一段软件代码，称为Bootloader，是在操作系统内核运行之前运行的一段小程序</p>
<ul>
<li>Booter:初始化系统硬件使之运行起来，至少是部分运行起来</li>
<li>Loader:将操作系统映像加载到内存中，并跳转到操作系统的代码运行</li>
</ul>
<p>Bootloader的实现严重依赖于具体硬件，难以用一个Bootloader支持所有CPU和系统</p>
<p>U-Boot等Bootloader大多分为stage1和stage2两大阶段</p>
<ul>
<li>stage1：依赖于CPU体系结构的代码（如设备初始化），可用汇编语言实现</li>
<li>stage2：通常C语言实现，可读性、移植性更好</li>
</ul>
<h3 id="mips">MIPS</h3>
<p>32位下，共有4G程序地址空间</p>
<ul>
<li>kuseg(0x0000_0000-0x7FFF_FFFF)：用户可用的地址，需经过MMU转换</li>
<li>kseg0(0x8000_0000-0x9FFF_FFFF)：清零最高位即可映射到物理地址，需通过cache</li>
<li>kseg1(0xA000_0000-0xBFFF_FFFF)：清零高三位即可映射到物理地址，无须cache</li>
<li>kseg2(0xC000_0000-0xFFFF_FFFF)：核心态可用，需经过MMU转换</li>
</ul>
<figure>
<img src="/img/OS/MIPS启动stage1.png" srcset="/img/loading.gif" lazyload alt="MIPS启动stage1" />
<figcaption aria-hidden="true">MIPS启动stage1</figcaption>
</figure>
<figure>
<img src="/img/OS/MIPS启动stage2.png" srcset="/img/loading.gif" lazyload alt="MIPS启动stage2" />
<figcaption aria-hidden="true">MIPS启动stage2</figcaption>
</figure>
<h2 id="内存管理">内存管理</h2>
<p>地址空间：程序使用的逻辑地址的集合</p>
<p>存储空间：存储信息的物理地址的集合</p>
<p>单道程序环境下，可进行静态地址翻译（程序运行之前确定所有物理地址），且地址独立、地址保护</p>
<h3 id="多道程序的存储管理">多道程序的存储管理</h3>
<p>内碎片：指分配给作业的存储空间中未被利用的部分</p>
<p>外碎片：指系统中无法利用的小的空闲分区</p>
<p>跟踪内存：</p>
<ul>
<li>位图表示法，每个分配单元赋予一个字位，记录该分配单元是否闲置</li>
<li>链表表示法，将空闲单元用链表连接起来</li>
</ul>
<h4 id="固定式分区">固定式分区</h4>
<p>把内存划分为若干个固定大小的连续分区。</p>
<ul>
<li>易于实现，开销小。</li>
<li>内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。</li>
</ul>
<h4 id="可变式分区">可变式分区</h4>
<p>分区的边界可以移动，即分区的大小可变。</p>
<ul>
<li>无内碎片</li>
<li>有外碎片</li>
</ul>
<h4 id="分配算法">分配算法</h4>
<ol type="1">
<li>首次适应算法（First
Fit）：从空白区域链的<strong>始端</strong>开始查找，选择第一个足以满足请求的空白块。——低地址留下很多难以利用的小的空闲分区</li>
<li>下次适应算法（Next
Fit）：从上次查找结束的地方开始，只要找到一个足够大的空白区。——缺乏大的空闲分区</li>
<li>最佳适应算法（Best
Fit）：寻找大小最接近于作业所要求的存储区域——剩下的空闲区太小</li>
<li>最坏适应算法（Worst
Fit）：总是寻找最大的空白区——需要大空间的作业得不到满足</li>
<li>快速适应算法：把空闲分区按容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。——查找效率高，不会对任何分区分割；算法复杂，系统开销大</li>
<li>伙伴系统：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块就称为“伙伴”
。具体实现如下</li>
</ol>
<h3 id="程序的存储分配">程序的存储分配</h3>
<h4 id="分配方式">分配方式</h4>
<ol type="1">
<li>直接指定。程序员在编写程序时指定</li>
<li>静态分配。程序员编程时,或由编译程序产生的目的程序,均可从其地址空间的零地址开始；当装配程序对其进行链接装入时才确定它们在主存中的地址。</li>
<li>动态分配。作业在存储空间中的位置,在其装入时确定,在其执行过程中可根据需要申请附加的存储空间,而且一个作业已占用的部分区域不再需要时,可以要求归还给系统。</li>
</ol>
<h4 id="由源码到可执行">由源码到可执行</h4>
<ol type="1">
<li>编译：用户源程序-&gt;若干个目标模块</li>
<li>链接：目标模块+库函数-&gt;可装载模块（通常是单一可执行文件）
<ul>
<li>静态链接：用户一个工程中所需的多个程序采用静态链接的方式链接在一起。当我们希望共享库的函数代码直接链接入程序代码中，也采用静态链接方式</li>
<li>动态链接：用于链接共享库代码。当程序运行中需要某些目标模块时，才对它们进行链接，具有高效且节省内存空间的优点。但相比静态链接，使用动态链接库的程序相对慢。</li>
</ul></li>
<li>装入：可装载模块-&gt;装入内存
<ul>
<li>一般采用动态运行时装入方式</li>
</ul></li>
</ol>
<p>为了保证程序在内存中的位置可以改变。装入程序把装入模块装入内存后，并不立即把装入模块中相对地址转换为绝对地址，而是在程序运行时才进行</p>
<h4 id="程序段">程序段</h4>
<p>一个程序主要由
bss段、data段、text段三个组成的。在C语言之类的程序编译完成之后，已初始化的全局变量保存在data
段中，未初始化的全局变量保存在bss 段中。</p>
<ul>
<li>bss段（bss
segment）：用来存放程序中未初始化的全局变量的一块内存区域。属于静态内存分配。</li>
<li>data段（data
segment）：用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>text段（code segment/text
segment）：用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)</li>
</ul>
<p>text和data段在链接后的可执行文件中</p>
<p>gcc:</p>
<ul>
<li>cc1：预处理器和编译器</li>
<li>as：汇编器</li>
<li>collect2：链接器</li>
</ul>
<h3 id="程序运行">程序运行</h3>
<h4 id="栈帧与调用规范">栈帧与调用规范</h4>
<p>当前函数A调用子函数B，会将子函数B的参数压到自己的栈帧里，并且先压最后一个参数。</p>
<h4 id="装载">装载</h4>
<p>一个segment在文件中的大小小于等于其在内存中的大小</p>
<h4 id="作业进程和程序">作业、进程和程序</h4>
<p>一个作业通常包括程序、数据和操作说明书3部分。每一个进程由进程控制块PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。因此，一个作业可划分为若干个进程来完成，而每一个进程由其实体——程序和数据集合。一个程序可以作为多个进程的运行程序；一个进程也可以运行多个程序</p>
<h3 id="页式存储">页式存储</h3>
<h4 id="机制">机制</h4>
<p>以32位逻辑地址、二级页表、每级页表大小4KB为例</p>
<figure>
<img src="/img/OS/二级页表.png" srcset="/img/loading.gif" lazyload alt="二级页表" />
<figcaption aria-hidden="true">二级页表</figcaption>
</figure>
<p>虚拟地址分为3部分，31-22位这10位代表一级页表的第几项，21-12位这10位代表二级页表的第几项，页内偏移量则是对应的物理页中的偏移。</p>
<p>设虚拟地址为 <code>va</code> ，一级页表基地址为 <code>pgdir</code> ，
<code>PDX(va)</code> 代表高10位，<code>PTX(va)</code> 代表中间10位。</p>
<p>存取过程先拿到一级页表基地址和虚拟地址高10位，从而找到对应的一级页表表项。即
<code>pgdir+PDX(va)</code>
为对应表项的物理地址，<code>*(pgdir+PDX(va))</code>
为一级页表表项的内容，记为 <code>pde=*(pgdir+PDX(va))</code></p>
<p>然后，<code>pde</code> 是二级页表的基地址，从而通过
<code>pde+PTX(va)</code>
拿到对应的二级页表表项的物理地址，<code>*(pde+PTX(va))</code>
为二级页表表项的内容，记为 <code>pte</code></p>
<p><code>pte</code> 就是虚拟地址对应的物理页的地址，此时只需将
<code>pte</code> 低12位换成 <code>va</code> 的低12位就拿到
<code>va</code> 对应的物理地址了。</p>
<ul>
<li>使得逻辑地址可以大于物理地址大小</li>
<li>多级页表可解决一级页表占用存储空间较大的问题</li>
<li>MMU可解决内存访问效率下降的问题（不分页访存1次，二级页表访存3次）</li>
</ul>
<h4 id="页目录自映射">页目录自映射</h4>
<p>仍然以32位逻辑地址、二级页表、每级页表大小4KB为例</p>
<p>32位逻辑地址-&gt;2<sup>20个页表-&gt;每个页表项4字节-&gt;4MB-&gt;2</sup>10个一级页表-&gt;4KB</p>
<p>其中，一级页表称页目录，所有页目录项共占用4KB空间，刚好和页表大小一致。因此，可以将页目录项作为特殊的页表，放入二级页表项中</p>
<p>设所有页表（二级页表）的基地址为 <code>PTbase</code>
，共2^20个页表项，总共占用4MB空间。其中有一个页表大小（4KB）放的是页目录，它的基地址设为
<code>PDbase</code>
，是页表基地址在整个逻辑地址中的相对位置映射到4MB中的位置，即
<code>PDbase=(PTbase&gt;&gt;22)&lt;&lt;12+PTbase</code>
。右移22，得到页表基地址是逻辑空间中的第几页，左移12，乘以每页的大小。自映射目录表项
<code>PDE=(PDbase&gt;&gt;22)&lt;&lt;12+PDbase</code></p>
<h4 id="缺页错误处理过程">缺页错误处理过程</h4>
<p>当进程执行过程中需访问的页面不在物理存储器（内存）中时，会引发发生缺页中断，进行所需页面换入，步骤如下：</p>
<ol type="1">
<li><p>陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护）</p></li>
<li><p>查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位）</p></li>
<li><p>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查）缺页错误处理过程</p></li>
<li><p>查找一个空闲的页框(物理内存中的页面)，如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框。</p></li>
<li><p>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回）</p></li>
<li><p>页框“干净”后，操作系统将保存在磁盘上的页面内容复制到该页框中。</p></li>
<li><p>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</p></li>
<li><p>恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场）</p></li>
<li><p>程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）</p></li>
</ol>
<h4 id="页面置换算法">页面置换算法</h4>
<p>先进先出（First-in, First-out）：先调入内存的页面先被置换出去</p>
<p>改进的FIFO：A是FIFO队列中最旧的页面，且其放入队列后没有被再次访问，则A被立刻淘汰；否则如果放入队列后被访问过，则将A移到FIFO队列头，并且将访问标志位清除。</p>
<p>改进的FIFO之Clock：环形队列，产生缺页错误时，当前指针指向C，如果C被访问过，则清除C的访问标志，并将指针指向下一位；如果C没有被访问过，则将新页面放入到C的位置,
置访问标志，并将指针指向下一位。</p>
<p>最近最少使用（LRU）：设置一个特殊的栈，保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最久未使用页面的页面号</p>
<p>老化算法（AGING）：为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入</p>
<h3 id="段式存储">段式存储</h3>
<p>每个作业的地址空间是由一些分段构成的，每段都有自己的名字（通常是段号），且都是一段连续的地址空间。逻辑地址结构为段号+位移量（加起来不一定是32位）</p>
<h5 id="段表">段表</h5>
<p>• 段表记录了段与内存位置的对应关系。</p>
<p>• 段表保存在内存中。</p>
<p>• 段表的基址及长度由段表寄存器给出。</p>
<p>• 访问一个字节的数据/指令需访问内存两次 (段表一次，内存一次)</p>
<h5 id="地址变换过程">地址变换过程</h5>
<ol type="1">
<li>系统将逻辑地址中的段号 S 与段表长度 TL 进行比较。
<ul>
<li>若 S&gt;TL，表示段号太大，是访问越界，于是产生越界中断信号。</li>
<li>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的始址。</li>
</ul></li>
<li>再检查段内地址 d，是否超过该段的段长 SL。
<ul>
<li>若超过，即 d &gt;SL，同样发出越界中断信号。</li>
<li>若未越界，则将该段的基址与段内地址 d
相加，即可得到要访问的内存物理地址</li>
</ul></li>
</ol>
<h5 id="优缺点">优缺点</h5>
<ul>
<li>分段系统易于实现段的共享，对段的保护也十分简单。</li>
<li>处理机要为地址变换花费时间；要为表格提供附加的存储空间。</li>
<li>为满足分段的动态增长和减少外碎片，要采用拼接手段。</li>
<li>在辅存中管理不定长度的分段困难较多。</li>
<li>分段的最大尺寸受到主存可用空间的限制。</li>
</ul>
<h4 id="段页式">段页式</h4>
<p>将用户程序分成若干个段（段式）
，并为每一个段赋一个段名，再把每个段分成若干个页（页式）
。地址结构由段号、段内页号、及页内位移三部分所组成</p>
<h2 id="进程与并发程序设计">进程与并发程序设计</h2>
<h3 id="一些概念">一些概念</h3>
<p>并发：两个活动在某一指定时间下，无论在同一处理机还是不同处理机，都在各自的起点和终点之间的某一处</p>
<p>并行：两个程序在同一时间度量下同时运行在不同的处理机上</p>
<p>进程特征：</p>
<ul>
<li>并发</li>
<li>共享</li>
<li>不确定性</li>
</ul>
<p><strong>并发条件</strong>——Bernstein条件：</p>
<p>定义 <span class="math inline">\(R(S_i)\)</span> 为进程 <span
class="math inline">\(S_i\)</span> 的读子集，<span
class="math inline">\(W(S_i)\)</span> 为 <span
class="math inline">\(S_i\)</span>
的写子集，则当一下条件同时成立时，进程 <span
class="math inline">\(S_1\)</span> 和 <span
class="math inline">\(S_2\)</span> 可并发</p>
<ul>
<li><span class="math inline">\(R(S_1)\cap
W(S_2)=\emptyset\)</span></li>
<li><span class="math inline">\(W(S_1)\cap
R(S_2)=\emptyset\)</span></li>
<li><span class="math inline">\(W(S_1)\cap
W(S_2)=\emptyset\)</span></li>
</ul>
<p><strong>原语</strong>：由若干条指令所组成的指令序列，来实现某个特定的操作功能。</p>
<ul>
<li>连续不可分割</li>
<li>操作系统核心组成部分</li>
<li>内核态下执行，且常驻内存</li>
</ul>
<p>竞争：两个或多个进程对同一共享数据同时进行访问，而最后的结果是不可预测的，它取决于各个进程对共享数据访问的相对次序。这种情形叫做竞争。</p>
<p>竞争条件：多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关</p>
<p>临界资源：我们将一次仅允许一个进程访问的资源称为临界资源</p>
<p>临界区：每个进程中访问临界资源的那段代码称为临界区。</p>
<p><strong>互斥</strong>：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但无法限制访问者对资源的访问顺序</p>
<p><strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p>
<p>互斥机制设计上的原则：</p>
<ul>
<li>空闲让进：临界资源处于空闲状态，允许进入临界区</li>
<li>忙则等待：临界区有正在执行的进程，所有其他进程不可进入临界区</li>
<li>有限等待：对要求访问临界区的进程应在保证在有限时间内进入自己的临界区，避免死等</li>
<li>让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li>
</ul>
<h3 id="线程">线程</h3>
<p>进程是资源分配的基本单位，线程是处理机调度的基本单位</p>
<p>每个线程由自己的堆栈</p>
<p>线程安全!=可重入</p>
<p>用户级线程：线程在用户空间，通过Library模拟，不需要或仅需极少的内核支持</p>
<ul>
<li>优点：
<ul>
<li>线程切换与内核无关</li>
<li>线程调度由应用决定，易优化</li>
<li>可运行在任何操作系统上</li>
</ul></li>
<li>缺点：
<ul>
<li>系统调用时阻塞所有属于此进程的线程</li>
<li>线程间无法并行</li>
</ul></li>
</ul>
<p>内核级线程：</p>
<ul>
<li>优点：
<ul>
<li>可并行</li>
<li>内核中的一些处理可以通过多线程实现</li>
<li>涉及两种模式的切换</li>
</ul></li>
</ul>
<h3 id="互斥的实现">互斥的实现</h3>
<h4 id="忙等">忙等</h4>
<h5 id="dekker">Dekker</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//进程P</span><br>pturn=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(qturn)&#123;<br>    <span class="hljs-keyword">if</span>(turn==<span class="hljs-number">1</span>)&#123;<br>		pturn=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>        pturn=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*临界区*/</span><br>turn=<span class="hljs-number">1</span>;<br>pturn=<span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//进程Q</span><br>qturn=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(pturn)&#123;<br>    <span class="hljs-keyword">if</span>(turn==<span class="hljs-number">0</span>)&#123;<br>		qturn=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>        qturn=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*临界区*/</span><br>turn=<span class="hljs-number">0</span>;<br>qturn=<span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>
<h4 id="信号量">信号量</h4>
<p>使用一种新的变量类型（semaphore）作为信号量。信号量使用前必须初始化，初始化后只能通过PV操作访问，PV操作不受进程调度的打断。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">Type</span> semaphore = <span class="hljs-keyword">record</span><br>	value : integer;<br>	L : list <span class="hljs-keyword">of</span> process;<br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">P</span><span class="hljs-params">(S)</span></span><br><span class="hljs-function">	<span class="hljs-title">var</span> <span class="hljs-title">S</span> :</span> semaphore;<br>	<span class="hljs-keyword">begin</span> <br>		S.value := S.value -<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> S.value&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> block(S.L);<br>	<span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">V</span><span class="hljs-params">(S)</span></span><br><span class="hljs-function">	<span class="hljs-title">var</span> <span class="hljs-title">S</span> :</span> semaphore;<br>	<span class="hljs-keyword">begin</span><br>		S.value := S.value + <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">if</span> S.value&lt;=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> wakeup(S.L)<br>	<span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>P操作分配资源，V操作释放资源。</p>
<h3 id="经典进程同步问题">经典进程同步问题</h3>
<h4 id="生产者-消费者">生产者-消费者</h4>
<p>问题描述：若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//互斥</span><br>semaphore empty=N;	<span class="hljs-comment">//空闲数量</span><br>semaphore full=<span class="hljs-number">0</span>;	<span class="hljs-comment">//产品数量</span><br>ItemType buffer[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>, out =<span class="hljs-number">0</span>;<br>producer() &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>		生产产品nextp;<br>		P(empty);<br>		P(mutex);<br>		buffer[in] = nextp;<br>		in = (in + <span class="hljs-number">1</span>) MOD n;<br>		V(mutex);<br>		V(full);<br>	&#125;<br>&#125;<br>consumer() &#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>		P(full);<br>		P(mutex);<br>		nextc = buffer[out];<br>		out = (out + <span class="hljs-number">1</span>) MOD n;<br>		V(mutex);<br>		V(empty);<br>		消费nextc中的产品<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="读者-写者问题">读者-写者问题</h4>
<p>问题描述：对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个，即“读－写”互斥，“写－写”互斥，“读－读”允许</p>
<h5 id="读者优先">读者优先</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore wmutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//允许写</span><br><span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;	<span class="hljs-comment">//正在读的数量</span><br>semaphore mutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//对readcount的互斥</span><br><br><span class="hljs-comment">//Writer</span><br>P(wmutex);<br>	write;<br>V(wmutex);<br><br><span class="hljs-comment">//Reader</span><br>P(mutex);<br>	<span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then P(wmutex);<br>	readcount := readcount +<span class="hljs-number">1</span>;<br>V(mutex);<br>read<br><span class="hljs-title function_">P</span><span class="hljs-params">(mutex)</span><br>	readcount := readcount <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then V(wmutex);<br>V(mutex)<br></code></pre></td></tr></table></figure>
<h5 id="读写公平">读写公平</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore wmutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//允许写</span><br><span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;	<span class="hljs-comment">//正在读的数量</span><br>semaphore mutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//对readcount的互斥</span><br>semaphore rwmutex =<span class="hljs-number">1</span>;	<span class="hljs-comment">//对readcount的互斥</span><br><br><span class="hljs-comment">//Writer</span><br>P(rwmutex);<br>P(wmutex);<br>	write;<br>V(wmutex);<br>V(rwmutex);<br><br><span class="hljs-comment">//Reader</span><br>P(rwmutex);<br>P(mutex);<br>	<span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then P(wmutex);<br>	readcount := readcount +<span class="hljs-number">1</span>;<br>V(mutex);<br>V(rwmutex);<br>read<br><span class="hljs-title function_">P</span><span class="hljs-params">(mutex)</span><br>	readcount := readcount <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then V(wmutex);<br>V(mutex)<br></code></pre></td></tr></table></figure>
<h5 id="写者优先">写者优先</h5>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。</p>
<p>如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐；不出现有人永远拿不到筷子</p>
<p>思路：</p>
<ul>
<li><p>至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。（破除<strong>资源互斥</strong>）</p></li>
<li><p>对筷子进行编号，奇数号先拿左，再拿右；偶数号相反。（破除<strong>循环等待</strong>）</p></li>
<li><p>同时拿起两根筷子，否则不拿起。（破除<strong>保持等待</strong>）</p></li>
</ul>
<h4 id="理发师问题">理发师问题</h4>
<p>理发店里有1位理发师、1把理发椅和n把供等候理发的顾客坐的椅子；如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师；如果理发师正在理发时，又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> waiting = <span class="hljs-number">0</span>;<br>semaphore mutex=<span class="hljs-number">1</span>;<br>semaphore custormers=<span class="hljs-number">0</span>;<br>semaphore barber=<span class="hljs-number">0</span>;<br><br>Barber:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>	P(custormers);<br>	P(mutex);<br>	waiting --;<br>	V(mutex);<br>	V(barber);<br>	CutHair();<br>&#125;<br><br>Custom_i:<br>P(mutex);<br><span class="hljs-keyword">if</span> (waiting &lt; N) &#123;<br>	waiting ++;<br>	V(mutex);<br>	V(custormers);<br>	P(barber);<br>	GetCutHair();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>	V(mutex);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="进程调度">进程调度</h3>
<p>进程切换步骤：</p>
<ol type="1">
<li>保存处理器的上下文，包括程序计数器和其它寄存器</li>
<li>用新状态和其它相关信息更新正在运行进程的PCB</li>
<li>把进程移至合适的队列：就绪、阻塞</li>
<li>选择另一个要执行的进程更新被选中进程的PCB（新状态等）</li>
<li>从被选中进程中重装入CPU 上下文</li>
</ol>
<h4 id="评价指标">评价指标</h4>
<p>周转时间：作业从提交到完成所经历的时间，包括执行、等待时间</p>
<p>平均周转时间：所有作业周转时间的平均值</p>
<p>带权周转时间：周转时间/服务时间</p>
<p>响应时间：用户输入一个请求，系统首次给出响应的时间</p>
<p>吞吐量：单位时间内所完成的作业数（不等于平均周转时间的倒数）</p>
<p>处理机利用率：忙碌时间/总时间</p>
<h4 id="调度细节">调度细节</h4>
<p>进程优先级：</p>
<ul>
<li>静态优先级：运行过程中不再改变</li>
<li>动态优先级：运行过程中可以动态变化</li>
</ul>
<p>进程就绪队列：</p>
<ul>
<li>按优先级排队，CPU调度优先级较高的进程执行</li>
<li>创建时都进入第一级，随进程运行，可能降低某些进程的优先级</li>
</ul>
<p>占用CPU的方式：</p>
<ul>
<li><p>不可抢占式：一旦处理器被分配给一个进程，就死赖着不走，直到进程调度</p></li>
<li><p>抢占式：就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，让位</p></li>
</ul>
<p>进程分类：</p>
<p>CPU密集/IO密集</p>
<p>批处理/交互式进程/实时进程</p>
<h4 id="批处理调度算法">批处理调度算法</h4>
<p>特点：不要求交互、实时性不强</p>
<h5 id="先来先服务fcfs">先来先服务FCFS</h5>
<p>字面意思</p>
<h5 id="短作业优先sjf">短作业优先SJF</h5>
<p>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业</p>
<p>优点：</p>
<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统吞吐量</li>
</ul>
<p>缺点：</p>
<ul>
<li>对长作业非常不利，可能长时间得不到执行；</li>
<li>未能依据作业的紧迫程度来划分执行的优先级</li>
<li>难以准确估计作业（进程）的执行时间，从而影响调度性能。</li>
</ul>
<h5 id="最短剩余时间srtf">最短剩余时间SRTF</h5>
<p>将SJF改为抢占式</p>
<p>缺点：源源不断的短任务到来，可能使长的任务长时间得不到运行，导致产生“饥饿”现象</p>
<h5 id="最高响应比优先hrrf">最高响应比优先HRRF</h5>
<p>在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP(响应优先级)，然后选择其值最大的作业投入运行。</p>
<p><span
class="math inline">\(\text{RR}=\dfrac{\text{已等待时间+要求运行时间}}{要求运行时间}\)</span>​</p>
<p>短作业容易得到较高的响应比，长作业等待时间足够长后，也将获得足够高的响应比。饥饿现象不会发生</p>
<p>缺点：每次计算各道作业的响应比会有一定的时间开销，性能比SJF略差。</p>
<h4 id="交互式系统的调度算法">交互式系统的调度算法</h4>
<h5 id="时间片轮转round-robin算法">时间片轮转(Round Robin)算法</h5>
<p>【排队】将系统中所有的就绪进程按照FCFS原则，排成一个队列。</p>
<p>【轮转】每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。</p>
<p>【中断】在一个时间片结束时，发生时钟中断。</p>
<p>【抢占】调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</p>
<p>【出让】进程可以未使用完一个时间片，就出让CPU（如阻塞）。</p>
<h5 id="多级队列算法">多级队列算法</h5>
<p>引入多个就绪队列，每个队列固定归入一个队列，不同队列可有不同的优先级、时间片长度、调度策略等。</p>
<h5 id="多级反馈队列算法">多级反馈队列算法</h5>
<p>设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍</p>
<p>新进程进入内存后，先投入队列1的末尾，按“时间片轮转”算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按“时间片轮转”算法调度；如此下去，降低到最后的队列，则按“FCFS”算法调度直到完成。</p>
<p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</p>
<p>问题：优先级倒置（高优先级进程被低优先级进程阻塞）。解决：优先级置顶、优先级继承（同一临界资源）</p>
<h4 id="实时系统的调度算法">实时系统的调度算法</h4>
<p>特点：实时性强</p>
<h5 id="静态表调度">静态表调度</h5>
<p>事先确定固定的调度方案</p>
<h5 id="单调速率调度">单调速率调度</h5>
<p>优先级静态固定分配：优先级与周期成反比，周期越短优先级越高。优先级高的任务先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度</p>
<p>任务在周期起点释放，高优先级任务可抢占低优先级任务的执行</p>
<h5 id="最早截止时间优先算法">最早截止时间优先算法</h5>
<p>任务的绝对截止时间越早，其优先级越高，优先级最高的任务最先被调度（动态优先级）</p>
<p>如果两个任务的优先级一样，当调度它们时，EDF算法将随机选择一个调度</p>
<h5 id="最低松弛度优先算法llf">最低松弛度优先算法LLF</h5>
<p>根据任务紧急（或松弛）的程度，来确定任务的优先级。任务的紧急度越高，其优先级越高，并使之优先执行。</p>
<p>松弛度=进程截止时间-本身剩余运行时间-当前时间</p>
<p>=进程最晚开始时间-当前时间</p>
<h4 id="多处理机调度">多处理机调度</h4>
<p>（对称式多处理系统SMP）</p>
<p>集中控制：静态、动态分配。分散控制：自调度</p>
<ul>
<li><p>静态分配：每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上。</p>
<ul>
<li>优点：调度算法开销小。</li>
<li>缺点：容易出现忙闲不均</li>
</ul></li>
<li><p>动态分配：所有CPU采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。</p></li>
<li><p>自调度：整个系统采用一个公共就绪队列，每个处理机都可以从队列中选择适当进程来执行。可采用单处理机的（成熟）调度技术，是最常用的算法，实现时易于移植。</p>
<ul>
<li>优点：不需要专门的处理机从事任务分派工作。</li>
<li>缺点：队列同步开销：各处理机共享就绪队列；缓存更新开销：被阻塞的进程重新运行时不一定仍在阻塞前的处理机上运行，那么高速缓存中的内容需要重置；线程协作开销：由于合作中的几个线程没有同时运行而受阻，进而被切换下来</li>
</ul></li>
<li><p>成组调度：将一个进程中的一组线程，每次分派时同时到一组处理机上执行，在剥夺处理机时也同时对这一组线程进行</p>
<ul>
<li>优点：通常这样的一组线程在应用逻辑上相互合作，成组调度提高了这些线程的执行并行度，有利于减少阻塞和加快推进速度，最终提高系统吞吐量。每次调度可以完成多个线程的分派，在系统内线程总数相同时能够减少调度次数，从而减少调度算法的开销</li>
</ul></li>
<li><p>专用处理机调度：为进程中的每个线程都固定分配一个CPU，直到该线程执行完成（多用于CPU数量众多的高度并行系统）</p>
<ul>
<li>优点：线程执行时不需切换，相应的开销可以大大减小，推进速度更快。</li>
<li>缺点：线程阻塞时，造成CPU的闲置。</li>
</ul></li>
</ul>
<h3 id="死锁">死锁</h3>
<p>定义：一组进程中，每个进程都无限等待被该组进程中其它进程所占有的资源，在无外力介入的条件下，将因永远分配不到资源而无法运行的现象。</p>
<p>发生原因： 资源竞争、并发执行的顺序不当</p>
<p>发生的必要条件</p>
<ul>
<li>互斥条件：指进程对所分配到的资源进行<strong>排它性使用</strong>，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>
<li>请求且占有条件：指进程已经占有至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己<strong>已获得的其它资源保持不放</strong>。</li>
<li>不可剥夺条件：指进程已获得的资源，在未使用完之前，<strong>不能被剥夺</strong>，只能在使用完时由自己释放。</li>
<li>环路等待条件：</li>
<li>指在发生死锁时，<strong>必然存在一个进程——资源的环形链</strong>，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ul>
<p>活锁：任务一直尝试、失败、尝试、失败，但没有被阻塞</p>
<p>饥饿：资源分配不公导致长时间等待</p>
<figure>
<img src="/img/OS/死锁.png" srcset="/img/loading.gif" lazyload alt="死锁" />
<figcaption aria-hidden="true">死锁</figcaption>
</figure>
<h4 id="死锁预防">死锁预防</h4>
<p>破坏死锁的产生条件</p>
<p>某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m+n，试讨论，该系统可能发生死锁吗?
并简述理由。</p>
<p>答：不可能。最坏情况下，n个进程同时申请了m+n-1台打印机，但每个进程都1差台才能完成，则实际已经分配了m-1台，还剩一台打印机可分配给任意进程解除等待状态，因此不会死锁</p>
<h4 id="死锁避免">死锁避免</h4>
<p>在资源分配之前进行判断</p>
<p>安全序列：一个进程序列&lt;P1，P2，...，Pn&gt;是安全的，是指若对于每一个进程Pi，它需要的附加资源可以被系统中当前可用资源加上所有进程Pj（j
&lt;
i）当前占有资源之和所满足，则&lt;P1，P2，...，Pn&gt;为一个安全序列</p>
<p>安全状态：系统存在一个安全序列。否则为不安全状态（但不一定死锁，但死锁必不安全）。</p>
<p>银行家算法：假定顾客借款分成若干次进行；并在第一次借款时，能说明他的最大借款额。具体算法：顾客的借款操作依次顺序进行，直到全部操作完成；银行家对当前顾客的借款操作进行判断，以确定其安全性（能否支持顾客借款，直到全部归还）；安全时，贷款；否则，暂不贷款</p>
<h4 id="死锁检测">死锁检测</h4>
<figure>
<img src="/img/OS/资源分配图1.png" srcset="/img/loading.gif" lazyload alt="资源分配图1" />
<figcaption aria-hidden="true">资源分配图1</figcaption>
</figure>
<figure>
<img src="/img/OS/资源分配图2.png" srcset="/img/loading.gif" lazyload alt="资源分配图2" />
<figcaption aria-hidden="true">资源分配图2</figcaption>
</figure>
<h4 id="死锁解除">死锁解除</h4>
<ul>
<li>撤销进程：使全部死锁的进程夭折掉；按照某种顺序逐个地撤消（回退）进程，直至有足够的资源可用，死锁状态消除为止。</li>
<li>剥夺资源：使用挂起/激活挂起一些进程，剥夺它们的资源以解除死锁，待条件满足时，再激活进程</li>
</ul>
<h2 id="io">IO</h2>
<p>IO设备分为块设备和字符设备</p>
<figure>
<img src="/img/OS/IO层次关系.png" srcset="/img/loading.gif" lazyload alt="IO层次关系" />
<figcaption aria-hidden="true">IO层次关系</figcaption>
</figure>
<h3 id="io控制技术">IO控制技术</h3>
<h4 id="程序控制">程序控制</h4>
<p>称轮询或查询方式I/O，它由CPU代表进程向I/O模块发出指令，
然后进入忙等状态， 直到操作完成之后进程才能够继续执行。</p>
<figure>
<img src="/img/OS/轮询IO.png" srcset="/img/loading.gif" lazyload alt="轮询IO" />
<figcaption aria-hidden="true">轮询IO</figcaption>
</figure>
<h4 id="中断驱动">中断驱动</h4>
<p>当I/O操作结束后由设备控制器主动地来通知设备驱动程序说这次结束，而不是设备驱动程序不断地去轮询看看设备的状态。</p>
<ul>
<li>优点：CPU不必忙等，提高CPU利用率，可以处理不确定事件</li>
<li>缺点：每次输入、输出一个数据都要中断CPU，多次中断浪费CPU时间</li>
</ul>
<figure>
<img src="/img/OS/中断IO.png" srcset="/img/loading.gif" lazyload alt="中断IO" />
<figcaption aria-hidden="true">中断IO</figcaption>
</figure>
<h4 id="dma">DMA</h4>
<p>直接存储器访问方式，是由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p>
<ul>
<li>优点：CPU只需干预I/O操作的开始和结束，而其中的一批数据读写无需CPU控制，适于高速设备。</li>
<li>缺点：数据传送的方向、存放数据的内存地址及传送数据的长度等都由CPU控制，占用了CPU时间。而且每个设备占用一个DMA控制器，当设备增加时，需要增加新的DMA控制器</li>
</ul>
<p>与中断区别：</p>
<ul>
<li>中断控制方式在每个数据传送完成后中断CPU；DMA控制方式是在要求传送的一批数据完成之后中断CPU。</li>
<li>中断控制方式的数据传送是在中断处理时由CPU控制完成的，由于程序陷入内核，需要保护和恢复现场。DMA方式下是由DMA控制器控制完成的，在传输过程中不需要CPU干预，DMA控制器直接在主存和I/O设备之间传送数据，只有开始和结束才需要CPU干预。</li>
<li>程序中断方式具有对异常事件的处理能力，而DMA控制方式适用于数据块的传输。</li>
</ul>
<h4 id="通道">通道</h4>
<p>与DMA的原理几乎是一样的，通道是一个特殊功能的处理器，它有自己的指令和程序专门负责数据输入输出的传输控制。CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部运算与I/O设备的并行工作。</p>
<ul>
<li>DMA方式的发展，进一步减少CPU干预。把对一个数据块的读写干预，减少为对一组数据块读写的干预。</li>
<li>I/O通道是专门负责输入输出的处理器，独立于CPU，有自己的指令体系。可执行由通道指令组成的通道程序，因此可以进行较为复杂的I/O控制。通道程序通常由操作系统所构造，放在内存里。</li>
<li>优点：执行一个通道程序可以完成几组I/O操作，与DMA相比，减少了CPU干预。</li>
<li>缺点：费用较高。</li>
</ul>
<p>与DMA区别：</p>
<ul>
<li>DMA方式下，数据的传送方向、存放数据的内存起始地址和数据块长度都由CPU控制；而通道是一个特殊的处理器，有自己的指令和程序，通过执行通道程序实现对数据传输的控制，所以通道具有更强的独立处理I/O的功能。</li>
<li>DMA控制器通常只能控制一台或者少数几台同类设备；而一个通道可同时控制多种设备</li>
</ul>
<h3 id="缓冲">缓冲</h3>
<ul>
<li>匹配CPU与外设的不同处理速度</li>
<li>减少对CPU的中断次数。</li>
<li>提高CPU和I/O设备之间的并行性。</li>
</ul>
<p>种类：单缓冲、双缓冲、环形缓冲、缓冲池</p>
<h3 id="设备分配">设备分配</h3>
<ul>
<li><p>DCT：设备控制表，每个设备一张，描述设备的特性和状态</p></li>
<li><p>COCT：控制器控制表（如DMA控制器，描述DMA占用的中断号……）。</p></li>
<li><p>CHCT：通道控制表，描述通道工作状态</p></li>
<li><p>SDT：系统设备表，系统内一张，记录所有设备相关信息。包括DCT指针等</p></li>
</ul>
<p>分配过程：</p>
<ol type="1">
<li>根据物理设备名查SDT，找到对应的DCT，若设备忙则等待，否则计算是否死锁然后进行分配</li>
<li>将设备分配给进程后，找到DCT所属的COCT，空闲则分配，否则等待</li>
<li>找到COCT所属CHCT，空闲则分配，否则等待</li>
</ol>
<h3 id="假脱机技术">假脱机技术</h3>
<p>把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p>
<p>应用程序进行I/O操作时，只是和SPOOLing程序交换数据，可以称为虚拟I/O</p>
<p>特点：</p>
<ul>
<li>高速。应用程序的虚拟I/O比实际I/O速度提高</li>
<li>独享设备的共享。由SPOOLing程序提供虚拟设备，可以对独享设备依次共享使用</li>
</ul>
<h2 id="磁盘存储管理">磁盘存储管理</h2>
<h3 id="基本概念">基本概念</h3>
<figure>
<img src="/img/OS/磁盘概念.png" srcset="/img/loading.gif" lazyload alt="磁盘概念" />
<figcaption aria-hidden="true">磁盘概念</figcaption>
</figure>
<p>磁盘访问时间=寻道时间+旋转延迟时间+传输时间</p>
<h4 id="寻道时间">寻道时间</h4>
<p>把磁头从当前位置移动到指定磁道上所经历的时间。该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和</p>
<p><span class="math inline">\(T_s=m\times n+s\)</span></p>
<h4 id="旋转延迟时间">旋转延迟时间</h4>
<p>3600RPM即每分钟3600转——每秒60转——每转16.7ms——平均旋转延迟时间 <span
class="math inline">\(T_r\)</span> 为8.3ms</p>
<h4 id="传输时间">传输时间</h4>
<p>指把数据从磁盘读出，或向磁盘写入数据所经历的时间，与每次所读／写的字节数b，旋转速度r以及磁道上的字节数N有关</p>
<p><span class="math inline">\(T_t=\dfrac{b}{rN}\)</span></p>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<h4 id="先来先服务fcfs-1">先来先服务（FCFS）</h4>
<p>按访问请求到达的先后次序服务</p>
<h4 id="最短寻道时间优先算法sstf">最短寻道时间优先算法（SSTF）</h4>
<p>优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。</p>
<ul>
<li>优点：改善了磁盘平均服务时间</li>
<li>缺点：可能产生“饥饿” 现象，造成某些访问请求长期等待得不到服务。</li>
</ul>
<h4 id="扫描算法scan">扫描算法（SCAN）</h4>
<p>类似电梯调度中的LOOK算法，但是要到边界才返回</p>
<p>当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。</p>
<ul>
<li>优点：既考虑了距离，又考虑了方向</li>
<li>缺点：摆动式扫描，两侧磁道访问概率仍低于中间磁道</li>
</ul>
<h4 id="循环扫描算法cscan">循环扫描算法（CSCAN）</h4>
<p>按照所要访问的柱面位置的次序去选择访问者。移动臂到达最后一个柱面后，立即带动读写磁头快速返回到0号柱面。返回时不为任何的等待访问者服务。返回后可再次进行扫描。</p>
<h4 id="look">LOOK</h4>
<p>把到边界才返回的scan类算法改成到离边界最近的请求处返回，就产生了LOOK、C-LOOK算法</p>
<h4 id="n-step-scan">N-Step-SCAN</h4>
<p>将请求队列分成分成长度为N的子队列，队列之间采用FCFS，队列内部采用SCAN</p>
<ul>
<li>可以解决“磁壁粘着”问题：一个或几个进程对某个磁道有较高的访问频率，从而垄断了整个磁盘设备</li>
</ul>
<p>N=2时成为FSCAN</p>
<h3 id="raid">RAID</h3>
<p>一种把多块独立的硬盘（物理硬盘）按照不同方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据冗余的技术。</p>
<ul>
<li>成本低、功耗小、传输速率高、可提供容错功能</li>
</ul>
<figure>
<img src="/img/OS/RAID说明.png" srcset="/img/loading.gif" lazyload alt="RAID说明" />
<figcaption aria-hidden="true">RAID说明</figcaption>
</figure>
<h4 id="raid0">RAID0</h4>
<p>仅提供了并行交叉存取，提高IO速度，但无冗余功能</p>
<h4 id="raid1">RAID1</h4>
<p>镜像磁盘冗余阵列，将每一数据块重复存入镜像磁盘</p>
<ul>
<li>读性能好，写性能由最差磁盘决定</li>
<li>有效容量减半</li>
</ul>
<h4 id="raid-01">RAID 01</h4>
<p>综合RAID0和RAID1的特点</p>
<p>其中RAID
0+1指先分块后镜像，物理磁盘与镜像磁盘间无明显一一对应关系</p>
<p>RAID 1+0指先镜像后分块，物理磁盘与镜像磁盘间一一对应关系</p>
<h4 id="raid2">RAID2</h4>
<p>采用海明码纠错的磁盘阵列，将数据位交叉写入几个磁盘中。按位条带化。</p>
<ul>
<li><p>并行存取，各个驱动器同步工作。</p></li>
<li><p>使用海明编码来进行错误检测和纠正，数据传输率高。</p></li>
<li><p>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。</p></li>
</ul>
<h4 id="raid3">RAID3</h4>
<p>将磁盘分组，采用字节级别的条带，读写要访问组中所有盘，每组中有一个盘作为校验盘。校验盘一般采用奇偶校验</p>
<ul>
<li>恢复时间较长</li>
<li>读写性能的水桶效应瓶颈</li>
</ul>
<h4 id="raid4">RAID4</h4>
<p>并行处理磁盘阵列：一种独立传送磁盘阵列，采用数据块交叉，用一个校验盘。将数据按块交叉存储在多个磁盘上</p>
<figure>
<img src="/img/OS/RAID4.png" srcset="/img/loading.gif" lazyload alt="RAID4" />
<figcaption aria-hidden="true">RAID4</figcaption>
</figure>
<ul>
<li><p>冗余代价与RAID3相同</p></li>
<li><p>访问数据的方法与RAID3不同。在RAID3中，一次磁盘访问将对磁盘阵列中的所有磁盘进行（同步）操作。</p></li>
<li><p>RAID4出现的原因：希望使用较少的磁盘参与操作，以使磁盘阵列可以并行进行多个数据的磁盘操作。</p></li>
<li><p>随机读快，随机写慢（竞争同一个校验盘）</p></li>
</ul>
<h4 id="raid5">RAID5</h4>
<p>一种独立传送磁盘阵列，采用数据块交叉和分布的冗余校验，将数据和校验都分布在各个磁盘中，没有专门的奇偶校验驱动器</p>
<figure>
<img src="/img/OS/RAID5.png" srcset="/img/loading.gif" lazyload alt="RAID5" />
<figcaption aria-hidden="true">RAID5</figcaption>
</figure>
<h4 id="raid6">RAID6</h4>
<p>双维校验独立存取盘阵列，数据以块（块大小可变）交叉方式存于各盘，检、纠错信息均匀分布在所有磁盘上。</p>
<figure>
<img src="/img/OS/RAID6.png" srcset="/img/loading.gif" lazyload alt="RAID6" />
<figcaption aria-hidden="true">RAID6</figcaption>
</figure>
<ul>
<li><p>写入数据要访问1个数据盘和2个冗余盘；</p></li>
<li><p>可容忍双盘出错；</p></li>
<li><p>存储开销是RAID5的两倍（多一个冗余盘）。</p></li>
</ul>
<h3 id="提高io速度">提高IO速度</h3>
<ul>
<li>选择性能好的磁盘</li>
<li>并行化</li>
<li>采用适当的调度算法</li>
<li>设置磁盘高速缓冲区</li>
</ul>
<h2 id="文件管理">文件管理</h2>
<h3 id="基本概念-1">基本概念</h3>
<p>需求：存储<strong>大量</strong>数据、<strong>长期</strong>保存、可<strong>共享</strong></p>
<p>文件：一种抽象机制，可以视为一个单独的连续的逻辑地址空间，其大小即为文件的大小，与进程的地址空间无关。或：信息项的序列（信息项是构成文件的基本单位，由单个字节或多个字节构成）</p>
<p>文件系统：本质为操作系统中统一管理信息资源的一个软件</p>
<p>Unix将文件分为普通文件、目录文件、特殊文件</p>
<ul>
<li>普通文件：用户自己建立的文件</li>
<li>目录文件：管理文件系统的系统文件</li>
<li>特殊文件：字符设备文件（和输入输出有关，如中断、打印机等）、块设备文件（磁带、磁盘等）</li>
</ul>
<p>文件系统模型的三个层次分别为文件系统接口、对象操作管理的软件集合、对象及其属性</p>
<p>提高文件系统性能：磁盘碎片整理、块高速缓存、RAID</p>
<h3 id="文件结构">文件结构</h3>
<p>逻辑结构上，有字节序列、记录序列、树等</p>
<ul>
<li>流式文件：基本单位为字符，有逻辑意义无结构</li>
<li>记录式文件：由若干条记录组成，可以按记录进行读写、查找等操作。每条记录有其内部结构</li>
</ul>
<h4 id="目录">目录</h4>
<p>文件目录是由文件说明索引组成的用于文件检索的特殊文件。文件目录的内容一般不包括文件内容，主要是文件访问和控制信息</p>
<ul>
<li>单级文件目录</li>
<li>二级文件目录（根目录+用户目录）</li>
<li>多级文件目录（内容文下一级目录名+指向下一级目录的指针+指向文件物理地址的指针）。层次清楚、可解决重名问题、查找速度快，但目录级数过多会增加路径检索时间</li>
</ul>
<p>文件目录有两种实现方法：</p>
<ul>
<li>直接法：目录项=文件名+FCB（如MS-DS/Windows）</li>
<li>间接法：目录项=文件名+FCB的地址（如Unix采用inode）</li>
</ul>
<h4 id="文件控制块fcb">文件控制块（FCB）</h4>
<ul>
<li>基本信息：文件名、物理位置、文件逻辑结构、物理结构等</li>
<li>访问控制信息：文件所有者、访问权限等</li>
<li>使用信息：创建时间、上一次修改时间等</li>
</ul>
<h4 id="文件物理结构">文件物理结构</h4>
<p>文件在存储介质上的存放方式</p>
<h5 id="连续结构">连续结构</h5>
<figure>
<img src="/img/OS/文件连续存储.png" srcset="/img/loading.gif" lazyload alt="文件连续存储" />
<figcaption aria-hidden="true">文件连续存储</figcaption>
</figure>
<ul>
<li>优点：
<ul>
<li>结构简单、实现容易、没有额外开销</li>
<li>支持顺序存取、随机存取</li>
</ul></li>
<li>缺点：
<ul>
<li>文件长度不易改变</li>
<li>不利于文件的动态增加和修改</li>
</ul></li>
</ul>
<p>适用于变化不大的顺序访问的文件</p>
<h5 id="串联链接文件结构">串联/链接文件结构</h5>
<figure>
<img src="/img/OS/链接存储结构.png" srcset="/img/loading.gif" lazyload alt="链接存储结构" />
<figcaption aria-hidden="true">链接存储结构</figcaption>
</figure>
<ul>
<li>优点：
<ul>
<li>空间利用率高；能较好的利用辅存空间</li>
<li>文件动态扩充和修改容易</li>
<li>顺序存取效率高</li>
</ul></li>
<li>缺点：
<ul>
<li>随机存取效率太低</li>
<li>可靠性问题，如指针出错</li>
<li>链接指针占用一定的空间</li>
</ul></li>
</ul>
<h5 id="索引结构">索引结构</h5>
<p>索引文件在存储区中占两个区：索引区和数据区。索引区存放索引表，数据区存放数据文件本身。</p>
<p>访问索引文件需要两步操作：查文件索引号，由逻辑块号查得物理块号；由此磁盘物理块号而获得所要求的信息</p>
<ul>
<li>优点：
<ul>
<li>既能顺序存取，又能随机存取</li>
<li>满足了文件动态增长、插入删除的要求</li>
<li>能充分利用外存空间</li>
</ul></li>
<li>缺点：索引表本身带来了系统开销</li>
</ul>
<figure>
<img src="/img/OS/索引存储结构.png" srcset="/img/loading.gif" lazyload alt="索引存储结构" />
<figcaption aria-hidden="true">索引存储结构</figcaption>
</figure>
<h3 id="磁盘空间的管理">磁盘空间的管理</h3>
<h4 id="空闲表">空闲表</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">序号</th>
<th style="text-align: center;">第一块空闲盘块号</th>
<th style="text-align: center;">空闲盘块数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<h4 id="空闲链表">空闲链表</h4>
<p>将所有的空闲盘区连成一条空闲链，可有两种方式：空闲盘块链（可能很长）、空闲盘区链（不会很长，但回收复杂）。</p>
<h4 id="位图">位图</h4>
<figure>
<img src="/img/OS/位图法.png" srcset="/img/loading.gif" lazyload alt="位图法" />
<figcaption aria-hidden="true">位图法</figcaption>
</figure>
<h4 id="成组链接">成组链接</h4>
<figure>
<img src="/img/OS/成组链接法.png" srcset="/img/loading.gif" lazyload alt="成组链接法" />
<figcaption aria-hidden="true">成组链接法</figcaption>
</figure>
<h3 id="文件保护">文件保护</h3>
<p>方法：</p>
<ul>
<li>建立副本</li>
<li>定时转储(Unix)</li>
<li>规定文件的权限</li>
</ul>
<p>文件一致性检查：</p>
<ul>
<li><p>磁盘块的一致性：每个磁盘块设置两个计数器，一个记录在文件中出现的次数，另一个记录在空闲块中出现的次数，最终检查两个计数器是否存在不一致问题。</p></li>
<li><p>文件的一致性：每个文件设置两个计数器，一个记录其i节点被引用的次数，另一个记录文件目录中引用它的次数，最终检查两个计数器是否存在不一致问题</p></li>
</ul>
<h3 id="文件系统实例">文件系统实例</h3>
<h4 id="fat文件系统ms-dos">FAT文件系统（MS DOS）</h4>
<p>主引导记录(MBR)+分区表+分区</p>
<p>分区中，引导区（文件系统数据）+文件分配表FAT（描述簇的分配状态、下一簇簇号等等）</p>
<figure>
<img src="/img/OS/FAT-DOS.png" srcset="/img/loading.gif" lazyload alt="FAT-DOS" />
<figcaption aria-hidden="true">FAT-DOS</figcaption>
</figure>
<p>目录项大小为32字节，包括文件名、子目录、文件长度、第一簇的编号。文件名不区分大小写</p>
<figure>
<img src="/img/OS/FAT2.png" srcset="/img/loading.gif" lazyload alt="FAT2" />
<figcaption aria-hidden="true">FAT2</figcaption>
</figure>
<h3 id="ext2文件系统">ext2文件系统</h3>
<p>利用索引节点(inode)来描述，每个文件对应一个inode，inode对应一个标识符，inode保存在索引节点表中。</p>
<p>目录也有索引节点，索引节点指向目录项</p>
<figure>
<img src="/img/OS/EXT2.png" srcset="/img/loading.gif" lazyload alt="EXT2" />
<figcaption aria-hidden="true">EXT2</figcaption>
</figure>
<p>文件系统的超块包含文件系统基本形式</p>
<p>组描述符</p>
<figure>
<img src="/img/OS/索引节点inode.png" srcset="/img/loading.gif" lazyload alt="索引节点inode" />
<figcaption aria-hidden="true">索引节点inode</figcaption>
</figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OS/" class="category-chain-item">OS</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OS理论笔记</div>
      <div>https://solor-wind.github.io/2024/07/02/OS理论笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>gpf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/02/shell-challenge%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/" title="OS挑战性任务设计文档">
                        <span class="hidden-mobile">OS挑战性任务设计文档</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
