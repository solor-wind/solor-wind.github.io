<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2024/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span><br />源码见 <ahref="https://github.com/solor-wind/BUAA_OO">https://github.com/solor-wind/BUAA_OO</a></p></blockquote><h2 id="题目概述">题目概述</h2><p>第一单元的主题是表达式括号展开，要求读入一个包含加、减、乘、乘方以及括号的表达式，输出恒等变形展开所有必要括号括号后的表达式。</p><ul><li>第一周：括号嵌套仅一层、单变量</li><li>第二周：新增表达式因子、自定义函数因子，允许多层嵌套</li><li>第三周：支持求导因子、函数定义时允许引用已定义函数。</li></ul><h2 id="量化分析">量化分析</h2><h3 id="代码量">代码量</h3><figure><img src="/img/OO/OO第一单元代码量.png" alt="OO第一单元代码量" /><figcaption aria-hidden="true">OO第一单元代码量</figcaption></figure><h3 id="复杂度">复杂度</h3><p><img src="/img/OO/OO第一单元类复杂度.png" alt="OO第一单元类复杂度" style="zoom: 80%;" /></p><p>可以发现Simplify类的复杂度严重超标，主要原因是表达式化简需要对各种情况进行特判，而且还加入了提取最大公因数和对输入预处理的功能，导致复杂度过高</p><figure><img src="/img/OO/OO第一单元方法复杂度.png"alt="OO第一单元方法复杂度" /><figcaption aria-hidden="true">OO第一单元方法复杂度</figcaption></figure><p>print_unit方法复杂度也严重超标，原因在于加入exp因子后，需要进行特判的情况增加，还要判断是否为表达式来化简括号，因此复杂度高。</p><h2 id="思路与架构">思路与架构</h2><p>先上类图</p><figure><img src="/img/OO/OO第一单元架构.png" alt="OO第一单元架构" /><figcaption aria-hidden="true">OO第一单元架构</figcaption></figure><p>其中，程序的主体是先存储自定义函数，然后调用lexer对输入表达式进行词法分析，接着用parse进行输入解析，解析完毕后调用toPoly方法运算、转化成统一形式，最后进一步化简输出。</p><p>解析部分采用<strong>递归下降</strong>（有点编译原理的感觉），分为表达式、项、因子三个层次。表达式解析调用项的解析方法，项再调用因子的解析方法，如果是表达式因子等特殊因子还可以再调用表达式解析方法直至解析完毕。主要因子均继承Factor接口，方便统一管理，内部属性与特点相对应。解析自定义函数调用时采用<strong>字符串递归替换</strong>的方法，具体实现在myFun类中。</p><p>计算方面采用<strong>标准项</strong>统一处理，建立Unit类作为HashMap的key，相同即可合并。表达式类、项类、每种因子类均实现了toPoly方法转化为<code>HashMap&lt;Unit,BigInteger&gt;</code>类型，便于运算、化简、输出。多项式加法、乘法、求导写成了静态方法放进Poly类中。类似的，预处理与化简方法也写成了静态方法放进Simplify类中。</p><h3 id="输入预处理">输入预处理</h3><p>这一部分较为简单，直接用正则表达式对字符串进行匹配替换即可，主要是去掉空白符和连续的正负号方便后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">pre_process</span><span class="hljs-params">(String input)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> input.replaceAll(<span class="hljs-string">&quot;[ \t]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        output = output.replaceAll(<span class="hljs-string">&quot;\\+\\+&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;\\+-&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;-\\+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><p>替换完毕后，将自定义函数的函数名、指定的形参、函数体分别存放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//函数名-具体函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//参数列表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//函数体</span><br></code></pre></td></tr></table></figure><h3 id="输入解析">输入解析</h3><p>首先使用lexer（词法分析器），逐个读入字符并分类为数字、变量、+-等符号，提供peek（返回当前的token，即遇到了什么）、next（读入下一个token）方法。</p><p>parser采用递归下降的方法，将表达式拆解为表达式、项、因子三层：</p><ul><li>表达式遇到加减号调用解析项的方法，将解析完的内容加到项容器中（容器中的元素是加减关系）</li><li>项遇到乘号调用解析因子的方法，将解析完的内容加到因子容器中（容器中的元素是相乘关系）。</li><li>解析因子的方法根据当前Token的不同，调用不同的解析方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Expr <span class="hljs-title function_">parseExpr</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>();<br>    expr.addTerm(sign, parseTerm());<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-keyword">return</span> expr;<br>&#125;<br><span class="hljs-keyword">public</span> Term <span class="hljs-title function_">parseTerm</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">Term</span> <span class="hljs-variable">term</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Term</span>();<br>    term.addFactor(parseFactor());<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-keyword">return</span> term;<br>&#125;<br><span class="hljs-keyword">public</span> Factor <span class="hljs-title function_">parseFactor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123; <span class="hljs-comment">//表达式因子</span><br>        <span class="hljs-keyword">return</span> parseExprFactor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;exp&quot;</span>)) &#123; <span class="hljs-comment">//指数函数因子</span><br>        <span class="hljs-keyword">return</span> parseExpFactor();<br>    &#125; <span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义函数的解析">自定义函数的解析</h4><p>关于自定义函数因子，我并没有相应的因子类，而是通过字符串递归替换得到没有自定义函数的字符串，然后调用lexer、parser等方法去解析，再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">parseFun</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> lexer.peek();<span class="hljs-comment">//确定调用哪一个函数</span><br>    ArrayList&lt;String&gt; can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//实参</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>            <span class="hljs-comment">/*...*/</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>            right++;<br>            <span class="hljs-keyword">if</span> (right == left) &#123;<br>                lexer.next();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(lexer.peek())) &#123;<br>            tmp.append(parseFun(lexer));<span class="hljs-comment">//递归替换</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        tmp.append(lexer.peek());<br>        lexer.next();<br>    &#125;<br>    tmp.append(<span class="hljs-string">&quot;)&quot;</span>);<br>    can.add(tmp.toString());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + MyFun.callFun(name, can) + <span class="hljs-string">&quot;)&quot;</span>;<span class="hljs-comment">//字符串替换函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表达式的存储">表达式的存储</h3><p>上面已经介绍过表达式、项的存储方法，现在介绍各类因子的存储</p><h4 id="常量幂函数因子">常量、幂函数因子</h4><p>常量和幂函数可以统一成 <span class="math inline">\(a\timesx^b\)</span> 的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger parameter;<span class="hljs-comment">//系数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="表达式因子">表达式因子</h4><p>内部用一个表达式类存储即可，再加上表达式括号后面的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExprFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Expr expr;<span class="hljs-comment">//表达式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指数函数因子">指数函数因子</h4><p>由于指数函数内部也是一个因子，因此用Factor来存储。虽然有种无限递归的感觉，但暂时没有出问题。同样还要存储后面跟的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> Factor factor;<span class="hljs-comment">//指数内的因子</span><br>    <span class="hljs-keyword">private</span> BigInteger exponent;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求导因子">求导因子</h4><p>事实上极其简单，甚至最初我还将它直接归类到表达式因子。但事实上求导因子的toPoly方法要调用表达式类的toDelta方法，自身的toDelta方法要先调用表达式类的toDelta方法，再求导一次。而表达式因子只有toDelta方法会求导，且仅求一次导数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeltaFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> Expr expr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表达式计算">表达式计算</h3><p>核心思想有两个，第一个还是<strong>递归调用</strong>，第二个是<strong>存算分离</strong>。</p><h4 id="总体结构1递归调用">总体结构1——递归调用</h4><p>这里的递归调用类似解析部分的递归下降法。</p><ul><li>表达式依次调用存储的项的 <code>toPoly</code>方法，获得结果后进行多项式加法并返回</li><li>项依次调用存储的因子的 <code>toPoly</code>方法，获得结果后进行多项式乘法并返回</li><li>因子实现 <code>toPoly</code>方法，如果内部存储有表达式，直接调用表达式的 <code>toPoly</code>方法再处理即可</li></ul><p>求导方法类似，但需要用到以下几个公式 <span class="math display">\[\begin{aligned}(a\times x^b\times e^c)&#39;&amp;=a\times b\times x^{b-1}\timese^c+a\times x^b\times e^c\times(c)&#39;\\[f(g(x))]&#39;&amp;=f&#39;(g(x))g&#39;(x)\\(\prod_i f_i)&#39;&amp;=\sum_if_i&#39;(\prod_{j\neq i}f_j)\\\sum f_i&amp;=\sum f_i&#39;\end{aligned}\]</span> 大体结构如上，但如何进行合并化简呢？</p><h4 id="总体结构2存算分离">总体结构2——存算分离</h4><p>存储时只存储相应因子的必要部分，计算时再化为统一的Unit或Poly类进行处理。</p><p>考察所有类别的因子，可以发现都能化成形如 <spanclass="math inline">\(a\times x^b\times \exp(c)\)</span>的基本项。因此，我决定采用Unit类来表示，并在存储的各类中添加toPoly方法转化成<code>HashMap&lt;Unit,BigInteger&gt; poly</code>来计算，<strong>Unit存储b和c，相同即可合并</strong></p><p><strong>注意以自建类作key时，一定要在类中重写equals和HashCode方法！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;Unit, BigInteger&gt; factor;<span class="hljs-comment">//因子</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Unit)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Unit</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Unit) o;<br>        <span class="hljs-keyword">return</span> other.exponent.equals(exponent)&amp;&amp;other.factor.equals(factor);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(exponent, factor.hashCode());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>系数a：Unit类中<strong>不存储系数</strong>，而是由各个因子中的toPoly方法将系数填写到<code>HashMap</code> 中的 <code>value</code> 中</li><li>指数b：存储在Unit的 <code>BigInteger exponent</code> 中</li><li>指数函数中的嵌套因子c：转化成多项式后，存储在Unit的<code>HashMap&lt;Unit,BigInteger&gt; factor</code> 中</li></ul><p>例如，2可以在计算过程中转化成多项式<code>HashMap&lt;Unit,BigInteger&gt; poly</code>，poly的大小为1，包含一个键值对，key为Unit，value为2。由于3为常数，所以Unit中指数项exponent为0，存储指数函数因子的factor为空。</p><p>又如，<span class="math inline">\(3\times x^6\times\exp(1+x^2)\)</span> 可以转化成多项式<code>HashMap&lt;Unit,BigInteger&gt; poly</code>，poly的大小为1，包含一个键值对，key为Unit，value为3。Unit里又存储了指数6和因子<span class="math inline">\(x^2+1\)</span> ，其中因子为<code>HashMap&lt;Unit,BigInteger&gt; factor</code>。factor的大小为2，有2个键值对，其中key1是Unit1，value1为1（代表1）;key2是Unit2，value2为1（代表<span class="math inline">\(x^2\)</span>）。Unit1中exponent为0，<strong>用factor为空代表 <spanclass="math inline">\(\exp(0)\)</span>​</strong>；Unit2中exponent为2，factor同样为空。</p><p>在IDEA中可以看到如下的展开式</p><figure><img src="/img/OO/表达式存储.png" alt="表达式存储" /><figcaption aria-hidden="true">表达式存储</figcaption></figure><p>根据如上的思路，我们可以在表达式类、项类和所有因子类中构建toPoly方法将表达式转化为统一形式</p><h4 id="性能优化与拓展性">性能优化与拓展性</h4><p>注意到在第二次作业中，有部分测试点进行了边界压力测试，如果采用的方法不当，极有可能出现MLE或TLE的情况，比如测试点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>(((((((((((x^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>关于MLE：在处理表达式因子或指数函数因子后的指数时，如果采用向相应容器（比如项类的容器）中存入指数个因子的方法，那么在应对上述情况时很有可能爆内存，而且计算时会进行递归调用，产生很多重复计算。</p><p>关于TLE：在计算表达式时，如果采用展开所有项（如 <spanclass="math inline">\((x+1)^2=x^2+x+x+1\)</span>​）的方法而不合并，则在应对较大数据时计算效率会大大下降，建议边计算边合并。</p><p>目前架构能做到 <code>(x+1)^1000</code>秒算，新增因子时，只需新建因子类、完善Unit类中的属性、修改Poly类中的加减法、添加输出方式即可，总体架构仍然可以保持不变</p><h3 id="结果化简">结果化简</h3><p>由于题面允许指数函数后接指数，即允许 <code>exp(2)^10</code>存在，于是可以用 <spanclass="math inline">\(\exp(a*x+b*y)=\exp(x)^a+\exp(y)^b\)</span>​这一公式进行任意优化。</p><p>但是，注意到以下几个例子：</p><ul><li><code>exp((10000+10000*x))=exp((1+x))^10000</code></li><li><code>exp((2*x))=exp(x)^2</code></li><li><code>exp((10+20*x+20*x^2))=exp((2+4*x+4*x^2))^5</code></li><li><code>exp((1+3*x))^2=exp((2+6*x))</code></li><li><code>exp((3*x+2*x^2+2*x^3+2*x^4+2*x^5))=exp(x)*exp((x+x^2+x^3+x^4+x^5))^2</code></li></ul><p>这说明无法单纯的提出来最大公因数来得到最优解，因为<strong>无法确定提出什么因数合适、是否要将因数合并进去</strong>。所以，我选择正确性优先，在保证正确性的基础上，寻找最大公因数并提取，并与最初的表达式的长短比较得出相对较短的字符串并输出。</p><h2 id="评测机与bug">评测机与bug</h2><p>和好友ZX共同完成了评测机。</p><h3 id="数据生成">数据生成</h3><h4 id="框架">框架</h4><p>采用python编写，具体框架即课程组给定的形式化表述。</p><ul><li>首先主函数调用生成自定义函数的函数（可选），然后根据指定的样例数调用表达式生成函数</li><li>表达式生成函数根据一定的概率调用一定数量的项生成函数，拼接成表达式</li><li>项生成函数根据一定的概率调用一定数量、一定种类的因子生成函数，拼接成项</li><li>常数、自变量因子直接返回，表达式因子、求导函数因子会递归调用表达式生成函数，指数函数因子会一定概率调用表达式生成函数</li></ul><p>具体的一些细节如空白符、正负号、前导0、指数的产生封装成小函数。</p><h4 id="功能">功能</h4><p>基本实现了所有类型样例的全覆盖，但缺点就是随机程度高，需要大量样例才能全覆盖。生成各种因子以及许多参数均可个性化调整，存储在json文件中，目前支持的参数主要有：测试样例数、是否自动生成自定义函数（或者自己指定函数）、括号嵌套层数上限、表达式中项数量的上限、项中因子数量的上限、产生各种因子的概率、空白符等多余内容的概率……</p><h3 id="正确性判定">正确性判定</h3><p>主要方法有两种——对拍与syms库</p><p>对拍采用讨论区JZY大佬的方法即可，两人分别跑一次数据，再用其中一个人跑一下刚才二人的结果的相减，若最终结果为0，则可以认为大概率没有问题</p><p>syms库即python中的库，这部分的实现主要由好友张鑫完成，大致包括表达式结果的预处理（如dx替换为diff）、调用数据生成器和java并运行、结果比较与输出、超时跳过（Linux可选）。</p><h3 id="bugs">bugs</h3><p>很幸运第一单元的作业没有在强测、互测中发现bug，以下测试点均为互测中有效hack数据，主要通过评测机发现。</p><h4 id="section">1.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4294967296</span><span class="hljs-comment">//系数/指数转化过程中使用了int</span><br></code></pre></td></tr></table></figure><h4 id="section-1">2.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>(<span class="hljs-number">1</span>+x+x^<span class="hljs-number">2</span>+x^<span class="hljs-number">3</span>)^<span class="hljs-number">6</span><span class="hljs-comment">//低性能压力测试1</span><br><br><span class="hljs-number">0</span><br>(((((((((((x^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span><span class="hljs-comment">//强测的压力测试...恐怖如斯</span><br><br><span class="hljs-number">0</span><br>exp((-x))<span class="hljs-comment">//应该原样输出，但很多人输出为exp(-x)，忽略了-x不是因子</span><br><br><span class="hljs-number">0</span><br>exp((exp((x-x))-exp((x-x))))<span class="hljs-comment">//有关0的处理</span><br></code></pre></td></tr></table></figure><h4 id="section-2">3.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>dx(exp(exp(exp(exp(exp(exp(exp(exp(x^<span class="hljs-number">2</span>)))))))))<span class="hljs-comment">//性能测试/正确性测试</span><br></code></pre></td></tr></table></figure><h2 id="心声">心声</h2><p><del>开学第一天即王炸</del></p><p>相比上学期的OOpre，这周的作业可谓是疾如猛火。开学第一天即布置高强度作业，最终码量甚至逼近OOpre的总码量，而且思维难度更高，对架构、性能要求也更高。</p><p>第一周幸好有训练单元提供的架构，输入解析改一改即可，直接省了近一半的代码量。但剩下的部分任然不可小觑，借鉴了学长的博客后还是采用了自己的架构，简单省事，用<code>HashMap&lt;BigInteger,BigInteger&gt;</code>存储多项式，也为第二周的重构埋雷。</p><p>第二周比第一周更难，主要是指数函数因子的出现让我不得不思考如何存储才能在计算时快速合并。反复阅读学长博客后，我不得不承认学长的架构自有其道理，但其中的细节还需要自己思考、处理，比如以Unit作key。最终重构后的代码也在强测中取得了良好的表现，看来以后决不能偷偷省事，一定要预先思考需求、做好架构。</p><p>第三周由于第二周的良好架构，作业发布当晚就写完了，最终码量775/679（总行/非空行）。</p><p>总的来说，OO不失为一次涅槃，高强度的码量与高难度的作业迫使我们一次又一次的思考架构。第一单元的作业让我对递归下降的解析法理解更加深刻，同时对层次化设计的思想也有了一定的应用经验。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OOpre总结</title>
    <link href="/2024/01/24/OOpre%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/24/OOpre%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="架构分析">架构分析</h4><h5 id="功能分析">功能分析</h5><p>Main:处理输入</p><p>Control:根据命令类型执行不同的命令，存储所有的冒险者、战斗日志（按月）</p><p>Adventure:执行冒险者的各种操作，存储雇佣的冒险者、药水瓶、装备、食物、战斗日志（按人）、背包</p><h5 id="继承关系">继承关系</h5><figure><img src="/img/image-20231104115232742.png"alt="image-20231104115232742" /><figcaption aria-hidden="true">image-20231104115232742</figcaption></figure><h5 id="几个特点">几个特点</h5><ol type="1"><li><p>control中相似操作用选择信号代替，减少代码重复</p><p>具体的，删除、加入、获取名字等方法一样，分别用1、2、3指代药水瓶、装备、食物；价值体接口中的<code>get_value</code>专门用来返回各个类特有的属性如药水瓶的容量、装备的星级、食物的能量等</p></li><li><p>除必需遍历输出的战斗日志外，全部采用HashMap、TreeSet，提高效率</p></li><li><p>输入只在Main中，其他方法传入字符串等参数，方便调试</p></li></ol><h5 id="架构变动">架构变动</h5><ul><li>最大的架构变动来自于P3到P4，原因是Main类里实在塞不下那么多类型的指令调用（代码风格过不去），因此把指令实现都放在了control类中，此后新增的操作分为switch1、switch2等等，<strong>嵌套调用</strong></li><li>其次要算新增了价值体，<strong>继承的使用</strong>大大简化了Adventrue类中存储结构的设计</li><li>最后一个小改动是战斗日志的处理，P6到P7的改动将这个处理更加清晰地分为2个方法</li></ul><h5 id="不足分析">不足分析</h5><ul><li>case数太多，寻找更优雅的解决多指令的方式</li><li>战斗日志的输入解读仍然不尽如人意，代码冗长、不优雅，看上去还是像屎山</li></ul><h4 id="junit的体会">Junit的体会</h4><h5 id="简单评价">简单评价</h5><p>个人角度来看，junit侧重于针对每个类或者方法单独测试，然而大部分的bug实际上来自于方法之间的调用、类与类之间的关系等等，因而<strong>对某一类、方法的测试</strong>可能局限于简单测试功能的完善性，而无法进行完全的测试。但如果通过对不同情况的仔细考虑造出强数据点并<strong>在类似顶层类（如control）中进行测试</strong>，则既可以测试每一方法、类，又能测试类与类、方法与方法间的调用关系，更加完备。</p><h5 id="使用体验">使用体验</h5><ul><li>assert的使用确实可以减少自己一个一个对数据点的烦恼。</li><li>在每次迭代后，都需要花费很多时间精心设计覆盖率足够高的数据点，看似很不划算，但真的是检验程序的一种绝佳方法（我自己在测试时经常出现程序崩溃的情况，输出错误反而很少。。。），确保提交的程序至少能够成功执行某些情况下的全部指令。</li></ul><h4 id="oopre的体会">OOpre的体会</h4><h5 id="面向对象编程">面向对象编程</h5><p>其实从C++和java对比来看更为明显，C++虽然也有类、支持继承、重载等等，但并没有显式的推荐一个类单独写一个文件（<del>自己都快把类当有函数的结构体用了</del>），还是容易造成”一main到底“的情况。而在OOpre中，由于java中的主体是类，真的需要<strong>认真考虑每个类到底有什么属性、功能</strong>，从而认真设计，相当于迫使程序员面向对象编程。</p><h5 id="框架">框架</h5><p>OOpre中，每次迭代都要根据新增的数据类型与指令要求设计新的存储、调用方法，因而程序的框架就十分重要。另一方面，代码量的显著增加也要求每次设计必须预先规划，而不能边写边想边改。</p><p>比如针对冒险者的操作大多根据id进行，因此可以用HashMap进行存储。但后续增加通过名字查询的功能时，又不得不增加一个名字-id的HashMap也是无奈之举。</p><p>又如类与类之间的联系、分工也应在开始编写之前考虑清楚，具体框架见前述。</p><h5 id="代码风格">代码风格</h5><p>统一化的代码风格这一要求其实还是容易理解的，但是还是有一些要求令我在编写时绷不住，只能尽量靠近要求</p><ul><li>每行不得超过100字符。从前写C时每行很难超过50字符，但由于java中相互调用太多，因此一行中很容易因为各种方法的嵌套调用而超过100字符。（<del>其实也说明代码结构不够简洁</del>）</li><li>每个方法不得超过60行。这一条与上面一条结合，直接促成了我P3到P4的架构大改。</li><li>变量命名必须使用小驼峰。主要是和我之前已经习惯的下划线的命名方式冲突，改起来比较费劲。</li></ul><h4 id="课程建议">课程建议</h4><ol type="1"><li>第一次作业相关环境的配置、java语法的介绍太少太乱，太难上手，而且各种说明放在一个文件夹里，每个说明还只解决半个问题。比如git和idea的下载完全可以分成两个文件，git的下载、配置、使用说明等等和gitlab的配置完全可以放在一起，一步到位。又比如《公测文档》、《建议得分说明》、《其他说明》互有重叠，想查找相关说明时无法根据文件名查找，还得逐一查看。</li><li>既然没有互测，可不可以把强测结果开放时间、bug修复时间提前？（进一步的，考虑提前开放下一次作业？）</li></ol>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P7设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P7建议：先理解异常的处理过程，明确需要硬件完成是哪一部分，然后逐步搭建。（异常的处理和系统桥感觉相对独立？）</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h2 id="设计要求架构与需求">设计要求、架构与需求</h2><h3 id="设计要求">设计要求</h3><p>处理器应为五级流水线设计，支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mfc0,mtc0,eret,syscall</span><br></code></pre></td></tr></table></figure><p>其他详见“P7提交要求”</p><h3 id="任务需求">任务需求</h3><p>说实话，P7的教程给出了大致框架，但很多地方的细节并未给出，或者分散在不同地方（不同章节、SMRL、设计文档等），难以明确需求与任务要求，从而导致实现困难，下面是个人的总结。</p><h4 id="术语的明确">术语的明确</h4><ul><li>内部异常：指由于执行指令引发的异常，如算术溢出、地址未对齐等等</li><li>外部中断：指外部引发的中断，如计时器、tb给出的中断信号等等</li><li>异常/中断：以上两类事件的统称</li></ul><h4 id="任务">任务</h4><h5 id="核心任务实现异常的处理">核心任务：实现异常的处理</h5><h6 id="处理步骤">处理步骤</h6><ol type="1"><li>根据当前CP0的SR状态、内部异常exc信号、外部中断HWint信号判断是否中断</li><li>把宏观PC写入EPC（注意延迟槽指令），异常信息写入CP0的Cause寄存器，SR相应位置1进入内核态（处理中断过程中禁止嵌套中断）</li><li>将PC调整到0x4180，清空宏观PC及之前的流水线寄存器</li><li>执行异常处理程序（处理异常、响应中断、回到原来指令等操作都交给软件实现）</li></ol><h6 id="具体实现">具体实现</h6><ul><li>每一级新增异常判断，流水异常信号——对应步骤1</li><li>每一级新增中断信号，进行清空操作——对应步骤2</li><li>每一级针对新增的指令进行修改（要结合CP0的设计一起进行），完成阻塞和转发的修改——对应步骤4</li><li>CP0的实现，包括接受内部异常与外部中断信号、给出中断信号、实现对三个寄存器的写入与读出。</li></ul><h6 id="一些细节">一些细节</h6><ul><li>CP0位置：我选择在E级，此时已经可以判断出所有类型，并且不会对乘除模块的寄存器、DM与外设、寄存器堆进行写入，同时可以参考乘除模块进行转发与阻塞的处理</li><li>延迟槽的判断：直接引入M级指令，若M为跳转，则判断为延迟槽</li><li>优先级：复位信号&gt;外部中断&gt;内部异常，这体现在Cause寄存器写入等方面</li><li><code>HWint=&#123;3'b0,interrupt,timer0,timer1&#125;</code>（看了学长的博客才知道，根本没有6个中断）</li></ul><h5id="附属任务将cpu封装为单周期实现与外设沟通的系统桥">附属任务：将CPU封装为单周期，实现与外设沟通的系统桥</h5><h6 id="封装为单周期">封装为单周期</h6><p>考察CPU的功能，主要有以下几点：</p><ul><li>执行指令进行计算——需要IM接口(提供pc，获取指令)</li><li>与外设进行读、写操作——需要DM等接口(提供addr、写入数据，获取读出数据)</li><li>获取外部中断信号——2个timer和tb的中断</li><li>老2样——clk与reset</li><li>课程组检查寄存器的入口——寄存器堆相关信号</li></ul><h6 id="系统桥">系统桥</h6><p>考察系统桥的功能，就是根据M级指令、地址、数据，向外设提供相应的写使能信号、写入数据，同时对来自外设的数据进行选择。因此，接口应该能实现以上功能。</p><h3 id="架构">架构</h3><figure><img src="/img/微系统架构.png" alt="微系统架构.png" /><figcaption aria-hidden="true">微系统架构.png</figcaption></figure><h2 id="模块规格">模块规格</h2><h3 id="命名规则">命名规则</h3><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能_去向</code> 命名。</p><h3 id="cpu">CPU</h3><h4 id="封装">封装</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">reset</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">int_export</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">外部中断信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">int_timer0</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟中断信号0</td><td style="text-align: center;">Timer0</td></tr><tr class="odd"><td style="text-align: center;">int_timer1</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟中断信号1</td><td style="text-align: center;">Timer1</td></tr><tr class="even"><td style="text-align: center;">macroscopic_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">宏观pc</td><td style="text-align: center;">EX/tb</td></tr><tr class="odd"><td style="text-align: center;">i_inst_rdata</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IM的指令</td><td style="text-align: center;">IF_instr</td></tr><tr class="even"><td style="text-align: center;">i_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF的pc</td><td style="text-align: center;">IF_pc</td></tr><tr class="odd"><td style="text-align: center;">w_grf_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">w_grf_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">w_grf_wdata</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">w_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">m_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级pc</td><td style="text-align: center;">EX_pc_MEM/bridge</td></tr><tr class="even"><td style="text-align: center;">out_instr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的指令</td><td style="text-align: center;">EX_instr_MEM/bridge</td></tr><tr class="odd"><td style="text-align: center;">out_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的地址</td><td style="text-align: center;">EX_out/bridge</td></tr><tr class="even"><td style="text-align: center;">out_WD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的数据</td><td style="text-align: center;">EX_rt_MEM或W级转发</td></tr><tr class="odd"><td style="text-align: center;">out_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从外设读取的数据</td><td style="text-align: center;">MEM_data</td></tr></tbody></table><h4 id="模块共有信号">模块共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级（IF为out）</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，跳至0x4180</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="odd"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="even"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从tb获取的指令</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">IF_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF级当前指令</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">IF_exc_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">内部异常信号</td><td style="text-align: center;">ID</td></tr></tbody></table><h4 id="id">ID</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，清空D级</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="odd"><td style="text-align: center;">EPC</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">CP0的EPC</td><td style="text-align: center;">EX_rt(转发)、CP0</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF的异常信号</td><td style="text-align: center;">IF</td></tr><tr class="even"><td style="text-align: center;">ID_exc_EX</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">给EX的异常信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量与操作">内部变量与操作</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，清空本级</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="odd"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">EX_CP0</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从CP0读取的值</td><td style="text-align: center;">CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从ID流水下来的内部异常信号</td><td style="text-align: center;">ID</td></tr><tr class="even"><td style="text-align: center;">EX_exc_CP0</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给CP0的内部异常信号</td><td style="text-align: center;">CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示E级产生了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">EX_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">E级产生新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">mul是否正忙</td><td style="text-align: center;">mul</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;<span class="hljs-comment">//即时给出运算结果，上升沿时赋给EX_out</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_tmp_new;<span class="hljs-comment">//同上，EX_new</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] EX_tmp_addr;<span class="hljs-comment">//EX_addr</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] start;<span class="hljs-comment">//从E级指令给出mul所需信号,req时为0</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] hi;<span class="hljs-comment">//</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] lo;<br></code></pre></td></tr></table></figure><h5 id="内部模块mul">内部模块——mul</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">start</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">开始运算信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rs</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">B</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rt</td><td style="text-align: center;">EX_rt_use</td></tr><tr class="even"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">正忙信号</td><td style="text-align: center;">busy</td></tr><tr class="odd"><td style="text-align: center;">hi</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法高位/除法余数</td><td style="text-align: center;">out</td></tr><tr class="even"><td style="text-align: center;">lo</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法低位/除法的商</td><td style="text-align: center;">out</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要读出的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">读出的数据</td><td style="text-align: center;">bridge</td></tr><tr class="odd"><td style="text-align: center;">MEM_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示M级有了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">MEM_new_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">M级新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传向下一级的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op;<span class="hljs-comment">//位扩展选择信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data_out;<span class="hljs-comment">//原始读出数据</span><br></code></pre></td></tr></table></figure><h5 id="内部模块ext">内部模块——ext</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">A</td><td style="text-align: center;">读出地址的低位</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">Din</td><td style="text-align: center;">in</td><td style="text-align: center;">Din</td><td style="text-align: center;">原始数据</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">Op</td><td style="text-align: center;">in</td><td style="text-align: center;">Op</td><td style="text-align: center;">扩展选择信号</td><td style="text-align: center;">op</td></tr><tr class="even"><td style="text-align: center;">Dout</td><td style="text-align: center;">out</td><td style="text-align: center;">Dout</td><td style="text-align: center;">扩展后的数据</td><td style="text-align: center;">MEM_data_WB</td></tr></tbody></table><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h4 id="cp0">CP0</h4><p>位于E级，此时已经可以判断出所有异常类型，而且不会写入乘除模块、DM以及寄存器</p><p>通过E级指令来写入/读出相应寄存器，读出/写入的值与E级其他指令一样流水</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">HWint</td><td style="text-align: center;">in</td><td style="text-align: center;">[5:0]</td><td style="text-align: center;">输入中断信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">异常类型</td><td style="text-align: center;">EX_exc_CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">E级pc</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">EX_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">E级指令</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">MEM_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级指令，判断延迟槽</td><td style="text-align: center;">EX_instr_MEM</td></tr><tr class="even"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入CP0的数据</td><td style="text-align: center;">EX_rt</td></tr><tr class="odd"><td style="text-align: center;">CP0_rd</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从CP0读出的数据</td><td style="text-align: center;">EX_CP0</td></tr><tr class="even"><td style="text-align: center;">EPC</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">EPC</td><td style="text-align: center;">IF</td></tr><tr class="odd"><td style="text-align: center;">Req</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号</td><td style="text-align: center;">好多</td></tr></tbody></table><h5 id="寄存器对应位的功能">寄存器对应位的功能</h5><p>其中，SR编号12，Cause编号13，EPC编号14</p><table><thead><tr class="header"><th style="text-align: center;">寄存器</th><th style="text-align: center;">功能域</th><th style="text-align: center;">位域</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">IM（Interrupt Mask）</td><td style="text-align: center;">15:10</td><td style="text-align: center;">分别对应六个外部中断，相应位置 1表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过<code>mtc0</code>这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr class="even"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">EXL（Exception Level）</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr class="odd"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">IE（Interrupt Enable）</td><td style="text-align: center;">0</td><td style="text-align: center;">全局中断使能，该位置 1 表示允许中断，置0 表示禁止中断。</td></tr><tr class="even"><td style="text-align: center;">Cause</td><td style="text-align: center;">BD（Branch Delay）</td><td style="text-align: center;">31</td><td style="text-align: center;">当该位置 1 的时候，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr class="odd"><td style="text-align: center;">Cause</td><td style="text-align: center;">IP（Interrupt Pending）</td><td style="text-align: center;">15:10</td><td style="text-align: center;">为 6 位待决的中断位，分别对应 6个外部中断，相应位置 1 表示有中断，置 0表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr class="even"><td style="text-align: center;">Cause</td><td style="text-align: center;">ExcCode</td><td style="text-align: center;">6:2</td><tdstyle="text-align: center;">异常编码，记录当前发生的是什么异常。</td></tr><tr class="odd"><td style="text-align: center;">EPC</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><h5 id="异常码">异常码</h5><table><thead><tr class="header"><th style="text-align: left;">异常与中断码</th><th style="text-align: left;">助记符与名称</th><th style="text-align: left;">指令与指令类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;"><code>Int</code> （外部中断）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">中断请求，来源于计时器与外部中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;"><code>AdEL</code> （取指异常）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">PC 地址未字对齐。</td></tr><tr class="odd"><td style="text-align: left;">PC 地址超过<code>0x3000 ~ 0x6ffc</code>。</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>AdEL</code> （取数异常）</td><td style="text-align: left;"><code>lw</code></td><td style="text-align: left;">取数地址未与 4 字节对齐。</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>lh</code></td><td style="text-align: left;">取数地址未与 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>lh</code>, <code>lb</code></td><td style="text-align: left;">取 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">计算地址时加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">取数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;"><code>AdES</code> （存数异常）</td><td style="text-align: left;"><code>sw</code></td><td style="text-align: left;">存数地址未 4 字节对齐。</td></tr><tr class="even"><td style="text-align: left;"><code>sh</code></td><td style="text-align: left;">存数地址未 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>sh</code>, <code>sb</code></td><td style="text-align: left;">存 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">计算地址加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">向计时器的 Count 寄存器存值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">存数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">8</td><td style="text-align: left;"><code>Syscall</code> （系统调用）</td><td style="text-align: left;"><code>syscall</code></td><td style="text-align: left;">系统调用。</td></tr><tr class="even"><td style="text-align: left;">10</td><td style="text-align: left;"><code>RI</code>（未知指令）</td><td style="text-align: left;">-</td><td style="text-align: left;">未知的指令码。</td></tr><tr class="odd"><td style="text-align: left;">12</td><td style="text-align: left;"><code>Ov</code>（溢出异常）</td><td style="text-align: left;"><code>add</code>, <code>addi</code>,<code>sub</code></td><td style="text-align: left;">算术溢出。</td></tr></tbody></table><h3 id="bridge">Bridge</h3><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级指令</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级要读/写的地址</td><td style="text-align: center;">CPU</td></tr><tr class="odd"><td style="text-align: center;">MEM_WD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级要写入的数据</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">MEM_RD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给M的从外设读取的数据</td><td style="text-align: center;">CPU</td></tr><tr class="odd"><td style="text-align: center;">WD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给外设的写入的数据</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">DM_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从DM读出的数据</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">m_data_byteen</td><td style="text-align: center;">out</td><td style="text-align: center;">[3:0]</td><td style="text-align: center;">DM写使能</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">m_int_byteen</td><td style="text-align: center;">out</td><td style="text-align: center;">[3:0]</td><td style="text-align: center;">外部中断写使能</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">Timer0_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">Timer0读出的数据</td><td style="text-align: center;">Timer0</td></tr><tr class="even"><td style="text-align: center;">Timer0_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">Timer0写使能</td><td style="text-align: center;">Timer0</td></tr><tr class="odd"><td style="text-align: center;">Timer1_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">Timer1读出的数据</td><td style="text-align: center;">Timer1</td></tr><tr class="even"><td style="text-align: center;">Timer1_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">Timer1写使能</td><td style="text-align: center;">Timer1</td></tr></tbody></table><p>主要功能：根据从M级的指令、地址、数据，给出相应的读写信号、写入数据的预处理、读出数据的选择</p><h3 id="timer">Timer</h3><h2 id="冒险处理">冒险处理</h2><p>新增了E级到D级的转发（eret）</p><p>mfc0采用之前的转发就好</p><p>mtc0采用之前的转发就好</p><h4 id="转发">转发</h4><p>转发共5个接受：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rs_base;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] MEM_data;<br></code></pre></td></tr></table></figure><p>共2处提供：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WB_data_ID;<br></code></pre></td></tr></table></figure><p>其中，2处提供接口还给出new信号与addr，代表新值产生且可用、要写入的寄存器编号</p><p>接受者只需判断new与addr即可决定转发与否（有新值且可用就转发）</p><h4 id="阻塞">阻塞</h4><p><span class="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算见表格</p><p>采用Time模块传递计算结果，<code>[31:0] use_new</code>具体每位对应结果如下表</p><p>[2][1][0]分别对应rs、rt、rd</p><table><thead><tr class="header"><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">rd</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[0]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-&gt;</td><td style="text-align: center;">use或new的数值</td><td style="text-align: center;">&lt;-</td><td style="text-align: center;">1代表正在算乘除法</td><td style="text-align: center;">-&gt;</td><td style="text-align: center;">0为use，1为new</td><td style="text-align: center;">&lt;-</td></tr></tbody></table><p>若 <span class="math inline">\(T_{use}&lt;T_{new}\)</span>，或乘除类指令遇上busy，则执行阻塞操作：</p><ol type="1"><li>冻结IF/ID</li><li>清除ID/EX</li><li>禁止PC</li></ol><h4 id="注意事项">注意事项</h4><ul><li>从W级转发到D级，采用D级内部转发（如beq）</li><li>转发时如果地址是0寄存器应剔除</li></ul><h2 id="添加指令">添加指令</h2><ol type="1"><li><p>添加到const、IF已有指令里</p></li><li><p>填写TIME表格，根据use和new更改M级中的MEM_new与MEM_new_addr，添加Time中的use与new值</p></li><li><p>根据操作在每个模块添加行为</p><ul><li>IF：指令获取与延迟槽、未知指令与取指异常</li><li>ID：给出跳转指令</li><li>EX：各种计算行为、存储地址计算</li><li>MEM：给出写入内存的地址、转发信号、对读出的数据进行加工</li><li>WB：给出写寄存器信号、寄存器编号、数据</li><li>Bridge：sw类指令给出使能信号判断</li></ul></li><li><p>每类指令对应行为（P5）</p><ul><li>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</li><li>lw：修改EX计算过程、添加WB回写信号，……</li><li>sw：修改EX计算过程、Bridge使能判断、MEM写入，………</li><li>j：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</li><li>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</li></ul></li><li><p>是否有新的转发通路、阻塞可能</p></li></ol><h2 id="思考bug与测试">思考、bug与测试</h2><h4 id="思考题">思考题</h4><ol type="1"><li><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>当键盘、鼠标有输入时（状态更新或其他），向CPU发出中断信号，CPU接到中断信号后判断中断种类，并执行相应区域代码，完成输入信号的读取。其中，输入信号需要驱动程序的解读。</p></li><li><p>请思考为什么我们的 CPU处理中断异常必须是已经指定好的地址？如果你的 CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>必须是已经指定好的地址。处理中断异常程序的目的是维护系统、程序的正常运行，并返回错误信息。如果地址由用户自定义，可能地址无效产生新的异常、或处理程序也产生新的异常等，达不到目的。</p></li><li><p>为何与外设通信需要 Bridge？</p><p>外设种类很多而CPU指令集有限，因此要把外设的接口和CPU的接口通过系统桥连接起来，通过统一的方式，由系统桥选择相关信息的输入输出。</p></li><li><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。</p><figure><img src="/img/计时器状态转换图.jpg" alt="计时器状态转换图" /><figcaption aria-hidden="true">计时器状态转换图</figcaption></figure><p>state的状态转换其实 一样，区别在于从INT到IDLE这一步。</p><p>模式0将ctrl[0]置0，IRQ仍然为1，让state在IDLE卡死</p><p>模式1将IRQ置0，ctrl[0]仍然为1，让state能继续由IDLE到LOAD，顺便在这一过程中把IRQ置0，实现循环</p></li><li><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>EPC会存入0，跳转回正常指令的时候出错。pc、错误信息</p></li><li><p>为什么 <code>jalr</code> 指令为什么不能写成<code>jalr $31, $31</code>？</p><p>根据MARS的行为，jalr两个寄存器相同会导致先写入当前pc+4，再从寄存器取数跳转，实际上达不到跳转到$31的目的</p></li><li><p>[P7 选做] 请详细描述你的测试方案及测试数据构造策略。</p><p>详见“测试部分”</p></li></ol><h4 id="写p7遇到的bug">写P7遇到的bug</h4><p>eret的跳转值要接受来自mtc0(E级)的转发，还要判断地址是不是EPC</p><p>ID在中断时写寄存器操作不能停(相当于W级)</p><p>未知指令少打了个sb、mtc0的指令编码敲错了</p><p>计数器之间的地址不连续</p><p>外部异常比内部异常优先写入Cause</p><p>stall和req时应当保持pc</p><p>判断溢出的实现有误，应严格按MARS文档来</p><p>不管跳转指令是否跳转，其后的延迟槽指令都必须携带BD标记</p><p>写入外设的数据和DM提前准备好的冲突</p><p>应流水延迟槽标记，而非通过M级判断</p><p>阻塞、中断的时候没管BD</p><p>测测延迟槽阻塞、中断（已测）</p><p>外部中断的时候，BD需要置1吗——需要</p><p>SR的IP要每周期修改一次</p><p>mtc0和mfc0如果超出12-14怎么办——不用管</p><p>何时复位EXL——eret到CP0的下一上升沿</p><p>取值异常或RI后视为nop提交至CP0</p><p>未知指令判断时，mtc0？、</p><p>在延迟槽中断后，修改pc使得在延迟槽重新执行，BD需要置1吗？——不需要</p><p>eret处中断怎么办——不会出现tb中断</p><p>从中断发生器（不是计时器）读出的数据应该保持0</p><p>CP0部分位是只读，未使用的位应当保持为0！！！</p><p>通过sw相应一些中断时，阻塞阻塞再eret？、</p><p>mtc0、mfc0的rt和rd不要混！！！</p><p>D/E流水线寄存器在阻塞的时候应当流水上一级pc和BD！！！</p><p>好奇：课程组到底是怎么测试时钟中断的？</p><p>优化：lui提前至D级实现、取消对0寄存器的阻塞</p><h4 id="测试部分">测试部分</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">2</span>)s<br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">12</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">3</span>,<span class="hljs-number">6</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sb</span> $<span class="hljs-number">4</span>,<span class="hljs-number">11</span>($<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2p5冒险测试">part2——p5冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><h5 id="part3p6新增指令测试">part3——p6新增指令测试</h5><p>重点测试边缘数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> $<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">or</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">slt</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">sltu</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">addi</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">9</span>,-<span class="hljs-number">1</span><br><span class="hljs-attribute">andi</span> $<span class="hljs-number">10</span>,$<span class="hljs-number">10</span>,-<span class="hljs-number">1</span><br><span class="hljs-attribute">sb</span> $<span class="hljs-number">11</span>,-<span class="hljs-number">1</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">11</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">12</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lui</span> $<span class="hljs-number">11</span> <span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span> <span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">11</span>,<span class="hljs-number">2</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lb</span> $<span class="hljs-number">13</span>,<span class="hljs-number">3</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lh</span> $<span class="hljs-number">14</span>,<span class="hljs-number">2</span>($<span class="hljs-number">4</span>)<br><br><span class="hljs-attribute">mult</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">15</span><br><span class="hljs-attribute">multu</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">16</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">17</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">18</span><br><span class="hljs-attribute">mthi</span> $<span class="hljs-number">19</span><br><span class="hljs-attribute">mtlo</span> $<span class="hljs-number">20</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">20</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">20</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">bne</span> $<span class="hljs-number">19</span>,$<span class="hljs-number">21</span>,loop<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">21</span>,$<span class="hljs-number">21</span>,$<span class="hljs-number">20</span><br><span class="hljs-attribute">nop</span><br><span class="hljs-comment">#重点测试符号乘除</span><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">add</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">0</span><br><span class="hljs-attribute">mult</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">5</span><br><span class="hljs-attribute">multu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">6</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">7</span><br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">13</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">9</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">10</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">11</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">12</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">13</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">14</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">15</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">16</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">17</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">18</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">19</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">20</span><br><br></code></pre></td></tr></table></figure><h5 id="part4p7中断异常测试">part4——p7中断异常测试</h5><p>异常全覆盖</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1c01</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><br><br><span class="hljs-comment">#pc地址未对齐</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">0x300a</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-number">2</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><span class="hljs-comment">#顺便延迟槽</span><br><span class="hljs-comment">#pc地址超范围</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">0x0003</span><br><br><span class="hljs-comment">#lw、lh没有字对齐</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-number">2</span>,<span class="hljs-number">1</span>($<span class="hljs-number">0</span>)<br><span class="hljs-comment">#lh、lb取Timer寄存器的值</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">0x7f00</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#应该没错</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-number">5</span>,<span class="hljs-number">20</span>($<span class="hljs-number">4</span>)<br><span class="hljs-comment">#计算地址加法溢出</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">1</span>($<span class="hljs-number">6</span>)<br><span class="hljs-comment">#取数地址超出范围</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0x7f0c</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">#sw、sh没有字对齐</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-number">2</span>,<span class="hljs-number">1</span>($<span class="hljs-number">0</span>)<br><span class="hljs-comment">#sh、sb取Timer寄存器的值</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#应该没错</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-number">5</span>,<span class="hljs-number">20</span>($<span class="hljs-number">4</span>)<br><span class="hljs-comment">#计算地址加法溢出</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">1</span>($<span class="hljs-number">6</span>)<br><span class="hljs-comment">#向计时器Count寄存器存值</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">7</span>)<br><span class="hljs-comment">#存数地址超出范围</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">100</span>($<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">#syscall</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">#RI</span><br><span class="hljs-keyword">nor </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,$<span class="hljs-number">4</span><br><br><span class="hljs-comment">#算术溢出</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">8</span>,$<span class="hljs-number">6</span><span class="hljs-comment">#不应溢出</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">6</span>,$<span class="hljs-number">8</span><span class="hljs-comment">#溢出</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">6</span>,$<span class="hljs-number">7</span><span class="hljs-comment">#溢出</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">6</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">9</span>,-<span class="hljs-number">100</span><span class="hljs-comment">#溢出</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span>,end<span class="hljs-comment">#死循环</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">#异常处理程序</span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">12</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">13</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-built_in">k0</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">eret</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><span class="hljs-comment">#应当没有延迟槽</span><br></code></pre></td></tr></table></figure><p>中断、异常、阻塞、延迟槽交错，限制部分中断</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1c01</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><br><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0x7fff</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">3</span>,<span class="hljs-number">0x7fff</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">3</span>,end<br><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,$<span class="hljs-number">3</span><span class="hljs-comment">#延迟槽指令出错。可在此处加入外部中断，断2次</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#阻塞的时候来点外部中断</span><br><span class="hljs-keyword">bne </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">4</span>,end<span class="hljs-comment">#此处需要更改机器码让beq出错</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">1</span><br><br><span class="hljs-comment">#时钟中断</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">9</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">0x7f00</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">4</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><span class="hljs-comment">#啥时候中断我也搞不清……</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><br><span class="hljs-keyword">and </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1001</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><span class="hljs-comment">#不许时钟中断了</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">4</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><span class="hljs-comment">#啥时候中断我也搞不清……</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span>,end<span class="hljs-comment">#死循环</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment">#异常处理程序</span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">12</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">13</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x7c</span><br><span class="hljs-keyword">and </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k1</span><br><span class="hljs-keyword">bne </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">0</span>,WTF<br>    <span class="hljs-keyword">sb </span>$<span class="hljs-number">0</span>, <span class="hljs-number">0x7f20</span>($<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">0</span>, <span class="hljs-number">0x7f00</span>($<span class="hljs-number">0</span>)<br><span class="hljs-symbol">WTF:</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-built_in">k0</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">eret</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P6设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P6%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P6%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P6建议：在P5基础上添加乘除槽即可</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h3 id="设计要求">设计要求</h3><p>处理器应为五级流水线设计，支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>直接通过顶层模块 mips.v 的 output 端口传出相应信号，不允许出现<code>display</code> 语句，具体要求见“在线测试相关说明”小节。</p></li><li><p>要求存储器外置，即将 IM 和 DM 放置在 CPU 之外。P6 的 IM 和 DM两个模块被内置于官方评测的 testbench 中（官方使用的 tb已在“存储器外置”小节公开），<strong>不再需要</strong>大家自行实现 IM 和DM 模块。官方 tb 中实现的指令存储器（IM，instructionmemory）和数据存储器（DM，data memory）的容量如下：</p><ul><li><p>IM：容量为 <strong>16KB</strong> (32bit/word ×<strong>4096word</strong>)</p></li><li><p>DM：容量为 <strong>12KB</strong> (32bit/word ×<strong>3072word</strong>)</p></li></ul></li><li><p>需有单独的<strong>乘除法模块</strong>和<strong>数据扩展模块</strong>，我们会分别在“乘除模块”和“支持按字节访存”两个小节中中予以详细说明。</p></li><li><p>最外层的 mips 模块的文件名必须为 mips.v ，该文件中的 module也必须命名为 <strong>mips</strong> 。</p></li></ol><h3 id="架构">架构</h3><h3 id="模块规格">模块规格</h3><h4 id="命名规则">命名规则</h4><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能(_去向)</code> 命名。</p><h4 id="共有信号">共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级（IF为out）</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr><tr class="even"><td style="text-align: center;">IF_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从tb获取的指令</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">IF_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF级当前指令</td><td style="text-align: center;">tb</td></tr></tbody></table><h4 id="id">ID</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="even"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">EX_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示E级产生了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">EX_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">E级产生新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">mul是否正忙</td><td style="text-align: center;">mul</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;<span class="hljs-comment">//即时给出运算结果，上升沿时赋给EX_out</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_tmp_new;<span class="hljs-comment">//同上，EX_new</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] EX_tmp_addr;<span class="hljs-comment">//EX_addr</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] start;<span class="hljs-comment">//从E级指令给出mul所需信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] hi;<span class="hljs-comment">//</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] lo;<br></code></pre></td></tr></table></figure><h5 id="内部模块mul">内部模块——mul</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">start</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">开始运算信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rs</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">B</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rt</td><td style="text-align: center;">EX_rt_use</td></tr><tr class="even"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">正忙信号</td><td style="text-align: center;">busy</td></tr><tr class="odd"><td style="text-align: center;">hi</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法高位/除法余数</td><td style="text-align: center;">out</td></tr><tr class="even"><td style="text-align: center;">lo</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法低位/除法的商</td><td style="text-align: center;">out</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要读出的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">读出的数据</td><td style="text-align: center;">m_data_rdata</td></tr><tr class="odd"><td style="text-align: center;">MEM_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示M级有了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">MEM_new_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">M级新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传向下一级的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-2">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op;<span class="hljs-comment">//位扩展选择信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data_out;<span class="hljs-comment">//原始读出数据</span><br></code></pre></td></tr></table></figure><h5 id="内部模块">内部模块</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">A</td><td style="text-align: center;">读出地址的低位</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">Din</td><td style="text-align: center;">in</td><td style="text-align: center;">Din</td><td style="text-align: center;">原始数据</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">Op</td><td style="text-align: center;">in</td><td style="text-align: center;">Op</td><td style="text-align: center;">扩展选择信号</td><td style="text-align: center;">op</td></tr><tr class="even"><td style="text-align: center;">Dout</td><td style="text-align: center;">out</td><td style="text-align: center;">Dout</td><td style="text-align: center;">扩展后的数据</td><td style="text-align: center;">MEM_data_WB</td></tr></tbody></table><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h3 id="冒险处理">冒险处理</h3><h4 id="转发">转发</h4><p>转发共5个接受：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rs_base;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] MEM_data;<br></code></pre></td></tr></table></figure><p>共2处提供：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WB_data_ID;<br></code></pre></td></tr></table></figure><p>其中，2处提供接口还给出new信号与addr，代表新值产生且可用、要写入的寄存器编号</p><p>接受者只需判断new与addr即可决定转发与否（有新值且可用就转发）</p><h4 id="阻塞">阻塞</h4><p><span class="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算见表格</p><p>采用Time模块传递计算结果，<code>[31:0] use_new</code>具体每位对应结果如下表</p><p>[2][1][0]分别对应rs、rt、rd</p><table><thead><tr class="header"><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">rd</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[0]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-&gt;</td><td style="text-align: center;">use或new的数值</td><td style="text-align: center;">&lt;-</td><td style="text-align: center;">1代表正在算乘除法</td><td style="text-align: center;">-&gt;</td><td style="text-align: center;">0为use，1为new</td><td style="text-align: center;">&lt;-</td></tr></tbody></table><p>若 <span class="math inline">\(T_{use}&lt;T_{new}\)</span>，或乘除类指令遇上busy，则执行阻塞操作：</p><ol type="1"><li><p>冻结IF/ID</p></li><li><p>清除ID/EX</p></li><li><p>禁止PC</p></li></ol><h4 id="注意事项">注意事项</h4><ul><li><p>从W级转发到D级，采用D级内部转发（如beq）</p></li><li><p>转发时如果地址是0寄存器应剔除</p></li></ul><h3 id="添加指令">添加指令</h3><ol type="1"><li><p>添加到const里</p></li><li><p>填写TIME表格，根据use和new更改M级中的MEM_new与MEM_new_addr，添加Time中的use与new值</p></li><li><p>根据操作在每个模块添加行为</p><ul><li><p>IF：指令获取与延迟槽</p></li><li><p>ID：给出跳转指令</p></li><li><p>EX：各种计算行为、存储地址计算</p></li><li><p>MEM：给出写入内存的地址、byte信号，对读出的数据进行加工</p></li><li><p>WB：给出写寄存器信号、寄存器编号、数据</p></li></ul></li><li><p>每类指令对应行为（P5）</p><ul><li><p>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</p></li><li><p>lw：修改EX计算过程、添加WB回写信号，……</p></li><li><p>sw：修改EX计算过程、MEM写入，………</p></li><li><p>j：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</p></li><li><p>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</p></li></ul></li><li><p>是否有新的转发通路、阻塞可能</p></li></ol><h3 id="思考题与测试">思考题与测试</h3><ol type="1"><li><p>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的HI、LO 寄存器？</p><p>乘除法相较其他运算，复杂性更高且时间更长（延迟更大），与ALU分离有利于保持模块的清晰关系、缩短时钟周期。便于在本级存储运算结果而不是回写到寄存器，否则其他使用寄存器的指令均需要被阻塞，性能下降严重。</p></li><li><p>真实的流水线 CPU是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p><p>类似于竖式乘法，乘数最低位*被乘数并累加右移直至每位乘数都算完，32位需5次加法-100周期的时间。</p><p>类似于算式除法，每次尝试减去能减去的最大值（含比较过程），重复计算得商、余数</p></li><li><p>请结合自己的实现分析，你是如何处理 Busy信号带来的周期阻塞的？</p><p>当D级是乘除类指令且E级是乘除类指令或busy时，阻塞</p></li><li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p><p>可读性好，当前执行的指令一目了然。字、半字、字节的处理具有统一性。</p></li><li><p>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p><p>不是。写入低位时，按字读和按字写效率近似，写入低位效率高于写入高位</p></li><li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p><ul><li><p>const中定义指令编码，减少代码量、提高易读性</p></li><li><p>time计算指令单独成一模块，采用列举法，便于新增指令</p></li></ul></li><li><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>见转发</p></li><li><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p></li></ol><h4 id="测试部分">测试部分</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">2</span>)s<br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">12</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">3</span>,<span class="hljs-number">6</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sb</span> $<span class="hljs-number">4</span>,<span class="hljs-number">11</span>($<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2冒险测试">part2——冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><h5 id="part3新增指令测试">part3——新增指令测试</h5><p>重点测试边缘数据</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">and</span> <span class="hljs-symbol">$</span><span class="hljs-number">1</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br><span class="hljs-keyword">or</span> <span class="hljs-symbol">$</span><span class="hljs-number">3</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>sub <span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>slt <span class="hljs-symbol">$</span><span class="hljs-number">7</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>sltu <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>addi <span class="hljs-symbol">$</span><span class="hljs-number">9</span>,<span class="hljs-symbol">$</span><span class="hljs-number">9</span>,<span class="hljs-number">-1</span><br>andi <span class="hljs-symbol">$</span><span class="hljs-number">10</span>,<span class="hljs-symbol">$</span><span class="hljs-number">10</span>,<span class="hljs-number">-1</span><br>sb <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">-1</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>sh <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">0</span>(<span class="hljs-symbol">$</span><span class="hljs-number">0</span>)<br>lw <span class="hljs-symbol">$</span><span class="hljs-number">12</span>,<span class="hljs-number">0</span>(<span class="hljs-symbol">$</span><span class="hljs-number">0</span>)<br>lui <span class="hljs-symbol">$</span><span class="hljs-number">11</span> <span class="hljs-number">0x1111</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">11</span> <span class="hljs-number">0x1111</span><br>sh <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">2</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>lb <span class="hljs-symbol">$</span><span class="hljs-number">13</span>,<span class="hljs-number">3</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>lh <span class="hljs-symbol">$</span><span class="hljs-number">14</span>,<span class="hljs-number">2</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br><br>mult <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">15</span><br>multu <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">16</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">17</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">18</span><br>mthi <span class="hljs-symbol">$</span><span class="hljs-number">19</span><br>mtlo <span class="hljs-symbol">$</span><span class="hljs-number">20</span><br><br>lui <span class="hljs-symbol">$</span><span class="hljs-number">20</span>,<span class="hljs-number">0</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">20</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">loop</span>:<br>bne <span class="hljs-symbol">$</span><span class="hljs-number">19</span>,<span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-keyword">loop</span><br>sub <span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-symbol">$</span><span class="hljs-number">20</span><br>nop<br><span class="hljs-comment">//重点测试符号乘除</span><br>lui <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-number">0x1111</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-number">0x1111</span><br>add <span class="hljs-symbol">$</span><span class="hljs-number">3</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">0</span><br>mult <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">5</span><br>multu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">7</span><br><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">0</span>,<span class="hljs-number">13</span><br>add <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">9</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">10</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">11</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">12</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">13</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">14</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">15</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">16</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">17</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">18</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">19</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">20</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P5设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P5%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P5%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P5建议：可以在P4的基础上先搭建没有转发、阻塞的流水线CPU，确认功能完善后逐步添加阻塞、转发通路。对于P5，转发与阻塞情况不多，也可采用列举法，后期改为TIME</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h3 id="设计要求">设计要求</h3><ol type="1"><li>处理器应支持如下指令集：{ add, sub, ori, lw, sw, beq, lui, jal, jr,nop }，为五级流水线设计。</li><li>流水线的设计以追求性能为第一目标，因此必须尽最大可能<strong>支持转发</strong>以解决数据冒险。这一点在本project的最终成绩中所占比重较大，课上测试时会通过测试程序所运行的<strong>总周期数</strong>进行判定，望大家慎重对待。</li><li>对于 b 类和 j 类指令，流水线设计必须<strong>支持延迟槽</strong>，因此设计需要注意使用<strong>PC@D + 8</strong>或<strong>PC@I + 4</strong>。</li><li>为了解决数据冒险而设计的转发数据来源必须是<strong>某级流水线寄存器</strong>，<strong>不允许</strong>对功能部件的输出直接进行转发。</li><li>指令存储器（IM，instruction memory）和数据存储器（DM，datamemory）要求如下：<ul><li>IM：容量为 <strong>16KiB</strong>（<strong>4096</strong> ×32bit）。</li><li>DM：容量为 <strong>12KiB</strong>（<strong>3072</strong> ×32bit）。</li></ul></li><li>PC 的初始地址为 <strong>0x00003000</strong>，和 Mars中我们要求设置的代码初始地址相同。</li><li>最外层的 mips 模块的文件名必须为 mips.v ，该文件中的 module也必须命名为 <strong>mips</strong> 。</li></ol><h3 id="模块规格">模块规格</h3><h4 id="架构">架构</h4><figure><img src="/img/CPU架构.jpg" alt="CPU架构" /><figcaption aria-hidden="true">CPU架构</figcaption></figure><h4 id="命名规则">命名规则</h4><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能(_去向)</code> 命名。</p><h4 id="控制器设计">控制器设计</h4><h5 id="指令解读">指令解读</h5><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">000011</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">较为复杂</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">001000</td><td style="text-align: center;">PC=rs</td></tr></tbody></table><p>jal：$31=PC+4，PC=PC[31:28]+index00</p><h4 id="共有信号">共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IM [<span class="hljs-number">0</span>:<span class="hljs-number">4095</span>];<span class="hljs-comment">//存储指令</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IF_pc;<span class="hljs-comment">//存储pc，同时也是当前的pc</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IF_instr;<span class="hljs-comment">//当前的指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr;<span class="hljs-comment">//方便截取特定位宽</span><br><span class="hljs-keyword">assign</span> pc_addr=IF_pc-<span class="hljs-number">32&#x27;h3000</span>;<br><span class="hljs-keyword">assign</span> IF_instr=IM[pc_addr[<span class="hljs-number">13</span>:<span class="hljs-number">2</span>]];<br></code></pre></td></tr></table></figure><h4 id="id">ID</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="even"><td style="text-align: center;">EX_rt_use</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">传递rt供sw写入的值，也可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="odd"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的数据</td><td style="text-align: center;">EX_rt_MEM</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">内存中读出的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-2">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] DM [<span class="hljs-number">0</span>:<span class="hljs-number">3071</span>];<br></code></pre></td></tr></table></figure><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h3 id="冒险处理">冒险处理</h3><h4 id="t_use-与-t_new-的计算"><spanclass="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算</h4><h5 id="指令分类">指令分类</h5><ul><li><p>calr——2个use(rs,rt)，一个new(rd)</p><p>add、sub</p></li><li><p>cali——1个use(rs)，一个new(rt)</p><p>ori、lui</p></li><li><p>lw——1个use(rs/base)，一个new(rt)</p><p>lw</p></li><li><p>sw——2个use(rs,rt)，无new</p><p>sw</p></li><li><p>j_rs——1个use(rs)</p><p>jr、beq</p></li><li><p>j_rt——1个use(rt)</p><p>beq</p></li><li><p>jal——无法分类</p></li></ul><p>其中，beq从属于两种</p><h5 id="列表">列表</h5><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">类型</th><th style="text-align: center;"><spanclass="math inline">\(T_{use}\)</span></th><th style="text-align: center;">转发接口</th><th style="text-align: center;"><spanclass="math inline">\(E\_T_{new}\)</span></th><th style="text-align: center;">提供接口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">calr</td><td style="text-align: center;">1(rs,rt)</td><td style="text-align: center;">ID_rs_base_EX,ID_rt_EX</td><td style="text-align: center;">1(rd)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">calr</td><td style="text-align: center;">1(rs,rt)</td><td style="text-align: center;">ID_rs_base_EX,ID_rt_EX</td><td style="text-align: center;">1(rd)</td><td style="text-align: center;">EX_out</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">cali</td><td style="text-align: center;">1(rs)</td><td style="text-align: center;">ID_rs_base_EX</td><td style="text-align: center;">1(rt)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">lw</td><td style="text-align: center;">1(base)</td><td style="text-align: center;">ID_rs_base_EX</td><td style="text-align: center;">2(rt)</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">sw</td><td style="text-align: center;">1(rs),2(rt)</td><td style="text-align: center;">ID_rs_base_EX,EX_rt_MEM</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">j_rs,j_rt</td><td style="text-align: center;">0(rs,rt)</td><td style="text-align: center;">ID_rs_data,ID_rt_data</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">cali</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td><td style="text-align: center;">1(rt)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">j</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td><td style="text-align: center;">1($31)</td><td style="text-align: center;">EX_out</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">j_rs</td><td style="text-align: center;">0(rs)</td><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr></tbody></table><h4 id="暂停">暂停</h4><h5 id="阻塞分类">阻塞分类</h5><p>总原则： <span class="math inline">\(T_{use}&lt;E\_T_{new}\)</span>、 <span class="math inline">\(T_{use}&lt;M\_T_{new}\)</span>、地址相同</p><p>大致有0&lt;1、0&lt;2、1&lt;2、0&lt;2(M级)四种类型，均需比较地址</p><h5 id="执行操作">执行操作</h5><p>若需要阻塞，则</p><ol type="1"><li>冻结IF/ID</li><li>清除ID/EX</li><li>禁止PC</li></ol><h4 id="转发">转发</h4><h5 id="接口-3">接口</h5><p>见表格</p><h5 id="注意事项">注意事项</h5><ul><li>从W级转发到D级，采用D级内部转发（如beq）</li><li>从W级转发到E、M级，可利用WB的信号直接判断</li><li>MEM写入内存的rt值从D到E再到M，要经过2次转发（如lw $3,0($0) sw$3,0($3)，因为阻塞了一次，W级产生的数据没办法转发到M级，只能是sw在E级时把W级的lw产生的数据转发）</li><li>转发时如果地址是0寄存器应剔除</li></ul><h5 id="遇到的bug修复历史">遇到的bug&amp;修复历史</h5><p>jr忘记加到阻塞里</p><p>lw写入的是rt不是rd，阻塞判断错了</p><p>先lw,后sw发生阻塞时，不能及时转发sw需要、lw产生的rt值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">3</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">3</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>加指令：改const、改阻塞、改转发、</p><h3 id="添加指令">添加指令</h3><ol type="1"><li>添加到const里</li><li>分类，想想有无新的转发通路/阻塞<ul><li>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</li><li>lw：修改EX计算过程、添加WB回写信号，……</li><li>sw：修改EX计算过程、MEM写入，……但是注意“注意事项3”，修改rt在E级的转发</li><li>j_rs：</li><li>j_rt：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</li><li>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</li></ul></li><li>在阻塞和转发中分别添加相应值，注意“注意事项3”</li></ol><h3 id="思考题">思考题</h3><p>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p><p>​ 提前分支判断使得beq的 <span class="math inline">\(T_{use}\)</span>为0，很容易发生阻塞，如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,loop<br></code></pre></td></tr></table></figure><p>​ 如果不提前判断，则可以使用转发解决（但这样好像会多流水一级？）</p><p>2、因为延迟槽的存在，对于 jal等需要将指令地址写入寄存器的指令，要写回 PC +8，请思考为什么这样设计？</p><p>​ jal执行后会无条件执行下一句（pc+4），但jr$ra执行时不会再执行延迟槽中的内容，因此是pc+8</p><p>3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、 ALU ），请思考为什么？</p><p>​ 来自寄存器的输出是稳定的，而功能部件可能输出不稳定</p><p>4、我们为什么要使用 GPR 内部转发？该如何实现？</p><p>​ 为了将来自W级的输出及时写入寄存器（或及时使用）。实现见代码</p><p>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p><p>​ 见“冒险处理”</p><p>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p><p>​ 见“添加指令”</p><p>7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p><p>​分布式译码，每一级流水指令即可，无需流水控制信号，通过宏定义根据指令执行操作</p><p>​ 不足：加指令时需要修改的部件较多</p><h3 id="让我想想">让我想想</h3><h4 id="测试部分">测试部分</h4><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2冒险测试">part2——冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><p>把mips.v里的转发、阻塞写到每个模块里，每个模块只需要针对当前指令给出addr和Tnew，ID给出Tuse</p><p>为什么DM的rt需要在E、M级2次转发？</p><p>大概因为sw在DM才用，lw的数据W级才有，错开就？</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P4设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P4%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P4%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P4建议：翻译P3设计即可，注意新加指令</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h4 id="设计要求">设计要求</h4><ul><li><p>处理器为 32 位单周期处理器，不考虑延迟槽，应支持的指令集为：<code>add, sub, ori, lw, sw, beq, lui, jal, jr, nop</code> ，其中：</p><ul><li><p><code>nop</code> 为空指令，机器码<code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</p></li><li><p><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</p></li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层文件为<strong>mips.v</strong>，有效的驱动信号要求包括且仅包括<strong>同步复位信号reset</strong> 和<strong>时钟信号 clk</strong>，接口定义如下：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset<br>);<br></code></pre></td></tr></table></figure><h4 id="模块规格">模块规格</h4><h5 id="顶层设计">顶层设计</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset<br>    );<br><br><span class="hljs-comment">//CON</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Instr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] j_ctrl;<span class="hljs-comment">//跳转指令，0为正常+4  1为beq  2为jal  3为jr</span><br><span class="hljs-keyword">wire</span> grf_write;<span class="hljs-comment">//grf写入信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] grf_reg;<span class="hljs-comment">//选择grf写入的寄存器</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] grf_data;<span class="hljs-comment">//选择grf写入数据来源</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ALU_op;<span class="hljs-comment">//运算选择</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ALU_data_op;<span class="hljs-comment">//运算数选择</span><br><span class="hljs-keyword">wire</span> MemWrite;<span class="hljs-comment">//数据写入信号</span><br><span class="hljs-comment">//PC</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] j_addr;<span class="hljs-comment">//PC跳转地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc;<span class="hljs-comment">//PC</span><br><span class="hljs-comment">//ALU</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ALU_out;<span class="hljs-comment">//ALU运算结果</span><br><span class="hljs-comment">//reg</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RegAddr;<span class="hljs-comment">//写入的寄存器</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WD;<span class="hljs-comment">//写入的数据</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD1;<span class="hljs-comment">//读出的寄存器数据1</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD2;<span class="hljs-comment">//读出的寄存器数据2</span><br><span class="hljs-comment">//ALU</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b;<span class="hljs-comment">//运算数2</span><br><span class="hljs-comment">//DM</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] DM_out;<span class="hljs-comment">//DM读出的数据</span><br><span class="hljs-comment">//decode</span><br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] im_of;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] Func;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rd;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rt;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rs_base;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] Op_code;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">25</span>:<span class="hljs-number">0</span>] index;<br><span class="hljs-keyword">assign</span> im_of=Instr[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> Func=Instr[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> rd=Instr[<span class="hljs-number">15</span>:<span class="hljs-number">11</span>];<br><span class="hljs-keyword">assign</span> rt=Instr[<span class="hljs-number">20</span>:<span class="hljs-number">16</span>];<br><span class="hljs-keyword">assign</span> rs_base=Instr[<span class="hljs-number">25</span>:<span class="hljs-number">21</span>];<br><span class="hljs-keyword">assign</span> Op_code=Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>];<br><span class="hljs-keyword">assign</span> index=Instr[<span class="hljs-number">25</span>:<span class="hljs-number">0</span>];<br><br><br><span class="hljs-keyword">assign</span> j_addr=(j_ctrl==<span class="hljs-number">2&#x27;b00</span>)?(pc+<span class="hljs-number">4</span>):<br>    (j_ctrl==<span class="hljs-number">2&#x27;b01</span>)?(pc+<span class="hljs-number">4</span>+&#123;&#123;<span class="hljs-number">14</span>&#123;im_of[<span class="hljs-number">15</span>]&#125;&#125;,im_of,<span class="hljs-number">2&#x27;b0</span>&#125;):<span class="hljs-comment">//beq</span><br>                    (j_ctrl==<span class="hljs-number">2&#x27;b10</span>)?(&#123;pc[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>],index,<span class="hljs-number">2&#x27;b0</span>&#125;):<span class="hljs-comment">//jal</span><br>                    RD1;<span class="hljs-comment">//jr</span><br><span class="hljs-keyword">assign</span> RegAddr=(grf_reg==<span class="hljs-number">2&#x27;b00</span>)?rd:<br>                    (grf_reg==<span class="hljs-number">2&#x27;b01</span>)?rt:<br>                    <span class="hljs-number">5&#x27;b11111</span>;<span class="hljs-comment">//写入$ra</span><br><span class="hljs-keyword">assign</span> WD=(grf_data==<span class="hljs-number">2&#x27;b00</span>)?ALU_out:<br>                (grf_data==<span class="hljs-number">2&#x27;b01</span>)?DM_out:<span class="hljs-comment">//lw</span><br>                (grf_data==<span class="hljs-number">2&#x27;b10</span>)?&#123;im_of,&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;&#125;:<span class="hljs-comment">//lui</span><br>                pc+<span class="hljs-number">4</span>;<span class="hljs-comment">//写入$ra</span><br><span class="hljs-keyword">assign</span> b=(ALU_data_op==<span class="hljs-number">0</span>)?RD2:<br>            (ALU_data_op==<span class="hljs-number">1</span>)?&#123;&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;,im_of&#125;:<span class="hljs-comment">//ori</span><br>            &#123;&#123;<span class="hljs-number">16</span>&#123;im_of[<span class="hljs-number">15</span>]&#125;&#125;,im_of&#125;;<span class="hljs-comment">//lw,sw</span><br><br>controller con(Instr,j_ctrl,grf_write,grf_reg,grf_data,ALU_op,ALU_data_op,MemWrite,ALU_out);<br>PC Pc(clk,reset,j_addr,pc);<br>IM im(pc,Instr);<br>GRF grf(clk,reset,grf_write,RegAddr,WD,rs_base,rt,RD1,RD2);<br>ALU alu(ALU_op,RD1,b,ALU_out);<br>DM dm(clk,reset,MemWrite,ALU_out,RD2,DM_out);<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(grf_write==<span class="hljs-number">1</span>&amp;&amp;reset!=<span class="hljs-number">1</span>)<span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: $%d &lt;= %h&quot;</span>, pc, RegAddr, WD);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(MemWrite==<span class="hljs-number">1</span>&amp;&amp;reset!=<span class="hljs-number">1</span>)<span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: *%h &lt;= %h&quot;</span>, pc, ALU_out, RD2);<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">integer fp;</span><br><span class="hljs-comment">initial begin</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">fp = $fopen(&quot;info.txt&quot;,&quot;w&quot;);</span><br><span class="hljs-comment">end</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h5 id="ifu取指令单元">IFU（取指令单元)</h5><ul><li><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p></li><li><p>PC用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</p></li><li><p><strong>起始地址：0x00003000</strong>。</p></li><li><p>地址范围：0x00003000 ~ 0x00006FFF。</p></li><li><p>IM 用 ROM 实现，容量为 4096 × 32bit。</p></li><li><p>IM 实际地址宽度仅为 12 位，需要使用恰当的方法将 PC 中储存的地址同IM 联系起来。</p></li></ul><h6 id="pcmoore型状态机">PC（Moore型状态机）</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">j_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">pc、Instr</td></tr><tr class="even"><td style="text-align: center;">addr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">下一条指令地址</td><td style="text-align: center;">IM</td></tr></tbody></table><h6 id="im">IM</h6><p><code>reg [31:0] IM [0:4095]</code></p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令地址</td><td style="text-align: center;">j_addr</td></tr><tr class="even"><td style="text-align: center;">Instr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td><td style="text-align: center;">很多</td></tr></tbody></table><h5id="grf通用寄存器组也称为寄存器文件寄存器堆">GRF（通用寄存器组，也称为寄存器文件、寄存器堆）</h5><ul><li><p>用具有写使能的寄存器实现，寄存器总数为 32个，应具有<strong>异步复位</strong>功能。</p></li><li><p><strong>0 号寄存器</strong>的值始终保持为0。其他寄存器<strong>初始值（复位后）均为0</strong>，无需专门设置。</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">WE</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">写使能信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">RegAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">GRF 5 位写入地址</td><td style="text-align: center;">rd/rt/$ra</td></tr><tr class="odd"><td style="text-align: center;">WD</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位写入数据</td><td style="text-align: center;">ALU/DM/im_of/pc</td></tr><tr class="even"><td style="text-align: center;">A1</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">rs_base</td></tr><tr class="odd"><td style="text-align: center;">A2</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">rt</td></tr><tr class="even"><td style="text-align: center;">RD</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">RD2</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr></tbody></table><h5 id="alu算术逻辑单元">ALU（算术逻辑单元）</h5><p>？比较按无符号还是有符号？</p><ul><li><p>提供 32 位加、减、或运算及大小比较功能。</p></li><li><p>加减法按无符号处理（不考虑溢出）。</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">in</td><td style="text-align: center;">2</td><td style="text-align: center;">功能选择</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">a</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数1</td><td style="text-align: center;">RD1</td></tr><tr class="odd"><td style="text-align: center;">b</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数2</td><td style="text-align: center;">RD2/im_of</td></tr><tr class="even"><td style="text-align: center;">out</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">结果</td><td style="text-align: center;">WD/MemAddr/con</td></tr></tbody></table><h5 id="dm数据存储器">DM（数据存储器）</h5><ul><li><p>使用 RAM 实现，容量为 3072 ×32bit，应具有<strong>异步复位</strong>功能，复位值为0x00000000。</p></li><li><p><strong>起始地址：0x00000000</strong>。</p></li><li><p>地址范围：0x00000000 ~ 0x00002FFF。</p></li><li><p>RAM 应使用双端口模式，即设置 RAM 的 <strong>DataInterface</strong> 属性为 <strong>Separate load and storeports</strong>。</p></li></ul><p><code>reg [31:0] DM [0:3071]</code></p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">DM 写入控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">MemAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入地址</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">MemData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入数据</td><td style="text-align: center;">RD2</td></tr><tr class="even"><td style="text-align: center;">MemData</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位输出数据</td><td style="text-align: center;">WD</td></tr></tbody></table><h5 id="ext扩展单元">EXT（扩展单元）</h5><ul><li>可以使用 Logisim 内置的 Bit Extender。</li></ul><h5 id="controller控制器">Controller（控制器）</h5><ul><li><p>使用与或门阵列构造控制信号的具体方法见后文叙述。</p></li><li><p>也可以通过其它方式构造控制信号，同学们可以自行探索。</p></li></ul><h6 id="指令解读">指令解读</h6><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">000011</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">较为复杂</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">001000</td><td style="text-align: center;">PC=rs</td></tr></tbody></table><p>jal：$31=PC+4，PC=PC[31:28]+index00</p><h6 id="控制器">控制器</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td></tr><tr class="even"><td style="text-align: center;">ALU_out</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">比较结果</td></tr><tr class="odd"><td style="text-align: center;">ctrl</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">PC，0(beq),1(jal),2(jr)</td></tr><tr class="even"><td style="text-align: center;">WE</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，写使能信号</td></tr><tr class="odd"><td style="text-align: center;">GRF_op1</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">GRF，控制写入地址来源,0(rd),1(rt),2($ra)</td></tr><tr class="even"><td style="text-align: center;">GRF_op2</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">GRF，控制写入数据来源,0(ALU),1(DM),2(im_of),3(index)</td></tr><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">ALU，运算选择0(+),1(-),2(|),3(==)</td></tr><tr class="even"><td style="text-align: center;">ALU_op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">ALU，控制运算数来源（0,rt,1,0-im,2,sign-of）</td></tr><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">DM，写入控制信号</td></tr></tbody></table><h4 id="思考题">思考题</h4><ol type="1"><li><p>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit ×1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr位数为什么是 [11:2] 而不是 [9:0] ？</p><figure><imgsrc="http://cscore.buaa.edu.cn/assets/cscore-image/refkxh/86953c72-c519-48b2-8cb8-7b2c90850e53/66.png"alt="66.png" /><figcaption aria-hidden="true">66.png</figcaption></figure><p>ALU的运算结果；截取高位实现右移2位的效果（lw、sw均为字操作，地址是4的倍数）</p></li><li><p>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</p><p>地方</p><p>指令</p></li></ol><p>指令对应的控制信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> ctrl=(beq&amp;&amp;ALU_out==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<br>                (jal)?<span class="hljs-number">2</span>:<br>                (jr)?<span class="hljs-number">3</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> WE=(add||sub||ori||lw||lui||jal);<br><span class="hljs-keyword">assign</span> GRF_op1=(ori||lw||lui)?<span class="hljs-number">1</span>:<span class="hljs-comment">//rt</span><br>                    (jal)?<span class="hljs-number">2</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//$ra</span><br><span class="hljs-keyword">assign</span> GRF_op2=(jal)?<span class="hljs-number">3</span>:<br>                    (lui)?<span class="hljs-number">2</span>:<br>                    (lw)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> op=(beq)?<span class="hljs-number">3</span>:<br>                (ori)?<span class="hljs-number">2</span>:<br>                (sub)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> ALU_op=(lw||sw)?<span class="hljs-number">2</span>:<br>                    (ori||lui)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> MemWrite=(sw);<br></code></pre></td></tr></table></figure><p>控制信号每种取值对应的指令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> add,sub,ori,lw,sw,beq,lui,jal,jr;<br><span class="hljs-keyword">assign</span> add=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b100000</span>);<br><span class="hljs-keyword">assign</span> sub=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b100010</span>);<br><span class="hljs-keyword">assign</span> ori=(Op_code==<span class="hljs-number">6&#x27;b001101</span>);<br><span class="hljs-keyword">assign</span> lw=(Op_code==<span class="hljs-number">6&#x27;b100011</span>);<br><span class="hljs-keyword">assign</span> sw=(Op_code==<span class="hljs-number">6&#x27;b101011</span>);<br><span class="hljs-keyword">assign</span> beq=(Op_code==<span class="hljs-number">6&#x27;b000100</span>);<br><span class="hljs-keyword">assign</span> lui=(Op_code==<span class="hljs-number">6&#x27;b001111</span>);<br><span class="hljs-keyword">assign</span> jal=(Op_code==<span class="hljs-number">6&#x27;b000011</span>);<br><span class="hljs-keyword">assign</span> jr=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b001000</span>);<br><br><br><span class="hljs-keyword">assign</span> ctrl=(beq&amp;&amp;ALU_out==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<br>                (jal)?<span class="hljs-number">2</span>:<br>                (jr)?<span class="hljs-number">3</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> WE=(add||sub||ori||lw||lui||jal);<br><span class="hljs-keyword">assign</span> GRF_op1=(ori||lw||lui)?<span class="hljs-number">1</span>:<span class="hljs-comment">//rt</span><br>                    (jal)?<span class="hljs-number">2</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//$ra</span><br><span class="hljs-keyword">assign</span> GRF_op2=(jal)?<span class="hljs-number">3</span>:<br>                    (lui)?<span class="hljs-number">2</span>:<br>                    (lw)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> op=(beq)?<span class="hljs-number">3</span>:<br>                (ori)?<span class="hljs-number">2</span>:<br>                (sub)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> ALU_op=(lw||sw)?<span class="hljs-number">2</span>:<br>                    (ori||lui)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> MemWrite=(sw);<br></code></pre></td></tr></table></figure><p>优劣：第一种比较直接，控制信号直接由指令决定，但可读性差</p><p>第二种可读性好，但指令条数增多后代码冗余</p><ol start="3" type="1"><li><p>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与P3中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的reset 信号与 clk 信号优先级的关系。</p><p>同步复位：clk&gt;reset</p><p>异步复位：reset&gt;clk</p></li><li><p>C 语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着 C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C语言，MIPS 指令的所有计算指令均可以忽略溢出。请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II:The MIPS32® Instruction Set》中相关指令的 Operation 部分。</p><p>与addiu相比，addi将32位扩展为33位并判断是否溢出，但忽略溢出后只关注前32位，因此相当于没拓展，和addiu相同</p><p>add与addu同理</p></li></ol><h4 id="测试方案">测试方案</h4><h5 id="机器码转指令的">机器码转指令的</h5><p>运行C语言代码（code_instruction.c），1为从文件输入，输出到文件；2为单个指令翻译</p><h5 id="自动生成数据点的代码">自动生成数据点的代码</h5><p>待开发，目前只有手敲代码（</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>jal loop3#往前跳<br>jal loop4#往后跳<br>loop4:<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>jal end2#原地蹦跶<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P3设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P3%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P3%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P3建议：在阅读课件的基础上梳理每个线路、接口的数据从哪里来、到哪里去，便于理解</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h4 id="设计要求">设计要求</h4><ul><li><p>处理器为 32 位单周期处理器，应支持的指令集为：<code>add, sub, ori, lw, sw, beq, lui, nop</code> ，其中：</p><ul><li><code>nop</code> 为空指令，机器码<code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</li><li><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层有效的驱动信号要求包括且仅包括<strong>异步复位信号reset</strong>（clk 请使用内置时钟模块）。</p></li></ul><h4 id="模块规格">模块规格</h4><h5 id="顶层设计">顶层设计</h5><figure><img src="/img/image-20231026090817666.png"alt="image-20231026090817666" /><figcaption aria-hidden="true">image-20231026090817666</figcaption></figure><h5 id="ifu取指令单元">IFU（取指令单元）</h5><ul><li>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</li><li>PC用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</li><li><strong>起始地址：0x00003000</strong>。</li><li>地址范围：0x00003000 ~ 0x00006FFF。</li><li>IM 用 ROM 实现，容量为 4096 × 32bit。</li><li>IM 实际地址宽度仅为 12 位，需要使用恰当的方法将 PC 中储存的地址同 IM联系起来。</li></ul><h6 id="pcmoore型状态机">PC（Moore型状态机）</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">内置</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">异步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">ctrl</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">beq_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IM的Instr</td></tr><tr class="odd"><td style="text-align: center;">addr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">下一条指令地址</td><td style="text-align: center;">IM</td></tr></tbody></table><p>难点：异步复位置0x00003000</p><p>解决方案：输出+0x00003000，内部仍从0开始</p><h6 id="im">IM</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">sel？</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">读取选择信号</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">addr</td><td style="text-align: center;">in</td><td style="text-align: center;">12</td><td style="text-align: center;">指令地址</td><td style="text-align: center;">PC</td></tr><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td><td style="text-align: center;">Control/PC/</td></tr></tbody></table><h5id="grf通用寄存器组也称为寄存器文件寄存器堆">GRF（通用寄存器组，也称为寄存器文件、寄存器堆）</h5><ul><li>用具有写使能的寄存器实现，寄存器总数为 32个，应具有<strong>异步复位</strong>功能。</li><li><strong>0 号寄存器</strong>的值始终保持为0。其他寄存器<strong>初始值（复位后）均为0</strong>，无需专门设置。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">内置</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">异步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">WE/RegWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">写使能信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">RegAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">GRF 5 位写入地址</td><td style="text-align: center;">Instr</td></tr><tr class="odd"><td style="text-align: center;">WD/RegData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位写入数据</td><td style="text-align: center;">ALU/DM/Instr</td></tr><tr class="even"><td style="text-align: center;">A1</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">Instr</td></tr><tr class="odd"><td style="text-align: center;">A2</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">Instr</td></tr><tr class="even"><td style="text-align: center;">RD</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">RD2</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr></tbody></table><h5 id="alu算术逻辑单元">ALU（算术逻辑单元）</h5><p>？比较按无符号还是有符号？</p><ul><li>提供 32 位加、减、或运算及大小比较功能。</li><li>加减法按无符号处理（不考虑溢出）。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">in</td><td style="text-align: center;">2</td><td style="text-align: center;">功能选择</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">a</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数1</td><td style="text-align: center;">GRF/Instr</td></tr><tr class="odd"><td style="text-align: center;">b</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数2</td><td style="text-align: center;">GRF/Instr</td></tr><tr class="even"><td style="text-align: center;">out</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">结果</td><td style="text-align: center;">GRF/DM</td></tr></tbody></table><h5 id="dm数据存储器">DM（数据存储器）</h5><ul><li>使用 RAM 实现，容量为 3072 ×32bit，应具有<strong>异步复位</strong>功能，复位值为 0x00000000。</li><li><strong>起始地址：0x00000000</strong>。</li><li>地址范围：0x00000000 ~ 0x00002FFF。</li><li>RAM 应使用双端口模式，即设置 RAM 的 <strong>Data Interface</strong>属性为 <strong>Separate load and store ports</strong>。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">DM 写入控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">MemAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入地址</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">MemData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入数据</td><td style="text-align: center;">GRF</td></tr><tr class="even"><td style="text-align: center;">MemData</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位输出数据</td><td style="text-align: center;">GRF</td></tr></tbody></table><h5 id="ext扩展单元">EXT（扩展单元）</h5><ul><li>可以使用 Logisim 内置的 Bit Extender。</li></ul><h5 id="controller控制器">Controller（控制器）</h5><ul><li>使用与或门阵列构造控制信号的具体方法见后文叙述。</li><li>也可以通过其它方式构造控制信号，同学们可以自行探索。</li></ul><h6 id="指令解读">指令解读</h6><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr></tbody></table><h6 id="控制器">控制器</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td></tr><tr class="even"><td style="text-align: center;">ctrl</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">PC，控制是否beq</td></tr><tr class="odd"><td style="text-align: center;">WE</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，写使能信号</td></tr><tr class="even"><td style="text-align: center;">GRF_op1</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，控制写入地址来源（0,rd）</td></tr><tr class="odd"><td style="text-align: center;">GRF_op2</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">GRF，控制写入数据来源（0,ALU,1,DM）</td></tr><tr class="even"><td style="text-align: center;">op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">ALU，运算选择</td></tr><tr class="odd"><td style="text-align: center;">ALU_op</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">ALU，控制运算数来源（0,rt,1,im,2,of）</td></tr><tr class="even"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">DM，写入控制信号</td></tr></tbody></table><h4 id="思考题">思考题</h4><ol type="1"><li><p>上面我们介绍了通过 FSM 理解单周期 CPU的基本方法。请大家指出单周期 CPU所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p><p>状态存储：GRF、DM、IFU</p><p>状态转移：ALU、Controller、EXT</p></li><li><p>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p><p>合理，IM存储指令，一般无需、也不应在执行过程中修改，因此使用ROM；DM需要读写，因此使用RAM；GRF所需存储规模较小，而且某些指令需要同时执行存储、读出行为，因此每一寄存器用Register较为合理。</p></li><li><p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p><p>设计了指令解读模块，将32位机器码按字段转为相应的值如OPcode、rt、offset等。思路就是利用splitter，只是将其封装为模块。</p></li><li><p>事实上，实现 <code>nop</code>空指令，我们并不需要将它加入控制信号真值表，为什么？</p><p>输入nop指令时，Conrtoller内部的与门阵列输出信号全为0，GRF、DM的写信号为0，因此相当于没进行任何操作。</p></li><li><p>阅读 Pre 的 <ahref="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS指令集及汇编语言”</a>一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p><p>指令覆盖情况：缺少sub指令</p><p>单一指令覆盖：add缺少 <code>intmax</code>，ori缺少中间值，lui缺少0，lw、sw偏移量没考虑负数，beq跳转范围应包含前后。</p></li></ol><h4 id="测试方案">测试方案</h4><h5 id="机器码转指令的">机器码转指令的</h5><p>运行C语言代码（code_instruction.c），1为从文件输入，输出到文件；2为单个指令翻译</p><h5 id="自动生成数据点的c语言代码">自动生成数据点的C语言代码</h5><p>待开发，目前只有手敲代码（</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,31<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br></code></pre></td></tr></table></figure><h5 id="命令行自动化测试">命令行自动化测试</h5><p>文件夹下：logisim的jar包、测试电路文件</p><p>文件夹打开命令行输入：<code>java -jar logisim-generic-2.7.1.jar 单周期CPU.circ -tty table &gt; result.txt</code></p><p>运行C语言代码（CPU_test.c），依次输出32个寄存器存储数值，可与MARS比较</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P7教程</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P7%E6%95%99%E7%A8%8B/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统">计算机系统</h1><h2 id="mips-微系统">MIPS 微系统</h2><p>当我们完成 P6 以后，可以说我们已经完成了一个复杂度相当高的 CPU，这个CPU可以利用流水线技术并行指令，并按照指令的内容完成计算，修改寄存器中的值。那么是不是完成这个CPU 就是掌握计算机组成这门课程的全貌了呢？我们说并不是这样。</p><p>CPU 的全称是 Central ProcessingUnit，也就是“中央处理器”。也就是说，CPU的功能就是数据的“加工与处理”。而计算机系统不仅要完成数据的加工处理，还要完成诸如输入，输出，存储，网络等多种功能，也就是说，<strong>“CPU不等价于计算机系统”</strong>。在 P7我们要完成的任务，就是实现一个简单的计算机系统，也就是“MIPS微系统”。</p><h2 id="外设">外设</h2><p>外设即外部设备，他们可以看做是与 CPU地位平等的一组设备。在计算机系统中，CPU负责数据的加工处理，而外设则负责输入（鼠标，键盘），输出（显示屏，扬声器），存储（硬盘，U盘），网络（网卡）等。我们的 MIPS 微系统中包括的外设主要有 3种，即计时器、存储器、中断发生器：</p><ul><li>计时器（Timer）：计算机系统中的计时部件，可以按照配置定时地产生时钟中断。</li><li>存储器（Memory）：计算机系统中的存储部件，用于存储指令和数据。我们在P6 的时候已经接触过了。</li><li>中断发生器（InterruptGenerator）：抽象的计算机系统外设，会随机的产生外部中断信号，产生的中断信号在CPU 响应前会持续置高。</li></ul><p>正如 CPU 一样，这些外设也可以用 Verilog语言对其进行建模。最终我们整个微系统都可以用 Verilog语言建模。为了让同学们在 P7有一个更好的实现体验，我们在这一章会只进行设计概念上的介绍，而在下一章介绍具体的实现规格和细节。希望同学们在这一章先熟悉一些系统设计的基本理念，然后在下一章具体的实现中去进一步体悟。</p><h1 id="支持异常处理流的-cpu">支持异常处理流的 CPU</h1><h2 id="之前的-cpu">之前的 CPU</h2><p>在 P6 我们完成的 CPU已经具有了很好的功能，他可以顺序的执行指令（有时会发生跳转）。那么我们考虑，这样的一个CPU 还有哪些缺陷，我们认为主要有两点：</p><ul><li>此时的 CPU 是没有办法处理错误的指令的。例如 <code>add</code>指令，当两个源操作数相加发生溢出的时候，按照规范这是<strong>异常</strong>的情况。我们在P6 的时候默认“溢出加”，会得到一个错误的答案。我们会在 P7对这个问题进行解决。</li><li>此时的 CPU 是没有办法实现与外设复杂的交互的，当计时器向 CPU传递一个信号的时候，CPU是没有办法立刻响应这个信号并做出相应的处理的。</li></ul><p>直观地说，P6 设计出的 CPU运行时的可靠性和完备性都不令人满意。如果运行在其上的程序有一些 bug，CPU既不能检测到这些 bug 并向使用者报告，也不能做出保证正确性的处理，CPU无法满足现实场景下的多种功能。</p><h2 id="异常处理流">异常处理流</h2><p>异常处理流指的是，CPU在执行程序的指令的时候，会发生一些“事件”，改变程序的原有流向，让<code>PC</code> 跳转到特定的地址。</p><p>异常处理流可以很好的解决上面的问题。当指令执行错误时，可以产生一个“事件”。那么CPU就会跳转到一个处理这种执行错误的程序上执行，在处理结束后再跳转回原来的程序（不一定是“事件”来临时的地址）。对于外设的信号，我们可以将其视为一个“事件”，当“事件”来临时，CPU会跳转到一个响应这个“事件”的程序处进行响应，在处理结束后再次跳转回原来的程序。</p><p>异常处理流可以用下面的这张图直观地表示，可以将其理解为<strong>“发生位置不确定的过程调用”</strong>。</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/theory/assets/stream.svg"alt="image-20220626094859732" /><figcaption aria-hidden="true">image-20220626094859732</figcaption></figure><h2 id="概念辨析">概念辨析</h2><p>为了降低同学们实现的困难，我们参照《See MIPS RunLinux》制定了以下概念规范。需要强调的是，这些概念的名字仅在 P7的实现中有效。不同的参考资料对于相同的事物可能会给出不同的概念名称，所以可能指导书会与教材、参考资料或者授课PPT 的概念存在冲突。</p><p><strong>在 P7实验中请以指导书为准，在其他场景中请具体分析。</strong></p><p>我们之前提到的“事件”一共有两种：</p><table><thead><tr class="header"><th style="text-align: left;">概念</th><th style="text-align: left;">定义</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">内部异常</td><td style="text-align: left;">由于指令执行错误导致的“事件”</td><td style="text-align: left;">加法溢出，除法除零等</td></tr><tr class="even"><td style="text-align: left;">外部中断</td><td style="text-align: left;">由于外部设备信号导致的“事件”</td><td style="text-align: left;">计时器信号，键盘输入等</td></tr></tbody></table><p>因为这两类“事件”的处理具有一定的共同性，所以我们统一称他们为“异常”，如下图所示：</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/theory/assets/exception.png"alt="image-20220626105259107" /><figcaption aria-hidden="true">image-20220626105259107</figcaption></figure><p>为了响应异常，CPU 会自动跳转到某一特定的地点（将 PC修改为特定值），然后进行异常处理。这里进行异常处理的程序叫做“异常处理程序”，是软件（在计组中表现为一段汇编代码），是不属于MIPS 微系统内的。在课程平台的自动测试中，评测数据将包含handler，但是我们仍要编写它来进行本地测试。</p><p>思考题</p><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>思考题</p><p>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><h1 id="软硬件接口">软硬件接口</h1><h2 id="接口的理解">接口的理解</h2><p>正如前面所描述的，在 P7 要完成的不再是 CPU 这个单独的功能模块，而是CPU与多个外设组成的计算机系统，各个模块之间需要进行合作。那么应该如何进行合作呢？</p><p>合作的前提就是“约定”。参与合作的人必须对其他人给出可以让自己完成功能的“约定”。比如说在“老师和学生上课”这个合作关系下，老师需要给出自己的上课时间和下课时间。如果老师并不告诉学生这个信息，这个合作就是进行不下去的。在计算机系统里，我们称这种“约定”为“接口”。</p><h2 id="接口的设计">接口的设计</h2><p>接口设计重要的一个方向就是要<strong>足够简洁</strong>。依然用“老师和学生上课”的例子，“我在8:00 上课，你们需要在这个时刻到达” 和 “我在 7:30 到达食堂吃早餐，然后吃20 分钟烧麦，10 分钟后到达教室给你们上课，你们需要在这个时刻到达”两种“接口”都是可以让学生正常上课，但是学生肯定会更喜欢第一种，因为这种接口的设计简洁，学生并不需要了解老师吃早饭的细节。</p><p>那么是什么带来了这种简洁性呢？并不是因为第一个老师不吃早饭导致的，两个老师都是吃早饭的，但是第一个老师贴心的计算出了自己到达教室的时间，而第二个老师将自己早上的所有细节都暴露了出去。</p><p>同时，这种简洁性并非是功能元件本身的简洁性导致的，而是功能元件在向外界提供接口的时候，隐藏了自己内部的复杂的实现细节，只提供给外界一种简单的接口。这就是著名的<strong>“高内聚，低耦合”</strong>原理。</p><p>这个“隐藏内部实现细节，向外部提供接口”的行为也叫做<strong>“封装”</strong>。需要强调的是，为了实现接口的简洁性，在模块的内部需要进行一些实现。也就是说，为了实现接口的简洁性，需要在模块内部付出额外的努力。</p><h2 id="外设的接口设计-系统桥">外设的接口设计-系统桥</h2><p>外设的种类是无穷无尽的，而 CPU的指令集却是有限的。我们并不能总是因为新加入了一个外设，就专门为这个外设增加新的CPU 指令。我们希望的是，尽管外设多种多样，但是 CPU可以用统一的方法访问它们。为了实现这个目标，我们设计了系统桥。</p><p>系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设。系统桥统一且简化了CPU 的对外接口，CPU不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p><p>在 P7 中，CPU 对于 DM、Timer 和 InterruptGenerator的访问都是需要通过系统桥的。</p><h2 id="cpu-的接口设计-封装成单周期-cpu">CPU 的接口设计-封装成单周期CPU</h2><p>P6 的 CPU 是一个五级流水的设计。也就是说，同一时刻，可能会运行 1~5条指令，这取决于是否阻塞等条件。这些具体的 CPU实现细节，软件是并不关心的。当我们编写汇编语言的时候，是不需要考虑我们的CPU是否会发生阻塞，是否会有转发等实现细节的。而软件之所以可以这么轻松，是因为CPU 实现了一个封装，即<strong>“将复杂的多级流水线 CPU封装成了简单的单周期 CPU”</strong>。在计算机系统中，将 CPU封装成单周期是理解 P7 任务的关键。</p><h1 id="任务清单">任务清单</h1><p>P7 与之前的 project相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7需要的事宜：</p><table><thead><tr class="header"><th style="text-align: left;">任务</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">计时器</td><tdstyle="text-align: left;">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr class="even"><td style="text-align: left;">系统桥</td><td style="text-align: left;">为 CPU提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr class="odd"><td style="text-align: left;">协处理器 CP0</td><td style="text-align: left;">设置 CPU 的异常处理功能，反馈 CPU的异常信息，需要按规格自行实现。</td></tr><tr class="even"><td style="text-align: left;">内部异常检测与流水</td><td style="text-align: left;">CPU需要具有可以检测内部指令执行错误的能力。</td></tr><tr class="odd"><td style="text-align: left;">外部中断响应</td><td style="text-align: left;">CPU需要具有初步响应外部中断信号的能力。</td></tr><tr class="even"><td style="text-align: left;">异常处理指令</td><tdstyle="text-align: left;">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr class="odd"><td style="text-align: left;">单周期 CPU 的封装</td><td style="text-align: left;">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr class="even"><td style="text-align: left;">异常处理程序</td><td style="text-align: left;">利用 MARS编写简单的异常处理程序用于测试。</td></tr></tbody></table><p>最后的架构图如图所示：</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/structure.svg"alt="structure" /><figcaption aria-hidden="true">structure</figcaption></figure><h1 id="外设的实现">外设的实现</h1><h2 id="计时器">计时器</h2><p>在 P7 这个简单的 MIPS微系统中，计时器是一种外部设备，其主要功能就是<strong>根据设定的时间来定时产生中断信号</strong>，是我们系统的中断来源之一。</p><p>在今年的教程中，我们向同学们提供已实现的计时器 <ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/P7_standard_timer_2019.v">Verilog源代码</a>。 timer 内部需要定义多个程序员可见寄存器，如<strong>CTRL</strong>、<strong>PRESET</strong>等，也需要定义若干用于完成功能的内部寄存器（程序员不可见），详情请参考设计文档：<ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/COCO定时器设计规范-1.0.0.4.pdf">CO定时器设计规范-1.0.0.4.pdf</a>。</p><h2 id="中断发生器">中断发生器</h2><p>这是课程组抽象简化现实中外设后得到的一种外设，会在不确定的时刻产生一个中断信号（就好像电脑并不知道谁会在什么时候敲击键盘一样），并持续置高。直到微系统做出响应，才变回低位。</p><p>对中断发生器的响应是通过系统桥来实现的，通过 <code>store</code>类指令访问地址 <code>0x7F20</code>，就可以达到响应中断的目的。</p><p>中断发生器的实现并不需要同学们来完成，不同的中断发生器（中断信号产生的规则不一样）都是在测试的tb 上实现的。同学们只需要确保自己的 P7微系统，具有以下两个能力，就可以满足这个方面的测试：</p><ul><li>微系统可以通过外部端口接受外部中断信号（在计时器部分已经实现了）。</li><li>微系统可以通过访问地址 <code>0x7F20</code> 的 <code>store</code>类指令，改变对应的微系统输出信号（<code>m_int_addr</code>，<code>m_int_byteen</code>），即系统桥实现正确。</li></ul><h2 id="系统桥">系统桥</h2><p>怎样使外设与 CPU 进行沟通呢？采用划分地址空间的办法后，与外设沟通和与DM 沟通的方式类似，通过一个 CPU视图下的内存地址，读写相应数据即可达到与外设沟通的目的。而这个所谓的内存，在外设中，实际上只是若干寄存器。系统桥传入对地址的访问请求后，我们通过系统桥内部的转换代码，将请求转变为对相应寄存器的读写操作。</p><p>下表是规定的地址空间设计，测试程序也将以此为根据编写。需要注意的是，P7与《See MIPS Run Linux》和 PPT 中给出的 MIPS 系统地址范围是不同的，而与MARS 相同，这主要是为了能够让你能更好的验证设计。</p><table><thead><tr class="header"><th style="text-align: center;">条目</th><th style="text-align: center;">地址或地址范围</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数据存储器</td><td style="text-align: center;">0x0000_0000∼0x0000_2FFF</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">指令存储器</td><td style="text-align: center;">0x0000_3000∼0x0000_6FFF</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">PC 初始值</td><td style="text-align: center;">0x0000_3000</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">异常处理程序入口地址</td><td style="text-align: center;">0x0000_4180</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">计时器 0 寄存器地址</td><td style="text-align: center;">0x0000_7F00∼0x0000_7F0B</td><td style="text-align: center;">计时器 0 的 3 个寄存器</td></tr><tr class="even"><td style="text-align: center;">计时器 1 寄存器地址</td><td style="text-align: center;">0x0000_7F10∼0x0000_7F1B</td><td style="text-align: center;">计时器 1 的 3 个寄存器</td></tr><tr class="odd"><td style="text-align: center;">中断发生器响应地址</td><td style="text-align: center;">0x0000_7F20∼0x0000_7F23</td><td style="text-align: center;"></td></tr></tbody></table><p>注意实现系统桥时，其必须作为独立 module 来实现，不能包含在 CPU内部。关于系统桥的具体编写，请大家参考该文件 <ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/L15-支持IO.pdf">L15-支持IO.pdf</a>。</p><p>思考题</p><p>为何与外设通信需要 Bridge？</p><p>思考题</p><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><h1 id="异常处理流的实现">异常处理流的实现</h1><h2 id="cp0-的寄存器">CP0 的寄存器</h2><p>CP0 协处理器是 P7新引入的功能模块，我们需要用这个模块完成两个主要功能，一个是对异常进行配置，一个是记录异常的信息。CP0有很多个寄存器用来配置或者记录，我们只需要实现其中的几个，如下所示：</p><table><thead><tr class="header"><th style="text-align: left;">寄存器</th><th style="text-align: left;">编号</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">SR</td><td style="text-align: left;">12</td><td style="text-align: left;">配置异常的功能。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">13</td><td style="text-align: left;">记录异常发生的原因和情况。</td></tr><tr class="odd"><td style="text-align: left;">EPC</td><td style="text-align: left;">14</td><td style="text-align: left;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><p>每个寄存器都是 32 位的，我们只需要其中的几位，列表如下：</p><table><thead><tr class="header"><th style="text-align: left;">寄存器</th><th style="text-align: left;">功能域</th><th style="text-align: left;">位域</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">IM（Interrupt Mask）</td><td style="text-align: left;">15:10</td><td style="text-align: left;">分别对应六个外部中断，相应位置 1表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过<code>mtc0</code>这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr class="even"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">EXL（Exception Level）</td><td style="text-align: left;">1</td><tdstyle="text-align: left;">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr class="odd"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">IE（Interrupt Enable）</td><td style="text-align: left;">0</td><td style="text-align: left;">全局中断使能，该位置 1 表示允许中断，置 0表示禁止中断。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">BD（Branch Delay）</td><td style="text-align: left;">31</td><td style="text-align: left;">当该位置 1 的时候，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr class="odd"><td style="text-align: left;">Cause</td><td style="text-align: left;">IP（Interrupt Pending）</td><td style="text-align: left;">15:10</td><td style="text-align: left;">为 6 位待决的中断位，分别对应 6个外部中断，相应位置 1 表示有中断，置 0表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">ExcCode</td><td style="text-align: left;">6:2</td><td style="text-align: left;">异常编码，记录当前发生的是什么异常。</td></tr><tr class="odd"><td style="text-align: left;">EPC</td><td style="text-align: left;">-</td><td style="text-align: left;">-</td><td style="text-align: left;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><p>当发生异常的时候，CPU 会自动将异常信息写入 CP0 的相应寄存器（如<code>Cause</code> 和<code>EPC</code>）。异常处理程序会访问相应寄存器，来了解异常的信息以进行异常处理。</p><p>同学们可以按规范自行设计 CP0，一个参考的 CP0 的端口声明如下：</p><table><thead><tr class="header"><th style="text-align: left;">端口</th><th style="text-align: left;">方向</th><th style="text-align: left;">位数</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">clk</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">时钟信号。</td></tr><tr class="even"><td style="text-align: left;">reset</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">复位信号。</td></tr><tr class="odd"><td style="text-align: left;">en</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">写使能信号。</td></tr><tr class="even"><td style="text-align: left;">CP0Add</td><td style="text-align: left;">IN</td><td style="text-align: left;">5</td><td style="text-align: left;">寄存器地址。</td></tr><tr class="odd"><td style="text-align: left;">CP0In</td><td style="text-align: left;">IN</td><td style="text-align: left;">32</td><td style="text-align: left;">CP0 写入数据。</td></tr><tr class="even"><td style="text-align: left;">CP0Out</td><td style="text-align: left;">OUT</td><td style="text-align: left;">32</td><td style="text-align: left;">CP0 读出数据。</td></tr><tr class="odd"><td style="text-align: left;">VPC</td><td style="text-align: left;">IN</td><td style="text-align: left;">32</td><td style="text-align: left;">受害 PC。</td></tr><tr class="even"><td style="text-align: left;">BDIn</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">是否是延迟槽指令。</td></tr><tr class="odd"><td style="text-align: left;">ExcCodeIn</td><td style="text-align: left;">IN</td><td style="text-align: left;">5</td><td style="text-align: left;">记录异常类型。</td></tr><tr class="even"><td style="text-align: left;">HWInt</td><td style="text-align: left;">IN</td><td style="text-align: left;">6</td><td style="text-align: left;">输入中断信号。</td></tr><tr class="odd"><td style="text-align: left;">EXLClr</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">用来复位 EXL。</td></tr><tr class="even"><td style="text-align: left;">EPCOut</td><td style="text-align: left;">OUT</td><td style="text-align: left;">32</td><td style="text-align: left;">EPC 的值。</td></tr><tr class="odd"><td style="text-align: left;">Req</td><td style="text-align: left;">OUT</td><td style="text-align: left;">1</td><td style="text-align: left;">进入处理程序请求。</td></tr></tbody></table><h2 id="异常码">异常码</h2><p>在异常处理程序中，我们需要通过访问 <code>Cause</code> 寄存器的<code>ExcCode</code> 域来获得异常的原因，在 P7中我们需要实现的异常有这样几种（除此之外，比较常见的还有陷入，断点调试等）：</p><p><strong>ExcCode的编码必须遵守规范，不然在评测的时候可能会出现问题</strong>。</p><table><thead><tr class="header"><th style="text-align: left;">异常与中断码</th><th style="text-align: left;">助记符与名称</th><th style="text-align: left;">指令与指令类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;"><code>Int</code> （外部中断）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">中断请求，来源于计时器与外部中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;"><code>AdEL</code> （取指异常）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">PC 地址未字对齐。</td></tr><tr class="odd"><td style="text-align: left;">PC 地址超过<code>0x3000 ~ 0x6ffc</code>。</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>AdEL</code> （取数异常）</td><td style="text-align: left;"><code>lw</code></td><td style="text-align: left;">取数地址未与 4 字节对齐。</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>lh</code></td><td style="text-align: left;">取数地址未与 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>lh</code>, <code>lb</code></td><td style="text-align: left;">取 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">计算地址时加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">取数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;"><code>AdES</code> （存数异常）</td><td style="text-align: left;"><code>sw</code></td><td style="text-align: left;">存数地址未 4 字节对齐。</td></tr><tr class="even"><td style="text-align: left;"><code>sh</code></td><td style="text-align: left;">存数地址未 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>sh</code>, <code>sb</code></td><td style="text-align: left;">存 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">计算地址加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">向计时器的 Count 寄存器存值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">存数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">8</td><td style="text-align: left;"><code>Syscall</code> （系统调用）</td><td style="text-align: left;"><code>syscall</code></td><td style="text-align: left;">系统调用。</td></tr><tr class="even"><td style="text-align: left;">10</td><td style="text-align: left;"><code>RI</code>（未知指令）</td><td style="text-align: left;">-</td><td style="text-align: left;">未知的指令码。</td></tr><tr class="odd"><td style="text-align: left;">12</td><td style="text-align: left;"><code>Ov</code>（溢出异常）</td><td style="text-align: left;"><code>add</code>, <code>addi</code>,<code>sub</code></td><td style="text-align: left;">算术溢出。</td></tr></tbody></table><h2 id="参考资料">参考资料</h2><p>CP0 设计及其相关指令的实现，以及硬软件在中断处理上的协同是 P7中最有挑战性的部分。仅阅读教程中的简要介绍远远不够，因此课程组放出一些推荐阅读的资料，希望同学能加以研究，尝试去理解其中的思路。</p><p>推荐资料列表：</p><ol type="1"><li><ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/L13-MIPS系统结构-V1.pdf">L13-MIPS系统结构-V1.pdf</a></li><li><ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/See_MIPS_Run_Linux.pdf">《SeeMIPS Run Linux》中相关章节</a></li><li>《计算机组成与设计：硬件/软件接口》中相关章节</li><li>Google / Bing 等搜索引擎</li><li>讨论区 P7 答疑帖</li></ol><h1 id="封装成单周期-cpu">封装成单周期 CPU</h1><h2 id="宏观-pc">宏观 PC</h2><p>我们的需求是要让我们的 CPU 从外部看上去是一个单周期的CPU（具体的原因在前一章有阐述）。但是实际上，我们的 CPU是一个五级流水的并行 CPU。所以本质上我们要实现一套机制，来让我们的 CPU满足这个需求。</p><p>为了检验同学们的实现效果，我们引入宏观 PC 这一概念。宏观 PC 表示整个CPU“宏观”运行指令所对应的PC地址。所谓“宏观”指令，表示该指令之前的所有指令序列对CPU 的更新已完成，该指令及其之后的指令序列对 CPU的更新未完成。具体实现上，宏观 PC 通常上是以某一个流水级 PC作为界限，作为输出端口输出出来。这个流水级一般是你 CP0所在的流水级。</p><h2 id="精确异常">精确异常</h2><p>对于异常，我们能明确指出是哪条指令导致了异常，并称这条指令为<strong>异常受害指令</strong>。精确异常的特性是，在异常受害指令<strong>前面的所有指令都执行完毕</strong>，而<strong>受害指令及其后续指令都像从来没有开始</strong>（准确说是当异常处理结束后重新执行这些指令，与未发生异常时执行这些指令的效果一样）。这样的处理思路使得从使用者的角度来看，CPU 执行异常处理是顺序执行的，从而隐藏了流水线设计的细节。</p><h3 id="清空流水线">清空流水线</h3><p>为了达到精确异常的效果，我们需要在异常发生的时候清空流水线，以避免宏观PC 之后的指令被执行。清空流水线一方面是要清空宏观 PC之后的指令所在的流水线寄存器，即插入 <code>nop</code>。</p><p>在了解了这点以后，我们可以总结一下我们对于流水线寄存器的控制。流水线寄存器需要接受多种控制信号，如复位信号，阻塞信号，刷新信号，请求信号。所以有可能同时会有多个信号控制同一个寄存器，那么寄存器该展现怎样的行为呢？这是一个需要考虑的事情。</p><p>例如在 D 级处于被阻塞状态时发生 <code>Req</code>，那么 D级流水线寄存器就应该立刻被清空，而不是保持原值；正在 <code>Req</code>的时候发生<code>reset</code>，那么 CPU应该立刻复位，而不是进行异常处理。此处处理不当可能造成评测时缺少中断的情况。实现上，可按如下优先级：</p><table><thead><tr class="header"><th style="text-align: left;">信号</th><th style="text-align: left;">优先级</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">reset</td><td style="text-align: left;">最高，复位大于一切。</td></tr><tr class="even"><td style="text-align: left;">Req</td><td style="text-align: left;">次高，中断请求比内部阻塞重要。</td></tr><tr class="odd"><td style="text-align: left;">flush / stall</td><td style="text-align: left;">最低，流水线信号，外部人员看不到。</td></tr></tbody></table><p>接下来我们考虑，哪些寄存器中的位段需要优先级。只有两个，一个是 PC寄存器，原因之前论述过了；另一个是 CP0 <code>Cause</code> 寄存器的<code>BD</code> 位。它在 flush的时候需要保持原来的信息，因为在外部去看的话，会发现宏观 PC是相同的，但是延迟槽标记是不同的，这显然是不正确的。如果在延迟槽指令被阻塞时产生中断，并且<code>nop</code> 没有流水延迟槽标记，那么 <code>EPC</code>就会被设置错误的值，无法通过评测。</p><p>清空流水线的另一个方面就是避免异常受害指令和其之后的指令产生影响（比如写寄存器，写DM），这一点将在下一小节“确定 CP0 的位置”中讨论。</p><h3 id="确定-cp0-的位置">确定 CP0 的位置</h3><p>CP0 需要放置在某个具体的流水级上，我们认为宏观 PC 所在的流水级就是CP0 的流水级。为了满足宏观 PC 的性质，CP0所处的位置不能够太靠前，比如设置在 F级，那么异常会发生在之后的流水级，那么就检测不到这个异常了（如果宏观 PC就是异常受害指令的话）。但是也不能太靠后，比如在 W级，因为我们需要清除受害指令之后的指令造成的影响，但是此时<code>store</code> 类指令已经修改了外设，清除影响较为困难。</p><p>因此，请根据所学挑选你的 CP0在流水线上的位置，需要强调，没有标准答案或者最优答案。</p><h3 id="流水异常码">流水异常码</h3><p>异常信号 ExcCode 应该流水到 CP0 所在的流水级，而不能直接提交到CP0。</p><p>这是因为 CPU 实际上是并行的，直接提交到 CP0可能会导致后面的指令发生异常的时间比前面指令发生异常的时间要早。例如<code>sw</code> 后接 <code>j</code> 指令。如果这两个都是异常指令，那么<code>j</code> 在 D 级产生异常，<code>sw</code> 在 M级产生异常（假设这个异常是超范围了）时不流水，就将先处理 <code>j</code>异常，显然不符合我们的要求，因为 <code>sw</code>异常被忽略了（<code>sw</code>继续往后流，前面的流水级开始流异常处理程序，等异常返回之后，就会直接到跳转目标指令了，<code>sw</code>的异常没有得到处理）。我们将异常信号流水以后，就可以先处理<code>sw</code> 异常，然后运行到 <code>j</code>，再处理 <code>j</code>异常。</p><h3 id="写入-epc">写入 EPC</h3><p>发生异常的一个重要行为是将中断指令的 PC 写入EPC，就像函数跳转之前，要将返回地址写入<code>$ra</code>。更严谨的说，对于异常情况只要考虑异常指令是不是延迟槽指令，如果是延迟槽指令，那么存的是异常指令的PC - 4，如果不是，那么就存异常指令的 PC。</p><p>这样造成的结果就是，返回的时候将重新执行异常指令（如果异常处理程序不对EPC 进行修改的话）。这里的 PC 指的都是宏观 PC。</p><p>思考题</p><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>思考题</p><p>为什么 <code>jalr</code> 指令的两个寄存器不能相同，例如<code>jalr $31, $31</code>？</p><h1 id="异常处理程序">异常处理程序</h1><h2 id="eret-没有延迟槽">eret 没有延迟槽</h2><p><code>eret</code> 承担了跳转功能，但是 <code>eret</code>是没有延迟槽的。也就是说测试数据中可能出现 <code>eret</code>指令后紧跟另一条非 <code>nop</code> 指令的情况。你的设计应该保证<code>eret</code> 的后续指令不被执行。</p><h2 id="异常处理程序的结构">异常处理程序的结构</h2><p>异常处理程序是由软件实现的，我们只需要提供接口而无需自己实现。同时，了解异常处理程序是十分有必要的。</p><p>异常和中断处理流程可以概括成如下步骤（需要强调的是，这些步骤只是为了让同学们更好的理解处理程序的结构，我们在实际测评中并不保证下述的步骤都执行，也不保证不包含在下述步骤里的结构不出现）：</p><ul><li>Step 1：构造异常处理环境，保存现场。</li><li>Step 2：读取 <code>Cause</code> 和 <code>EPC</code>寄存器，判断错误类型。</li><li>Step 3：根据异常类型和其他属性执行对应处理。</li><li>Step 4：恢复现场。</li><li>Step 5：使用 <code>eret</code> 指令从异常处理返回。</li></ul><p>下面列出了一个简要的发生算数溢出时的程序，同学们可以结合源码进行参考和理解。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 程序首先从这里运行</span><br><span class="hljs-meta">.text</span><br>    <span class="hljs-comment"># 只允许外部中断</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1001</span><br>    <span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">12</span><br><br>    <span class="hljs-comment"># 算术溢出</span><br>    <span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t0</span>, <span class="hljs-number">0x7fff</span><br>    <span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0x7fff</span><br>    <span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br>    <span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>, $<span class="hljs-number">0</span>, end<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-symbol">_entry:</span><br>    <span class="hljs-comment"># 保存上下文</span><br>    <span class="hljs-keyword">j </span>_save_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_main_handler:</span><br>    <span class="hljs-comment"># 取出 ExcCode</span><br>    <span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">13</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x7c</span><br>    <span class="hljs-keyword">and </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k1</span><br><br>    <span class="hljs-comment"># 如果是中断，直接恢复上下文</span><br>    <span class="hljs-keyword">beq </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">0</span>, _restore_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br>    <span class="hljs-comment"># 将 EPC + 4，即处理异常的方法就是跳过当前指令</span><br>    <span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">14</span><br>    <span class="hljs-keyword">addu </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">14</span><br>    <span class="hljs-keyword">j </span>_restore_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_exception_return:</span><br>    <span class="hljs-keyword">eret</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_save_context:</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>     <span class="hljs-comment"># 在栈上找一块空间保存现场</span><br>    <span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, -<span class="hljs-number">256</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">sp</span>, <span class="hljs-number">116</span>($<span class="hljs-built_in">k0</span>)        <span class="hljs-comment"># 最先保存栈指针</span><br>    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">k0</span><br><br>    <span class="hljs-comment"># 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">1</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">31</span>, <span class="hljs-number">124</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">k0</span><br>    <span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">k1</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">k0</span>, <span class="hljs-number">128</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">k1</span>, <span class="hljs-number">132</span>($<span class="hljs-built_in">sp</span>)<br><br>    <span class="hljs-keyword">j </span>_main_handler<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_restore_context:</span><br>    <span class="hljs-comment"># 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">1</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">2</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">31</span>, <span class="hljs-number">124</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">k0</span>, <span class="hljs-number">128</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">k1</span>, <span class="hljs-number">132</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">mthi </span>$<span class="hljs-built_in">k0</span><br>    <span class="hljs-keyword">mtlo </span>$<span class="hljs-built_in">k1</span><br><br>    <span class="hljs-comment"># 最后恢复栈指针</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">sp</span>, <span class="hljs-number">116</span>($<span class="hljs-built_in">sp</span>)<br><br>    <span class="hljs-keyword">j </span>_exception_return<br>    <span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="利用-mars-验证异常处理框架">利用 MARS 验证异常处理框架</h2><p>尽管在 MARS中，我们只能针对内部异常进行模拟，无法模拟外部中断。但由我们对内部异常与外部中断的了解可以知道，两者的处理是类似的。因此我们可以在MARS中先验证中断/异常处理的框架是否正确（我们可以构造一条产生异常的指令，如溢出，再观察MARS 能否进入 ExceptionHandler），至于我们如何处理这个错误，则是次要问题。</p><h1 id="p7-提交要求">P7 提交要求</h1><h2 id="整体要求">整体要求</h2><ul><li>MIPS 处理器须为流水线设计，MIPS 微系统须支持中断和异常。</li><li>除本文明确的规范和补充声明外，MIPS 微系统设计以《See MIPS RunLinux》（下文简称《SMRL》）作为标准。《SMRL》的标准与 MARS的行为存在一定差异，在测试时不以 MARS 为准。</li><li>P7 较前几个 Project 为同学预留了更多需自主设计的内容，最终 P7的实现因人而异。只要满足所给出的设计约束、行为规范和 MIPS基本设计规范，任何设计都被认为是正确的。</li><li><strong>此章节主要包含实现细节与评测要求，一些基本概念或定义请结合前面的教程理解。</strong></li></ul><h2 id="顶层模块接口">顶层模块接口</h2><ul><li><p>MIPS 微系统接口（请顶层模块严格满足该要求）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,                    <span class="hljs-comment">// 时钟信号</span><br>    <span class="hljs-keyword">input</span> reset,                  <span class="hljs-comment">// 同步复位信号</span><br>    <span class="hljs-keyword">input</span> interrupt,              <span class="hljs-comment">// 外部中断信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] macroscopic_pc, <span class="hljs-comment">// 宏观 PC</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_addr,    <span class="hljs-comment">// IM 读取地址（取指 PC）</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_rdata,   <span class="hljs-comment">// IM 读取数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,    <span class="hljs-comment">// DM 读写地址</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,   <span class="hljs-comment">// DM 读取数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,   <span class="hljs-comment">// DM 待写入数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_data_byteen,  <span class="hljs-comment">// DM 字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_int_addr,     <span class="hljs-comment">// 中断发生器待写入地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_int_byteen,   <span class="hljs-comment">// 中断发生器字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_inst_addr,    <span class="hljs-comment">// M 级 PC</span><br><br>    <span class="hljs-keyword">output</span> w_grf_we,              <span class="hljs-comment">// GRF 写使能信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span> :<span class="hljs-number">0</span>] w_grf_addr,     <span class="hljs-comment">// GRF 待写入寄存器编号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_grf_wdata,    <span class="hljs-comment">// GRF 待写入数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_inst_addr     <span class="hljs-comment">// W 级 PC</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>相较于 P6 的顶层模块新增了以下 4 个接口：</p><ul><li><code>interrupt</code>：外部中断信号。由中断发生器产生，每次中断信号会持续到处理器响应该信号。请注意，处理该中断信号的方式应和处理Timer 产生的中断不完全相同，具体见前面的教程。</li><li><code>macroscopic_pc[31:0]</code>：详细概念见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#pc">宏观PC</a>。我们保证评测过程中宏观 PC仅用于定位指令，作为产生外部中断信号的条件。</li><li><code>m_int_addr[31:0]</code>：中断发生器待写入地址。当该信号命中中断发生器响应地址，且字节使能信号有效时，视为响应外部中断。</li><li><code>m_int_byteen[3:0]</code>：中断发生器字节使能信号，当该信号任意一位置位时视为有效。</li></ul></li></ul><h2 id="硬件约束">硬件约束</h2><ul><li>顶层模块中应该至少包含 CPU、Bridge、Timer0、Timer1四个功能部件。</li><li>地址空间：见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-2/#_4">系统桥</a>。</li><li>主要部件：<ul><li>CPU：在 P6 基础上进行增量开发，增加 CP0协处理器，支持异常和中断等。</li><li>CP0：见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-6/#cp0">CP0约束</a>。</li><li>Bridge：须作为独立的 module，不包括在 CPU中；访问外设均须通过系统桥。</li><li>IM：容量为 <strong>16KiB</strong>（<strong>4096</strong> ×32bit）。</li><li>DM：容量为 <strong>12KiB</strong>（<strong>3072</strong> ×32bit）。</li><li>Timer：定时器官方源代码已经给出，无需自行设计实现。</li><li>中断发生器：<ul><li>中断信号依据宏观 PC产生，依据相应的待写入地址和字节使能信号关闭，具体实现参考下发的tb。</li><li>由于其内部并没有真正的存储单元，我们规定读出的数据始终保持0，且写入时除了响应中断外不会产生其他影响。</li></ul></li></ul></li></ul><h2 id="cp0-约束">CP0 约束</h2><ul><li>协处理器位置：不作明确要求，自行设计。</li><li>输出要求：写入时无需 display。</li><li>为了支持异常和中断，必须实现的寄存器包括：<strong>SR、CAUSE、EPC</strong>。</li><li>寄存器规范：<ul><li>CP0 寄存器的初始值均为 0，未实现位始终保持 0。</li><li>当进入中断或异常状态时，均需要将 EXL 置为1，用以屏蔽中断信号（注意《SMRL》中并没有指定进入中断时 EXL的值）；当退出中断或异常状态时，也均需要将 EXL 置为0，取消屏蔽中断信号。</li><li>Cause 寄存器的 IP 域每周期写入 HWint 对应位的值。</li><li>当进入中断或异常状态时，需要将受害指令的 PC 写入 EPC。</li></ul></li></ul><h2 id="指令约束">指令约束</h2><ul><li><p>处理器应支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">nop, </span><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr,</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mfc0, </span><span class="hljs-keyword">mtc0, </span><span class="hljs-keyword">eret, </span><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure></li><li><p>在 P6 基础上新增了 <code>mfc0, mtc0, eret, syscall</code>四条新指令。</p></li><li><p><code>eret</code> 具有跳转的功能但是没有延迟槽，你的设计应该保证<code>eret</code> 的后续指令不被执行。</p></li><li><p><code>syscall</code> 指令行为与 MARS不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态。</p></li></ul><h2 id="中断异常约束">中断异常约束</h2><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#_1">精确异常</a>的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code>同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><table><thead><tr class="header"><th style="text-align: left;">ExcCode</th><th style="text-align: left;">助记符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;">Int</td><td style="text-align: left;">中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;">AdEL</td><td style="text-align: left;">取数或取指时地址错误。</td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;">AdES</td><td style="text-align: left;">存数时地址错误。</td></tr><tr class="even"><td style="text-align: left;">8</td><td style="text-align: left;">Syscall</td><td style="text-align: left;">系统调用。</td></tr><tr class="odd"><td style="text-align: left;">10</td><td style="text-align: left;">RI</td><td style="text-align: left;">不认识的（或者非法的）指令码。</td></tr><tr class="even"><td style="text-align: left;">12</td><td style="text-align: left;">Ov</td><td style="text-align: left;">自陷形式的整数算术指令（例如<code>add</code>）导致的溢出。</td></tr></tbody></table></li><li><p>补充说明：</p><ul><li>分支跳转指令无论跳转与否，延迟槽指令为受害指令时 <code>BD</code>均需要置位。</li><li>发生取指异常或 <code>RI</code> 异常后视为 <code>nop</code>直至提交到 CP0。</li><li>跳转到不对齐的地址时，受害指令是 PC 值不正确的指令（即需要向 EPC写入不对齐的地址）。</li><li>对于未知指令的判断仅需考虑 opcode（和 R 型指令的funct），且仅需判断是否出现在 P7要求的指令集中，同时保证未知指令的测试用例中 opcode 和 funct码的组合一定没有在 MARS 的基本指令集中出现。</li></ul></li></ul><h2 id="官方测试说明">官方测试说明</h2><ul><li>为便于进行测试，我们允许从 0x417C 直接前进到 0x4180，此种情况下 CPU行为与 P6 一致，不应有中断响应等其他行为。</li><li>测试数据规范：<ul><li>测试时不会出现跳转到未加载指令的位置的情况。</li><li><code>eret</code> 只会出现在中断处理程序中，后可能紧跟另一条非<code>nop</code> 的指令。</li><li>测试程序保证不会写入 Cause，但可能写入 SR 和 EPC。</li><li>测试程序只会通过指令 <code>sb $0, 0x7f20($0)</code>访问中断发生器（响应中断），且只会在中断处理程序中访问。</li><li>中断处理程序会对寄存器和内存进行读写来验证 CPU 的正确性。</li><li>中断处理程序执行过程中保证不出现异常，且不会产生中断。</li></ul></li><li>官方 tb 示例：<ul><li>外设不给予中断时，使用的 tb 为：<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/tb_norm_demo.v">下载链接</a>。</li><li>评测机通过检测同学们的宏观 PC 给予中断信号并对中断进行测试，例如此<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/tb_interrupt_demo.v">下载链接</a>中的tb 会在处理器的宏观 PC 第一次到达 0x3010 时给予 CPU 一个中断信号。</li></ul></li></ul><h2 id="官方-mars">官方 Mars</h2><ul><li>课程组修改了 Mars，增加了输出运行信息等功能，支持课程 P7要求的异常和定时器中断，供同学们本地测试，<ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/Mars_p7.zip">下载链接</a>。</li></ul><h1 id="思考题汇总">思考题汇总</h1><p>思考题</p><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU处理中断异常必须是已经指定好的地址？如果你的 CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成<code>jalr $31, $31</code>？</p><p>思考题</p><p>1、[P7 选做] 请详细描述你的测试方案及测试数据构造策略。</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组理论</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h3 id="考题">考题</h3><p>10*单选</p><p>简答：逻辑函数化简、内存扩展（译码器生成片选信号、二维地址结构）、页式存储、cache命中率、mips汇编</p><h4 id="概述">概述</h4><p>进制转换</p><h4 id="组合逻辑">组合逻辑</h4><p>逻辑函数化简：吸收律、配项法……</p><p>多路选择器：74151、函数生成器</p><h4 id="时序逻辑">时序逻辑</h4><p>有限状态机：moore、mealy型，状态转换图、表、函数表达式（考试说明再化简）</p><h4 id="主存">主存</h4><p>二维地址结构、译码器生成片选信号</p><h4 id="汇编">汇编</h4><p>指令格式：操作码结构、指令长度（定长快、变长小）</p><p>各种指令：R、I、J</p><p>寻址方式</p><h4 id="mips流水线">mips流水线</h4><p>基本概念</p><p>数据冒险</p><h4 id="cache">cache</h4><p>直接映射：区地址（tag）+区内快递至</p><p>命中率（能否替换）</p><h4 id="中断">中断</h4><p>DMA、中断</p><h4 id="浮点数">浮点数</h4><p>以单精度浮点数为例，浮点数共由以下3部分组成</p><ul><li>1位数符S：0表示正数，1为负数</li><li>8位阶E（双精度为11位）：偏移量为 <spanclass="math inline">\(2^{n-1}-1\)</span></li><li>23位尾数m（双精度为52位）：规格化成小数点左侧为1，且1作为隐含位被忽略，即1.m</li></ul><p><spanclass="math inline">\((178.125)_{10}=(10110010.001)_2=1.0110010001\times2^{111}\)</span>：S=0，E=00000111+01111111=10000110，m=01100100010000000000000</p><p>单精度浮点数的表示约定：</p><table><thead><tr class="header"><th style="text-align: center;">E</th><th style="text-align: center;">M</th><th style="text-align: center;">浮点数N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1-254</td><td style="text-align: center;">不为0</td><td style="text-align: center;">规范浮点数 <spanclass="math inline">\(N=(-1)^s\times1.m\times2^{E-127}\)</span></td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">不为0</td><td style="text-align: center;">非规范浮点数 <spanclass="math inline">\(N=(-1)^s\times0.m\times2^{-126}\)</span></td></tr><tr class="even"><td style="text-align: center;">255</td><td style="text-align: center;">0</td><td style="text-align: center;">无穷（有正负）</td></tr><tr class="odd"><td style="text-align: center;">255</td><td style="text-align: center;">不为0</td><td style="text-align: center;">NaN（不是一个数）</td></tr></tbody></table><h2 id="组合逻辑-1">组合逻辑</h2><h3 id="基础知识">基础知识</h3><h4 id="晶体管类器件">晶体管类器件</h4><p>P(positive)型半导体掺三价元素，导电以空穴为主；N(negtive)型半导体掺五价元素，导电以电子为主。</p><p>PN结（晶体二极管）P极接正极为正向偏置，导通；反之为反向偏置，截止</p><p>三极管</p><p>集电极C，N型；基极B，P型；发射极E，N型</p><figure><img src="/img/image-20231214213736360.png"alt="image-20231214213736360" /><figcaption aria-hidden="true">image-20231214213736360</figcaption></figure><figure><img src="/img/image-20231216214649868.png"alt="image-20231216214649868" /><figcaption aria-hidden="true">image-20231216214649868</figcaption></figure><p>TTL与非门的两个状态通常称为关态和开态，当输入全为高电平时对应的是关态，此时输出为高电平；当输入有一为低电平时，对应的是开态，此时输出为低电平。</p><h4 id="逻辑电路的符号表示">逻辑电路的符号表示</h4><figure><img src="/img/image-20231210151341113.png"alt="image-20231210151341113" /><figcaption aria-hidden="true">image-20231210151341113</figcaption></figure><h4 id="组合逻辑电路">组合逻辑电路</h4><ol type="1"><li>从结构看，组合逻辑电路由门电路构成，不含<strong>存储电路</strong>，也不含<strong>反馈电路</strong>，信号从输入开始单向传输到输出。对于组合逻辑电路，任何时刻电路的输出仅由当时的<strong>输入信号</strong>决定。</li><li>将加在电路若干输入端中的某一个输入端的信号变换成相应的一组二进制代码输出的过程叫做<strong>编码</strong></li><li>将二进制代码所表示的信息翻译成对应输出的高低电平信号的过程称为译码；n位二进制译码器有n个输入，有2^n个输出，工作时译码器只允许有一个输出有效。</li></ol><h3 id="理论运算">理论运算</h3><h5 id="符号">符号</h5><p>与：<span class="math inline">\(\cdot\)</span> 或 <spanclass="math inline">\(\land\)</span></p><p>或：<span class="math inline">\(+\)</span> 或 <spanclass="math inline">\(\lor\)</span></p><p>非：<span class="math inline">\(\overline{}\)</span> 或 <spanclass="math inline">\(\neg\)</span></p><p>异或：<span class="math inline">\(\oplus\)</span></p><p>同或：<span class="math inline">\(\odot\)</span></p><p>优先级：括号、非、与、异或、或 <spanclass="math inline">\(()&gt;\neg&gt;\cdot&gt;\oplus&gt;+\)</span></p><h5 id="运算律">运算律</h5><p>交换律、结合律、0-1律（与0做运算）、互补律</p><p>重叠率、吸收律、还原律</p><p>吸收律</p><p><span class="math inline">\(A+\bar{A}B=A+B\)</span></p><p>分配律</p><p><span class="math inline">\(A\cdot(B+C)=A\cdot B+A\cdotC\)</span></p><p><span class="math inline">\(A+B\cdot C=(A+B)\cdot(A+C)\)</span></p><p>反演律（德摩根律）</p><p><spanclass="math inline">\(\overline{A+B}=\overline{A}\cdot\overline{B}\)</span></p><p><span class="math inline">\(\overline{A\cdotB}=\overline{A}+\overline{B}\)</span></p><p>包含律</p><p><span class="math inline">\(A\cdot B+\overline{A}\cdot B+B\cdotC=A\cdot B+\overline{A}\cdot B\)</span></p><p><spanclass="math inline">\((A+B)\cdot(\overline{A}+C)\cdot(B+C)=(A+B)\cdot(\overline{A}+C)\)</span></p><h5 id="规则">规则</h5><p>代入规则、反演规则、对偶规则</p><h5 id="逻辑函数的标准表达式">逻辑函数的标准表达式</h5><h6 id="最小项">最小项</h6><ul><li><p>最小项：由n个变量组成的 “与”项中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个与项称为最小项。n个变量有<span class="math inline">\(2^n\)</span> 个最小项</p></li><li><p>最小项编号：按照变量顺序将最小项中的原变量用1表示、反变量用0表示，得到一个二进制数，与其对应的十进制数，即该最小项的编号i</p></li><li><p>性质：</p></li></ul><ol type="1"><li><p>对于任何一个最小项，只有对应的一组变量取值，使其值为1，其余情况下均为0</p></li><li><p>全体最小项之和为1</p></li><li><p>任意两个最小项的乘积为0</p></li><li><p>相邻最小项：除一个变量互为相反外，其余变量都分别相同的两个最小项。</p><p>具有相邻性的两个最小项之和，可以合并为一个乘积项，消去一个以原变量和反变量形式出现的变量，保留由没有变化的变量构成的乘积项。</p><p>例：<spanclass="math inline">\(\bar{A}\bar{B}\bar{C}+\bar{A}\bar{B}C=\bar{A}\bar{B}\)</span></p></li></ol><ul><li>最小项推导法（从真值表推出表达式）：把输出为1的输入组合写成乘积项的形式，其中取值为1 的输入用原变量表示，取值为 0的输入用反变量表示，然后把这些乘积项加起来</li></ul><p><spanclass="math inline">\(F=\bar{A}BC+A\bar{B}C+AB\bar{C}+ABC\)</span></p><p><span class="math inline">\(F(A,B,C)=m_3+m_5+m_6+m_7\)</span></p><p><span class="math inline">\(F(A,B,C)=\sum m(3,5,6,7)\)</span></p><h6 id="最大项">最大项</h6><ul><li><p>最大项：设有n个变量，它们所组成的具有n个变量的“或”项（和项）中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个和项称为最大项。n个变量有2n个最大项</p></li><li><p>最大项编号：按照变量顺序将最大项中的原变量用0表示、反变量用1表示，得到一个二进制数，与其对应的十进制数即该最大项的编号i</p></li><li><p>性质：</p><ol type="1"><li><p>对于任何一个最大项，只有对应的一组变量取值，使其值为0，其余情况下均为1</p></li><li><p>全体最大项之积为0</p></li><li><p>任意两个最大项之和为1</p></li><li><p>相邻最大项：若2个最大项中只有1个变量分别以原变量和反变量的形式出现，其余的变量分别相同，则称这2个变量具有相邻性，或相邻最大项。具有相邻性的两个最大项之积可以合并为一个和项，消去一个以原变量和反变量形式出现的变量，保留由没有变化的变量构成的和项。</p><p>例：<spanclass="math inline">\((\bar{A}+B+\bar{C})(A+B+\bar{C})=[\bar{A}+(B+\bar{C})][A+(B+\bar{C})]=B+\bar{C}\)</span></p></li></ol></li><li><p>1</p></li></ul><h6 id="化简">化简</h6><p>一般由EDA工具完成</p><p>“与或”表达式化简：</p><ol type="1"><li><p>乘积项最少（与门最少）</p></li><li><p>乘积中变量最少</p></li><li><p>用最少的门、门的输入也最少</p></li></ol><p>方法：</p><ol type="1"><li><p>合并乘积项（互补律）</p></li><li><p>吸收项法（吸收律、包含律）</p></li><li><p>配项法（利用互补律）</p></li></ol><p><strong>卡诺图化简</strong></p><h3 id="常见器件">常见器件</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">输入</th><th style="text-align: center;">输出</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">7485四位比较器</td><td style="text-align: center;">A3-A0,B3-B0,I0-I2</td><td style="text-align: center;">F&gt;,F&lt;,F=</td><td style="text-align: center;">比较4位二进制数的大小</td></tr><tr class="even"><td style="text-align: center;">8线-3线编码器</td><td style="text-align: center;">Y0,Y1...Y7</td><td style="text-align: center;">C,B,A</td><td style="text-align: center;">用3位二进制代码对8个信号进行编码</td></tr><tr class="odd"><td style="text-align: center;">8421BCD编码器</td><td style="text-align: center;">Y0,Y1...Y9</td><td style="text-align: center;">D,C,B,A</td><tdstyle="text-align: center;">用4位二进制代码对10个十进制数字进行编码</td></tr><tr class="even"><td style="text-align: center;">74LS148优先编码器</td><td style="text-align: center;">低电平有效</td><td style="text-align: center;">反码</td><td style="text-align: center;">同8-3，优先编码7</td></tr><tr class="odd"><td style="text-align: center;">74LS147优先编码器</td><td style="text-align: center;">低电平有效</td><td style="text-align: center;">反码</td><td style="text-align: center;">同8421，优先编码9</td></tr><tr class="even"><td style="text-align: center;">3线-8线译码器(74138)</td><td style="text-align: center;">A2,A1,A0,S2,S1,S0</td><td style="text-align: center;">Y7-Y0，低电平输出有效</td><td style="text-align: center;">S0,S1,S2为100时使能，3-8</td></tr><tr class="odd"><td style="text-align: center;">BCD译码器</td><td style="text-align: center;">DCBA</td><td style="text-align: center;">Y9-Y0，低电平输出有效</td><td style="text-align: center;">10-4</td></tr><tr class="even"><td style="text-align: center;">74151多选器</td><td style="text-align: center;">D7-D0,A2-A1,~en</td><td style="text-align: center;">Y,~Y</td><td style="text-align: center;">8选1数据选择器</td></tr></tbody></table><h2 id="时序逻辑-1">时序逻辑</h2><h3 id="基础知识-1">基础知识</h3><ol type="1"><li><p>时序逻辑电路由组合逻辑电路和存储电路两部分组成</p></li><li><p>时序逻辑电路按触发器时钟端的连接方式不同可以分为同步时序逻辑和异步时序逻辑两类。</p></li></ol><h3 id="锁存器">锁存器</h3><h6 id="基本rs锁存器">基本RS锁存器</h6><figure><img src="/img/image-20230925142055279.png"alt="image-20230925142055279" /><figcaption aria-hidden="true">image-20230925142055279</figcaption></figure><p>功能：</p><ol type="1"><li><p>保持原来状态： <spanclass="math inline">\(\overline{R_D}=1,\overline{S_D}=1\)</span></p></li><li><p>置0（次态变0）：<spanclass="math inline">\(\overline{R_D}=0,\overline{S_D}=1\)</span></p></li><li><p>置1：<spanclass="math inline">\(\overline{R_D}=1,\overline{S_D}=0\)</span></p></li></ol><p>约束条件：<spanclass="math inline">\(\overline{R_D}+\overline{S_D}=1\)</span></p><p>特性方程：<spanclass="math inline">\(Q^{n+1}=S_D+\overline{R_D}Q^n\)</span></p><h6 id="钟控rs锁存器">钟控RS锁存器</h6><figure><img src="/img/image-20230925142436000.png"alt="image-20230925142436000" /><figcaption aria-hidden="true">image-20230925142436000</figcaption></figure><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> 时，保持状态</p></li><li><p><span class="math inline">\(CP=1\)</span>时，具有RS锁存器的功能</p></li></ol><p>约束条件：<span class="math inline">\(S*R=0\)</span></p><p>特性方程：<spanclass="math inline">\(Q^{n+1}=S+\overline{R}Q^n\)</span></p><h6 id="钟控d锁存器">钟控D锁存器</h6><p><img src="/img/image-20230925143251215.png" alt="image-20230925143251215" style="zoom:50%;" /></p><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> ，保持</p></li><li><p><span class="math inline">\(CP=1\)</span> ，<spanclass="math inline">\(Q=D\)</span></p></li></ol><p>特性方程：<span class="math inline">\(Q^{n+1}=D\)</span></p><h6 id="d触发器">D触发器</h6><p><img src="/img/image-20230925143754522.png" alt="image-20230925143754522" style="zoom:50%;" /></p><p>功能：CP（clk）上升沿更新Q，Q=D</p><p>可带使能端、复位</p><p>多个D触发器可以组成寄存器</p><h6 id="jk触发器">JK触发器</h6><p><img src="/img/image-20230925144127337.png" alt="image-20230925144127337" style="zoom:50%;" /></p><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> ，保持</p></li><li><p><span class="math inline">\(CP=1\)</span> ，RS锁存器功能，且<span class="math inline">\(J=K=1\)</span> 时翻转</p></li></ol><p>特性方程：<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span></p><h6 id="t触发器">T触发器</h6><p>功能：</p><ol type="1"><li><p><span class="math inline">\(T=0\)</span> ，保持</p></li><li><p><span class="math inline">\(T=1\)</span> ，翻转</p></li></ol><p>特性方程：<span class="math inline">\(Q_{n+1}=T\oplusQ_n\)</span></p><h3 id="有限状态机">有限状态机</h3><h6 id="相关概念">相关概念</h6><p>概念：可描述有限个状态以及这些状态之间的转移及引起转移的动作等的离散数学模型。</p><p>次态逻辑：组合逻辑，根据当前状态和输入计算下一状态。</p><p>状态寄存器：在时钟沿到来之前，保持现态，并为输出逻辑和次态逻辑提供稳定输入；在时钟沿到来时，锁存次态逻辑输出的状态值。</p><p>输出逻辑：组合逻辑，根据现态形成输出信号。</p><p><img src="/img/image-20230925145703517.png" alt="image-20230925145703517" style="zoom: 50%;" /></p><p>分类：Moore型状态机：输出状态仅与当前状态有关</p><p>Mealy型状态机：输出信号与当前状态和输入信号有关</p><h6 id="建立方法">建立方法</h6><ol type="1"><li><p>确定输入、输出、状态</p></li><li><p>画出状态转换图，进而得到状态转换表、次态与输出逻辑表达式</p></li></ol><h6 id="时序问题">时序问题</h6><p><spanclass="math inline">\(T_c&gt;=T_{ctq}+T_{cd}+T_{setup}+时钟偏移\)</span></p><p><span class="math inline">\(T_c\)</span> ：时钟周期</p><p><span class="math inline">\(T_{ctq}\)</span>：稳定时间（clock-to-Q）：——从触发时钟边沿到输出稳定的时间</p><p><span class="math inline">\(T_{cd}\)</span>：组合逻辑电路最长时延</p><p><span class="math inline">\(T_{setup}\)</span>：建立时间——触发时钟沿之前，输入需稳定的时间</p><p><span class="math inline">\(T_{hold}\)</span>：保持时间：触发时钟沿之后，输入仍需稳定的时间</p><p>保持约束：<span class="math inline">\(T_{ctq}+T_{cd}\geqslantT_{hold}\)</span></p><h3 id="寄存器">寄存器</h3><p>数据寄存器：多个边沿触发器组成</p><p>数据锁存器：多位电位触发器组成</p><p>移位寄存器：</p><p>4位双向移位寄存器(CT74194)</p><figure><img src="/img/image-20231215222541935.png"alt="image-20231215222541935" /><figcaption aria-hidden="true">image-20231215222541935</figcaption></figure><p>同步计数器：所有触发器的时钟端并在一起</p><p>异步计数器：时钟脉冲只作用于最低位</p><h2 id="主存储器">主存储器</h2><h3 id="分类">分类</h3><p>RAM（随机访问存储器）、ROM（只读存储器）</p><p>RAM可分为SRAM（静态存储器，Cache）、DRAM（主存）</p><p>ROM可分为Flash（闪存，可擦写）、不可在线更改的等等</p><h3 id="描述">描述</h3><p>存取时间：读或写操作所用的时间</p><p>存取周期：两次访问存储单元的最小时间间隔</p><p>存储器带宽：单位时间访问的存储量</p><p>存储芯片容量=字单元数*字单元的位数，即 <spanclass="math inline">\(2^n\times m\)</span> 。其中 <spanclass="math inline">\(2^n\)</span>为字单元数量，n为地址线数量，m为数据线数量（字单元位数）</p><p>地址线=log2(字单元数)，（按字寻址）</p><p>数据线=字单元位数</p><h3 id="扩展">扩展</h3><p>位扩展：字单元位数不够</p><p>字扩展：字单元数不够</p><h3 id="dram刷新">DRAM刷新</h3><p>刷新间隔：同一行两次被刷新之间的时间</p><p>刷新周期：所有行被刷新一次的时间</p><p>集中式：间隔=刷新周期</p><p>分散式：间隔=刷新行数*存储周期</p><p>分布式（异步）：间隔=刷新周期</p><h2 id="mips汇编">MIPS汇编</h2><h3 id="指令格式">指令格式</h3><p>操作码+操作数（操作数地址，0123）</p><p>定长/变长</p><h3 id="寻址">寻址</h3><p>立即寻址：机器码中给出立即数</p><p>直接寻址：操作数在寄存器中，机器码里有寄存器编号</p><p>间接寻址：操作数在内存中，机器码里有存储着内存地址的寄存器的编号</p><p>基址寻址/变址寻址：间接寻址+立即数（<code>lw $s1,100($s2)</code>）</p><p>相对寻址：PC作为基址寄存器+立即数</p><p>堆栈寻址</p><h4 id="mips中的寻址">mips中的寻址</h4><p>立即寻址：ori中的立即数</p><p>寄存器寻址：add中操作数在寄存器里</p><p>基址寻址：lw，根据寄存器中的数据+偏移量得出内存地址，取数</p><p>PC相对寻址：beq</p><p>伪直接寻址：j</p><h3 id="一些指令">一些指令</h3><h4 id="跳转相关">跳转相关</h4><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">位数</th><th style="text-align: center;">跳转空间</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">beq</td><td style="text-align: center;">16位立即数+左移2</td><td style="text-align: center;">256K</td></tr><tr class="even"><td style="text-align: center;">j</td><td style="text-align: center;">26位立即数+左移2</td><td style="text-align: center;">256M</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">寄存器，32位</td><td style="text-align: center;">4G</td></tr></tbody></table><h4 id="罕见指令">罕见指令</h4><p>bgez：大于等于0跳转 bgtz：大于0跳转 blez：小于等于……bgeal：大于等于0，则跳转+写入ra</p><p>lbu：加载无符号数……lhu、lwu、sbu</p><p>sll：逻辑左移，5位立即数 sllv：寄存器代替立即数 srl：逻辑右移sra：算数右移……</p><p>slti：小于立即数置1 sltiu：小于无符号立即数置1</p><h2 id="流水线cpu">流水线CPU</h2><figure><img src="/img/image-20231231103906887.png"alt="image-20231231103906887" /><figcaption aria-hidden="true">image-20231231103906887</figcaption></figure><p>数据相关性：设指令i在指令j前面</p><ol type="1"><li>写读相关（RAW）：指令i将数据写入寄存器后，指令j才能读取</li><li>读写相关（WAR）：指令i读出数据后，指令j才能写寄存器</li><li>写写相关（WAW）：指令i写入后，指令j才能写入，否则寄存器内容不是最新值</li></ol><p>冒险类型：</p><ul><li>数据冒险：数据存在相关性，可用转发、暂停解决</li><li>控制冒险：分支跳转指令“撤回”等问题，可用延迟槽、分支比较前移解决</li><li>结构冒险：两条指令使用同一部件如同时读写寄存器堆，可通过把指令寄存器和数据寄存器分开解决</li></ul><h2 id="cache-1">Cache</h2><p><strong>注意主存地址位数（多少字节）、字节、字之间的换算！！！</strong></p><h3 id="cache结构">Cache结构</h3><p>SRAM组成，以数据块为单位。块大小与主存相同</p><p>数据块（block）：主存与cache交换数据的最小单位，多个字节组成</p><p>标记（tag）：保存该数据块对应的主存数据块的地址信息</p><p>有效位（valid bit）：该数据块中是否包含有效数据</p><p>行：1行=数据块+标记+有效位</p><p>组：若干块构成一组</p><p>实际Cache容量=行数*(tag+有效位等+数据块字节数)</p><h3 id="cache映射机制">Cache映射机制</h3><h4 id="全相联">全相联</h4><p>主存中某一数据块可以映射到Cache中的任意一数据块</p><p>Cache的tag内容：与该数据块对应的主存的数据块的块地址</p><p>主存地址格式：块地址+块内地址</p><h4 id="直接映射">直接映射</h4><p>主存中某一块J映射到Cache中的固定块K，<spanclass="math inline">\(K=J\mod M\)</span> ，M是Cache包含的块数</p><p>Cache的tag内容：主存中与该数据块对应的区地址，即第几个能映射到Cache中该块的数据块</p><p>主存地址格式：区地址+区内块地址+块内地址</p><h4 id="组相联">组相联</h4><p>Cache分成K组，每组L块，主存的块J映射到Cache中组I的任意一块，其中$I=JK$</p><p>实际上，主存与Cache都分为K组，但组内块数不同，组内任意映射</p><p>Cache的tag内容：主存中与该数据块对应的组内块地址</p><p>主存地址格式：组内块地址+组地址+块内地址</p><h3 id="缺失损失与替换策略">缺失损失与替换策略</h3><h4 id="缺失损失">缺失损失</h4><p>缺失时，CPU等待数据装入Cache后才能访问</p><p>取出块的时间：第一个字的延迟时间（存储器访问）+块的剩余部分的传送时间</p><p>计算方法1：访问Cache发现缺失的时间+访问DRAM的时间*字数+传输时间*字数</p><p>传输时间可能会因为并行数而改变</p><h4 id="缺失处理">缺失处理</h4><ul><li>块装入后访问</li><li>尽早重启：块中各字按顺序装入Cache，一旦所请求的字装入Cache，CPU立刻访问</li><li>请求字优先：先把所请求的字装入Cache，再装入其他字</li></ul><h4 id="替换策略">替换策略</h4><p>最近最少使用法（LRU）：最近没有被使用的块被替换。替换的块计数清零，其他计数器+1；访问命中时，计数值小于等于命中块计数值的+1，然后命中块清零；替换时选择计数值最大的块来替换</p><p>先进先出法（FIFO）：最先装入数据的块被替换</p><p>最小使用频率法（LFU）：使用次数最少的块被替换</p><p>随机法（RAND）</p><h2 id="辅助存储与虚拟存储">辅助存储与虚拟存储</h2><h3 id="辅助存储">辅助存储</h3><h4 id="磁介质">磁介质</h4><p>磁记录编码方式：</p><figure><img src="/img/image-20231231113943254.png"alt="image-20231231113943254" /><figcaption aria-hidden="true">image-20231231113943254</figcaption></figure><p>编码效率：记录一位信息的最大磁化翻转次数的倒数，调频、调相为0.5，不归零制为1</p><p>自同步能力：从读出的信号中提取同步信号。PM、FM有</p><p>可靠性：归零制低，调相制高</p><h5 id="磁盘">磁盘</h5><p>RPM：每分钟转多少圈</p><p>容量：盘面数*每面磁道数*每磁道扇区数*扇区容量</p><p>访问时间=寻道时间+寻区时间</p><p>数据传输率：单位时间传输的数据位数</p><p>RAID：廉价磁盘冗余阵列，多个物理磁盘构成，但被操作系统当成一个逻辑磁盘，数据分布在不同的物理磁盘上，冗余磁盘用于保存数据校验信息，校验信息保证在出现磁盘损坏时能够有效地恢复数据。</p><ul><li>RAID0：每一数据条带分布在不同物理磁盘上，改善数据传输性能，但完全没有冗余</li><li>RAID1：简单镜像磁盘冗余，利用率50%。写操作性能不高（同时写两组）</li><li>RAID2：海明校验，完整的并行访问技术</li><li>RAID3：奇偶校验的并行传送，校验码保存在独立的冗余磁盘对应位置</li><li>RAID4：奇偶校验吗的独立磁盘结构</li><li>RAID5：分布式奇偶校验的独立磁盘结构。校验信息保存在磁盘组的不同磁盘中</li></ul><h5 id="mips存储管理">MIPS存储管理</h5><p>从低到高32位：用户2G，KSeg0（有MMU的操作系统内核）512M，KSeg1512M，KSeg2 1G</p><p>PC初始值：0x00400000</p><p>$gp：0x10008000，静态数据区为0x10000000-0x1000FFFF</p><p>$sp：0x7FFFFFFF</p><h3 id="虚拟存储">虚拟存储</h3><p>虚地址：编写程序时使用的地址，地址格式为虚页号+页内地址</p><p>实地址：物理内存的访问地址，地址格式为实页号+页内地址</p><p>页表：每道程序一个，以虚页号为索引，实页号、有效位为页表项，存储在内存中</p><p>快表（TLB）：用Cache存储部分活跃的页表项，内容为虚页号、对应实页号、有效位、修改位</p><p>调度方式：页式调度、段式调度、段页式调度</p><h2 id="总线与io接口">总线与I/O接口</h2><h3 id="总线">总线</h3><p>分类：片内总线、系统总线、通信总线。其中系统总线可分为数据总线、地址总线、控制总线</p><p>总线的信息传送：请求总线、总线仲裁、寻址、信息传送、状态返回</p><p>总线仲裁方式（分布式、集中式）：链式查询、计数器定时查询、独立请求</p><p>总线通信方式：同步、异步（不互锁、半互锁、全互锁）</p><h3 id="io接口">I/O接口</h3><p>分类：串行/并行、同步/异步、程序查询/中断/DMA/通道控制接口</p><p>I/O操作过程：</p><ol type="1"><li>CPU查询接口状态</li><li>I/O回送设备状态</li><li>CPU发出命令，请求传送</li><li>I/O获得来自外设的数据</li><li>数据从I/O接口传送至CPU</li></ol><p>编址方式：独立编址、统一编址（存储器与I/O地址统一考虑）</p><p>程序查询I/O：I/O操作全部由CPU直接完成，与CPU串行，效率低</p><p>中断I/O：当前指令执行完毕后，响应中断。外设准备阶段可认为是并行的。目前最主要的方式。</p><p>DMA：CPU不再介入具体的I/O操作，DMA控制总线，数据传送效率更高。周期窃取方式（单字、一个总线周期），停止CPU访问内存（成组传送方式）。指令周期的任一存取周期结束时响应</p><p>通道I/O：有自己指令系统的专业控制器，CPU基本不需要管理I/O。选择通道的数据传输率=一台设备的数据传输率，字节多通道、数组多通道数据传输率=各设备数据传输率之和</p><h3 id="dma与中断">DMA与中断</h3><p>响应时机：中断在一条指令结束后响应；DMA在指令周期内任一存储周期结束时响应</p><p>现场保护：中断要中断现有程序，保护现场；DMA不中断现有程序，无须保护现场</p><p>适应场合：中断适于处理紧急或异常事件；DMA适合传送大批数据（如磁盘、网卡等）</p><p>传送方式：中断靠程序传送数据；DMA靠硬件</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>离散2笔记</title>
    <link href="/2024/01/14/%E7%A6%BB%E6%95%A32%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E7%A6%BB%E6%95%A32%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h3 id="考前要看的几点">考前要看的几点</h3><h4 id="判断题">判断题</h4><p>连通无向图：欧拉图 <spanclass="math inline">\(\Leftrightarrow\)</span>有欧拉闭路；非连通无向图：欧拉图 <spanclass="math inline">\(\Leftrightarrow\)</span> 每个分支都有欧拉闭路</p><p>字典序不一定保证有极小元（ab,aab,aaab,...）</p><p>n阶二叉树有(n+1)/2个叶节点，(n-1)/2个分支节点</p><p>任何图都有偶数个奇结点</p><p>三个集合间的交、并关系仔细看！</p><h4 id="证明题">证明题</h4><p>最优叶加权路径</p><p>n阶非循环无向图有n-1条边，求证连通</p><p>n阶连通无向图有n-1条边，求证非循环</p><p>n阶连通无向图G非循环，求证有n-1条边</p><p><span class="math inline">\(t(R)=R^{+}\)</span></p><p>基础图是完全无向图的n阶有向图必有哈密顿路径</p><h2 id="集合">集合</h2><p>罗素悖论：<span class="math inline">\(T=\{x|x\notinx\}\)</span>，则推理 <span class="math inline">\(T\in T\)</span> 与<span class="math inline">\(T\notin T\)</span> 过程中均产生矛盾</p><p>幂集：集合A的全部子集构成的集合，即 <spanclass="math inline">\(\mathcal{P}(A)=\{X|X\subseteq A\}\)</span></p><p>A有穷，则 <spanclass="math inline">\(\#\mathcal{P}(A)=2^{\#A}\)</span></p><h4 id="集合的运算">集合的运算</h4><p><span class="math inline">\(A-B=A\cap \sim B\)</span></p><p><span class="math inline">\(A\oplus B=(A-B)\cup(B-A)\)</span></p><p>证明某式成立：元素分析法、集合运算</p><h4 id="广义交广义并">广义交、广义并</h4><p>集类：某集合的所有元素都是集合</p><p>广义并：设 <span class="math inline">\(\mathcal{B}\)</span>是任意集类，称集合 <span class="math inline">\(\{x|\existsX(X\in\mathcal{B}\land x\in X)\}\)</span> 为 <spanclass="math inline">\(\mathcal{B}\)</span> 的广义并，记为 <spanclass="math inline">\(\cup\mathcal{B}\)</span></p><p>广义交：设 <span class="math inline">\(\mathcal{B}\)</span>是任意集类，且 <spanclass="math inline">\(\mathcal{B}\ne\emptyset\)</span>，称集合 <spanclass="math inline">\(\{x|\forall X(X\in\mathcal{B}\rightarrow x\inX)\}\)</span> 为 <span class="math inline">\(\mathcal{B}\)</span>的广义交，记为 <span class="math inline">\(\cap\mathcal{B}\)</span></p><p>有穷集的计数原理：<span class="math inline">\(\#(A\cupB)=\#A+\#B-\#(A\cap B)\)</span></p><h4 id="集合的归纳定义字符串集合">集合的归纳定义、字符串集合</h4><h5 id="归纳定义法">归纳定义法</h5><ol type="1"><li>基本项：非空集 <span class="math inline">\(S_0\subseteqA\)</span></li><li>归纳项：一组规则，使得从A中元素出发，按照规则所获得的元素仍然是A中元素</li><li>极小化：A中每个元素都是通过有限次使用1或2获得的，如果集合 <spanclass="math inline">\(S\subseteq A\)</span> 也满足1和2，则 <spanclass="math inline">\(S=A\)</span></li></ol><h5 id="字符串集合">字符串集合</h5><p>字母表 <spanclass="math inline">\(\Sigma\)</span>：字母或符号的非空有限集合</p><p>字符串：由 <span class="math inline">\(\Sigma\)</span>中字母组成的有穷序列</p><p>字符串长度：字符串 <span class="math inline">\(x\)</span>所含字母的个数，记作 <span class="math inline">\(|x|\)</span></p><p>空串：若 <span class="math inline">\(|x|=0\)</span>，称 <spanclass="math inline">\(x\)</span> 为空串，记作 <spanclass="math inline">\(\varepsilon\)</span></p><p>字符串连接：设 <span class="math inline">\(\Sigma\)</span>是一字母表，<span class="math inline">\(x,y\)</span> 是 <spanclass="math inline">\(\Sigma\)</span> 上字符串，<spanclass="math inline">\(x=a_1a_2...a_n,y=b_1b_2...b_m\)</span> ，则 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的连接记作 <spanclass="math inline">\(xy\)</span>，<spanclass="math inline">\(xy=a_1a_2...a_nb_1b_2...b_m\)</span>。另外规定：</p><ul><li><span class="math inline">\(x\varepsilon=\varepsilonx=x\)</span></li><li>n个 <span class="math inline">\(x\)</span> 的连接记作 <spanclass="math inline">\(x^n,x^0=\varepsilon,x^{n+1}=x^nx\)</span></li><li><span class="math inline">\(|x+y|=|x|+|y|\)</span></li></ul><p>字符串集合 <span class="math inline">\(\Sigma^*\)</span>：<spanclass="math inline">\(\Sigma\)</span>上的所有字符串构成的集合，其中非空字符串的集合记为 <spanclass="math inline">\(\Sigma^+\)</span>，<spanclass="math inline">\(\Sigma^*\)</span> 归纳定义如下</p><ol type="1"><li><spanclass="math inline">\(\{\varepsilon\}\cup\Sigma\subseteq\Sigma^*\)</span></li><li>若 <span class="math inline">\(x\in\Sigma^*\)</span> 且 <spanclass="math inline">\(a\in\Sigma\)</span>，则 <spanclass="math inline">\(xa\in\Sigma^*\)</span></li><li><span class="math inline">\(\Sigma^*\)</span>中的每一个元素都可以通过有限次应用上述1、2规则得到</li></ol><h4 id="语言">语言</h4><p><span class="math inline">\(\Sigma^*\)</span> 的子集称 <spanclass="math inline">\(\Sigma\)</span> 上的语言</p><p>语言的乘积：设A、B是 <span class="math inline">\(\Sigma\)</span>上的语言，则A与B的乘积记作 <span class="math inline">\(AB=\{xy|x\inA\land y\in B\}\)</span></p><p>语言的幂运算：<spanclass="math inline">\(A^0=\{\varepsilon\},A^{n+1}=A^nA\)</span></p><p>语言的闭包：<span class="math inline">\(A^*={\varepsilon\cup A\cupA^2\cup......}\)</span>，正闭包 <span class="math inline">\(A^+\)</span>没有 <span class="math inline">\(\varepsilon\)</span></p><h3 id="有序偶与笛卡尔积">有序偶与笛卡尔积</h3><p>有序偶：<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\}\}\)</span></p><p>笛卡尔积：<span class="math inline">\(A\times B=\{&lt;x,y&gt;|x\inA\land y\in B\}\)</span></p><p>笛卡尔积无交换律，但是对交、并、差满足分配律</p><h2 id="关系">关系</h2><h3 id="定义与性质">定义与性质</h3><p>设 <span class="math inline">\(n\in I^+\)</span>，且 <spanclass="math inline">\(A_1,A_2,...A_n\)</span> 为n个任意的集合，<spanclass="math inline">\(R\subseteq A_1\times A_2\times...\timesA_n\)</span>，称R为 <span class="math inline">\(A_1,A_2,...A_n\)</span>间的n元关系。<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则可表示成 <span class="math inline">\(xRy\)</span> ；<spanclass="math inline">\(&lt;x,y&gt;\notin R\)</span>，则可表示成 <spanclass="math inline">\(x\bar{R}y\)</span></p><p>全关系：<span class="math inline">\(R= A_1\times A_2\times...\timesA_n\)</span></p><p>A<strong>上</strong>的关系：<spanclass="math inline">\(A_1=A_2=...=A_n=A\)</span></p><p>恒等关系（X上的二元关系）：<spanclass="math inline">\(I_X=\{&lt;x,x&gt;|x\in X\}\)</span></p><p>从有限集到有限集的二元关系可用关系图、关系矩阵表示</p><p>设R是集合X上的二元关系：</p><ul><li>自反性：<span class="math inline">\(\forall x(x\inX\rightarrow&lt;x,x&gt;\in R)\Leftrightarrow I_X\subseteq R\)</span>，对角线元素为1、所有节点有自环</li><li>反自反：<span class="math inline">\(\forall x(x\inX\rightarrow&lt;x,x&gt;\notin R)\Leftrightarrow I_X\capR=\emptyset\)</span> ，对角线元素为0、所有节点无自环</li><li>对称性：<span class="math inline">\(\forall x\forall y(x\in X\landy\in X\land&lt;x,y&gt;\in R\rightarrow&lt;y,x&gt;\in R)\LeftrightarrowR=R^{-1}\)</span>， 对称矩阵、边成对出现</li><li>反对称：<span class="math inline">\(\forall x\forall y(x\in X\landy\in X\land&lt;x,y&gt;\in R\land&lt;y,x&gt;\in R\rightarrowx=y)\Leftrightarrow R\cap R^{-1}\subseteq I_X\)</span></li><li>传递性：<span class="math inline">\(\forall x\forall y \forallz(x\in X\land y\in X\land z\in X\land&lt;x,y&gt;\in R\land&lt;y,z&gt;\inR\rightarrow&lt;x,z&gt;\in R)\Leftrightarrow R\circ R\subseteqR\)</span>， x到y有路径，则x到y有边</li></ul><p>非空集上的空关系没有自反性，空集上的空关系具有全部性质</p><p>含有3个元素的集合A上的反对称关系共有216个（用矩阵考虑，且三角阵里是<span class="math inline">\(3^3\)</span>）</p><h3 id="关系的运算">关系的运算</h3><h4 id="交并补异或差">交并补、异或、差</h4><p>定义域与值域：</p><ul><li><span class="math inline">\(dom(R)=\{x\in A|\exists y\inB使得&lt;x,y&gt;\in R\}\)</span></li><li><span class="math inline">\(ran(R)=\{y\in B|\exists x\inA使得&lt;x,y&gt;\in R\}\)</span></li><li><span class="math inline">\(dom(R_1\cup R_2)=dom(R_1)\cupdom(R_2)\)</span></li><li><span class="math inline">\(ran(R_1\cap R_2)\subseteq ran(R_1)\capran(R_2)\)</span> （<strong>注意交集的情况下不会相等</strong>）</li></ul><table><thead><tr class="header"><th style="text-align: center;">R,S</th><th style="text-align: center;"><span class="math inline">\(R\capS\)</span></th><th style="text-align: center;"><span class="math inline">\(R\cupS\)</span></th><th style="text-align: center;"><spanclass="math inline">\(R-S\)</span></th><th style="text-align: center;"><span class="math inline">\(R\oplusS\)</span></th><th style="text-align: center;"><span class="math inline">\(\simR\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">自反</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">反自反</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">对称</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="even"><td style="text-align: center;">反对称</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">传递</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>逆关系相当于矩阵转置，保持原有关系的5个性质</p><h4 id="复合运算">复合运算</h4><p><span class="math inline">\(R\circ S=\{&lt;x,z&gt;|\exists y\inY使得xRy\land ySz\}\)</span></p><p>若R是A上的关系，则 <span class="math inline">\(R^0=I_A\)</span> ，<span class="math inline">\(R^{n+1}=R^n\circ R\)</span></p><p>有时也记 <spanclass="math inline">\(R^{+}=\cup_{i=1}^{\infty}R^i\)</span></p><p>无交换律，有结合律</p><p>设 <span class="math inline">\(R_1\subseteq A\times B,\R_2,R_3\subseteq B\times C，R_4\subseteq C\times D\)</span>，则</p><ul><li><p><span class="math inline">\(R_1\circ(R_2\cup R_3)=(R_1\circR_2)\cup(R_1\circ R_3)\)</span></p></li><li><p><span class="math inline">\(R_1\circ(R_2\capR_3)\subseteq(R_1\circ R_2)\cap(R_1\circR_3)\)</span>（<strong>注意交集的情况下可能不会相等</strong>）</p></li><li><p><span class="math inline">\((R_1\circ R_2)^{-1}=R_2^{-1}\circR_1^{-1}\)</span></p></li></ul><p>复合运算仅能保持5个性质中的自反性</p><h4 id="闭包">闭包</h4><p>定义：设R是集合A上的关系，称R‘是R的自反（对称、传递）闭包，当且仅当</p><ol type="1"><li>R'是自反（对称、传递）的</li><li><span class="math inline">\(R\subseteq R&#39;\)</span></li><li>对于A上的任何自反（对称、传递）关系R''，如果 <spanclass="math inline">\(R\subseteq R&#39;&#39;\)</span> ，则 <spanclass="math inline">\(R&#39;\subseteq R&#39;&#39;\)</span></li></ol><p>R的自反（对称、传递）闭包即包含R的最小自反（对称、传递）关系</p><ul><li>R自反：<span class="math inline">\(r(R)=R=R\cup I_A\)</span></li><li>R对称：<span class="math inline">\(s(R)=R=R\cup R^{-1}\)</span></li><li>R传递：<spanclass="math inline">\(t(R)=R=\cup_{n=1}^{\infty}R^n\)</span></li><li><span class="math inline">\(t(R)=\cup_{i=1}^{\#A}R^i\)</span></li></ul><p>闭包运算保持集合上的包含关系，但传递闭包不保持关系的并</p><ul><li><span class="math inline">\(r(R_1\cup R_2)=r(R_1)\cupr(R_2)\)</span></li><li><span class="math inline">\(s(R_1\cup R_2)=s(R_1)\cups(R_2)\)</span></li><li><span class="math inline">\(t(R_1)\cup t(R_2)\subseteq t(R_1\cupR_2)\)</span></li></ul><table><thead><tr class="header"><th style="text-align: center;">R</th><th style="text-align: center;">r(R)</th><th style="text-align: center;">s(R)</th><th style="text-align: center;">t(R)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">自反性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="even"><td style="text-align: center;">对称性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="odd"><td style="text-align: center;">传递性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr></tbody></table><h3 id="次序">次序</h3><h4 id="各种序">各种序</h4><ul><li><p>偏序关系：A上二元关系R，且R自反、反对称、传递。用 <spanclass="math inline">\(&lt;A,\le&gt;\)</span> 表示偏序结构</p></li><li><p>全序关系：<span class="math inline">\(&lt;A,\le&gt;\)</span>是一个偏序结构，若 <span class="math inline">\((\forall xy)(x\in A\landy\in A\rightarrow x\le y\lor y\le x)\)</span>，则称 <spanclass="math inline">\(\le\)</span> 为A上的全序（线序），并称 <spanclass="math inline">\(&lt;A,\le&gt;\)</span> 为全序结构（链）</p></li><li><p>严格偏序关系：A上二元关系R，且R反自反、传递</p></li><li><p>覆盖：y是x的覆盖 <span class="math inline">\(\Leftrightarrowx&lt;y\land\neg\exists z(z\in A\land x&lt;z\landz&lt;y)\)</span></p></li><li><p>良序：偏序结构 <spanclass="math inline">\(&lt;A,\le&gt;\)</span>，若A的每一个非空子集都有一个最小元，则称<span class="math inline">\(\le\)</span> 为良序关系，<spanclass="math inline">\(&lt;A,\le&gt;\)</span> 为良序结构</p></li></ul><p>良序的充要条件：全序+非空子集有极小元；全序+不存在A中元素的无穷递降序列</p><h4 id="特殊元素">特殊元素</h4><p><span class="math inline">\(&lt;A,\le&gt;\)</span> 是偏序结构，并且<span class="math inline">\(S\subseteq A,S\ne\emptyset\)</span></p><ul><li>S的最大元：<span class="math inline">\(b\in S\land\forall x(x\inS\rightarrow x\le b)\)</span></li><li>S的最小元：<span class="math inline">\(b\in S\land\forall x(x\inS\rightarrow b\le x)\)</span></li><li>S的极大元：<span class="math inline">\(b\in S\land\forall x(x\inS\land b\le x\rightarrow x=b)\)</span></li><li>S的极小元：<span class="math inline">\(b\in S\land\forall x(x\inS\land x\le b\rightarrow x=b)\)</span></li><li>S的上界：<span class="math inline">\(b\in A\land\forall x(x\inS\rightarrow x\le b)\)</span></li><li>S的下界：<span class="math inline">\(b\in A\land\forall x(x\inS\rightarrow b\le x)\)</span></li></ul><p>注意S的上下界可能不在S中</p><h3 id="等价关系">等价关系</h3><ul><li><p>相容关系：A上关系R自反、对称</p></li><li><p>等价关系：A上关系R自反、对称、传递<spanclass="math inline">\(\Leftrightarrow r(R)=s(R)=t(R)=R\)</span></p></li></ul><p>R是A上二元关系，则 <spanclass="math inline">\(tsr(R)、trs(R)、rts(R)\)</span>都是A上的等价关系（t在s之后）</p><p>设R是A上等价关系</p><ul><li><p>等价类：<span class="math inline">\([x]_R=\{y|y\in A\landxRy\}\)</span></p></li><li><p>商集：<span class="math inline">\(A/R=\{[x]_R|x\in A\}\)</span>，称 <span class="math inline">\(n(A/R)\)</span> 为R的秩</p></li></ul><h4 id="划分">划分</h4><p>定义：设 <spanclass="math inline">\(\Pi\subseteq\mathcal{P}(A)\)</span> ，且有</p><ol type="1"><li>若 <span class="math inline">\(S\in\Pi\)</span> ，则 <spanclass="math inline">\(S\ne\emptyset\)</span></li><li><span class="math inline">\(\cup\Pi=A\)</span></li><li>若<span class="math inline">\(S_1,S_2\in\Pi\)</span> ，且 <spanclass="math inline">\(S_1\cap S_2\ne\emptyset\)</span>，则 <spanclass="math inline">\(S_1=S_2\)</span></li></ol><p>若R为A上的等价关系，则商集 <spanclass="math inline">\(A/R=\{[x]_R|x\in A\}\)</span> 为A的一个划分</p><p>若 <span class="math inline">\(\Pi\)</span> 为A的一个划分，则 <spanclass="math inline">\(R_{\Pi}=\{&lt;x,y&gt;|\exists S\in\Pi,使x,y\inS\}\)</span> 为A上的等价关系，且 <spanclass="math inline">\(A/R_{\Pi}=\Pi\)</span></p><h2 id="函数">函数</h2><h3 id="部分函数相关概念">部分函数相关概念</h3><p>部分函数：从X到Y的二元关系f满足 <spanclass="math inline">\(&lt;x,y_1&gt;\in f\land&lt;x,y_2&gt;\inf\rightarrow y_1=y_2\)</span> ，记作 <spanclass="math inline">\(y=f(x)\)</span></p><p>定义域：<span class="math inline">\(dom(f)=\{x\in X|\exists y\inY使y=f(x)\}\)</span> 。<span class="math inline">\(x\in dom(f)\)</span>称f在x处有定义，记为 <span class="math inline">\(f(x)\uparrow\)</span>，反之记为 <span class="math inline">\(f(x)\downarrow\)</span></p><p>值域：<span class="math inline">\(ran(f)=\{y\in Y|\exists x\inX使y=f(x)\}\)</span></p><p><span class="math inline">\(dom(g\circ f)=f^{-1}[dom\ g],ran(g\circf)=g[ran\ f]\)</span></p><p>严格部分函数：<span class="math inline">\(dom f\subset X\)</span></p><p>从X到Y<strong>上</strong>的部分函数：<span class="math inline">\(ranf=Y\)</span></p><p>从X到Y<strong>内</strong>的部分函数：<span class="math inline">\(ranf\subset Y\)</span></p><p>1-1部分函数：<span class="math inline">\(\forall x_1,x_2\in domf,当x_1\ne x_2时,均有f(x_1)\ne f(x_2)\)</span></p><p><span class="math inline">\(A\subseteq X,B\subseteq Y\)</span>像：<span class="math inline">\(f[A]=\{y\in Y|\exists x\inA使y=f(x)\}\)</span> 源像：<span class="math inline">\(f^{-1}[B]=\{x\inX|\exists y\in B使y=f(x)\}\)</span></p><h3 id="函数相关概念">函数相关概念</h3><ul><li>函数（全函数）：<span class="math inline">\(dom f=X\)</span>，记为<span class="math inline">\(f:X\rightarrow Y\)</span></li><li>限制：<span class="math inline">\(f:X\rightarrow Y,A\subseteqX\)</span>，称 <span class="math inline">\(f\cap(A\times Y)\)</span>是从A到Y的函数，f在A上的限制，记作 <spanclass="math inline">\(f|_A\)</span>。f为 <spanclass="math inline">\(f|_A\)</span> 到X的延拓</li><li>记A到B的函数的集合为 <spanclass="math inline">\(B^A=\{f|f:A\rightarrow B\}\)</span> ，则有 <spanclass="math inline">\(n(B^A)=(n(B))^{n(A)}\)</span></li><li>单射（内射）：<span class="math inline">\(\forall x_1\forallx_2(x_1\in X\land x_2\in X\land f(x_1)=f(x_2)\rightarrowx_1=x_2)\)</span></li><li>满射：<span class="math inline">\(ranf=Y\)</span></li><li>双射：单射+满射</li><li>*自然映射/正则映射：设R是集合A上的等价关系，<spanclass="math inline">\(\varphi=\{&lt;x,[x]_R&gt;|x\in A\}\)</span></li></ul><p><strong>注意空关系！</strong></p><p>设X是任意集合、f和g都是X到R的函数</p><p><span class="math inline">\(f\leqslant g:\forall x\in X\rightarrowf(x)\leqslant g(x)\)</span></p><p><span class="math inline">\(f+g:\forall x\in X\rightarrow(f+g)(x)=f(x)+g(x)\)</span> ，称 <spanclass="math inline">\(f+g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的和</p><p><span class="math inline">\(f-g:\forall x\in X\rightarrow(f-g)(x)=f(x)-g(x)\)</span> ，称 <spanclass="math inline">\(f-g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的差</p><p><span class="math inline">\(f*g:\forall x\in X\rightarrow(f*g)(x)=f(x)*g(x)\)</span> ，称 <spanclass="math inline">\(f*g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的积</p><h3 id="函数的复合">函数的复合</h3><p>设f是从X到Y的（部分）函数，g为从Y到Z的（部分）函数，则复合关系 <spanclass="math inline">\(f\circ g\)</span> 是从X到Y的（部分）函数，记为<span class="math inline">\(g\circ f=\{&lt;x,z&gt;|x\in X\land z\inZ\land \exists y(y\in Y\land y=f(x)\land z=g(y))\}\)</span></p><p><span class="math inline">\(f:X\rightarrow X\)</span>，则f的n次幂记为<span class="math inline">\(f^n=f\circ f^{n-1}\)</span> ……</p><p><span class="math inline">\(g\circ f\)</span>可以传递满射、单射、双射的性质（f与g均满足时）</p><p>逆向推导“左满右单”（<span class="math inline">\(f:X\rightarrowY,g:Y\rightarrow Z\)</span>）：</p><ul><li>若 <span class="math inline">\(g\circ f\)</span> 是满射，则 <spanclass="math inline">\(g\)</span> 是满射</li><li>若 <span class="math inline">\(g\circ f\)</span> 是单射，则 <spanclass="math inline">\(f\)</span> 是单射</li><li>若 <span class="math inline">\(g\circ f\)</span> 是双射，则 <spanclass="math inline">\(g\)</span> 是满射且 <spanclass="math inline">\(f\)</span> 是单射</li></ul><h3 id="逆函数">逆函数</h3><h4 id="定义">定义</h4><p><span class="math inline">\(f:X\rightarrow Y\)</span></p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(g\circ f=I_X\)</span>，称f为左可逆，g为f的一个左逆函数（左逆）</p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(f\circ g=I_Y\)</span>，称f为右可逆，g为f的一个右逆函数（右逆）</p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(g\circ f=I_X\)</span> 且 <spanclass="math inline">\(f\circ g=I_Y\)</span>，称f可逆，g为f的一个逆函数（逆）</p><h4 id="充要条件">充要条件</h4><p>设 <span class="math inline">\(X\ne \emptyset\)</span> ，若 <spanclass="math inline">\(f:X\rightarrow Y\)</span> ，则以下条件等价</p><ul><li>f为单射</li><li>f左可逆</li><li>f可左消去，即对任意Z、任意 <spanclass="math inline">\(g:Z\rightarrow X\)</span> 和 <spanclass="math inline">\(h:Z\rightarrow X\)</span>，当 <spanclass="math inline">\(f\circ g=f\circ h\)</span> 时，都有 <spanclass="math inline">\(g=h\)</span></li></ul><p>设 <span class="math inline">\(f:X\rightarrow Y\)</span>，则以下条件等价</p><ul><li>f为满射</li><li>f右可逆</li><li>f可右消去，即对任意Z、任意 <spanclass="math inline">\(g:Y\rightarrow Z\)</span> 和 <spanclass="math inline">\(h:Y\rightarrow Z\)</span>，当 <spanclass="math inline">\(g\circ f=h\circ f\)</span> 时，都有 <spanclass="math inline">\(g=h\)</span></li></ul><p><span class="math inline">\(f:X\rightarrow Y\)</span>，则 <spanclass="math inline">\(f\)</span> 是双射 <spanclass="math inline">\(\Leftrightarrow f\)</span> 可逆</p><p><span class="math inline">\(f:X\rightarrow Y,g:Y\rightarrowZ\)</span> 都可逆，则 <span class="math inline">\(g\circ f\)</span>可逆，且 <span class="math inline">\((g\circ f)^{-1}=f^{-1}\circg^{-1}\)</span></p><h3 id="特征函数">特征函数</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(U\)</span> 是全集，<spanclass="math inline">\(A\)</span> 是 <spanclass="math inline">\(U\)</span> 的子集，<spanclass="math inline">\(A\)</span> 的特征函数为 <spanclass="math inline">\(\chi_A(x):U\rightarrow R\)</span> <spanclass="math display">\[\chi_A(x)=\begin{cases} 1,x\in A\\0,x\notin A \end{cases}\]</span></p><h4 id="性质">性质</h4><p><span class="math inline">\(\forall x(\chi_A(x)=0)\LeftrightarrowA=\emptyset\)</span></p><p><span class="math inline">\(\forall x(\chi_A(x)=1)\LeftrightarrowA=U\)</span></p><p><span class="math inline">\(\forallx(\chi_A(x)\leqslant\chi_B(x))\Leftrightarrow A\subseteq B\)</span></p><p><span class="math inline">\(\forallx(\chi_A(x)=\chi_B(x))\Leftrightarrow A=B\)</span></p><h4 id="运算">运算</h4><p><span class="math inline">\(\chi_A*\chi_A=\chi_A\)</span></p><p><span class="math inline">\(\chi_A*\chi_B=\chi_A\LeftrightarrowA\subseteq B\)</span></p><p>交：<span class="math inline">\(\chi_{A\capB}=\chi_A*\chi_B\)</span></p><p>并：<span class="math inline">\(\chi_{A\cupB}=\chi_A+\chi_B-\chi_A*\chi_B\)</span></p><p>补：<span class="math inline">\(\chi_{\sim A}=1-\chi_A\)</span></p><p>差：<spanclass="math inline">\(\chi_{A-B}=\chi_A-\chi_A*\chi_B\)</span></p><h2 id="自然数基数与归纳法">自然数、基数与归纳法</h2><h3 id="自然数与归纳法">自然数与归纳法</h3><p>后继：A的后继 <span class="math inline">\(A^{+}=A\cup\{A\}\)</span>，每个集合的后继唯一</p><h4 id="自然数的归纳定义">自然数的归纳定义：</h4><ol type="1"><li><p><span class="math inline">\(0\in N\)</span> ，此处 <spanclass="math inline">\(0=\emptyset\)</span></p></li><li><p>若 <span class="math inline">\(n\in N\)</span>，则 <spanclass="math inline">\(n^{+}\in N\)</span></p></li><li><p>若 <span class="math inline">\(S\subseteq N\)</span>，且满足</p><p>a.<span class="math inline">\(0\in S\)</span></p><p>b.如果 <span class="math inline">\(n\in S\)</span> ，则 <spanclass="math inline">\(n^{+}\in S\)</span></p><p>则 <span class="math inline">\(S=N\)</span></p></li></ol><h4 id="自然数的运算">自然数的运算</h4><p>对于每个自然数n，都有 <span class="math inline">\(n\in n^{+}\)</span>且 <span class="math inline">\(n\subseteq n^{+}\)</span> ，<spanclass="math inline">\(\cup n^{+}=n\)</span></p><p><span class="math inline">\(m&lt;n\)</span>：<spanclass="math inline">\(m,n\in N,m\in n\)</span></p><p>+：<span class="math inline">\(m+0=m,m+n^{+}=(m+n)^{+}\)</span></p><p><span class="math inline">\(\cdot\)</span>：<spanclass="math inline">\(m\cdot0=0,m\cdot n^{+}=m\cdot n+m\)</span></p><h4 id="自然数系统与皮亚诺公理">自然数系统与皮亚诺公理</h4><p>定义加法与乘法后，得到自然数系统 <spanclass="math inline">\(&lt;N,+,\cdot&gt;\)</span></p><p>这样构造的自然数系统满足以下皮亚诺公理：</p><ol type="1"><li><span class="math inline">\(0\in N\)</span></li><li>若 <span class="math inline">\(n\in N\)</span> ，则有唯一后继 <spanclass="math inline">\(n^{+}\in N\)</span></li><li>若 <span class="math inline">\(n\in N\)</span> ，则有 <spanclass="math inline">\(n^{+}\ne0\)</span></li><li>若 <span class="math inline">\(n,m\in N\)</span> 且 <spanclass="math inline">\(n^{+}=m^{+}\)</span> ，则 <spanclass="math inline">\(n=m\)</span></li><li>若 <span class="math inline">\(S\subseteq N\)</span> 满足 <spanclass="math inline">\(0\in S\)</span>、如果 <spanclass="math inline">\(n\in S\)</span> 则 <spanclass="math inline">\(n^{+}\in S\)</span> ，则 <spanclass="math inline">\(S=N\)</span></li></ol><p>作为集合的自然数满足</p><ul><li>传递性：若 <span class="math inline">\(n_1\in n_2\)</span> 且 <spanclass="math inline">\(n_2\in n_3\)</span> ，则 <spanclass="math inline">\(n_1\in n_3\)</span></li><li>三歧性：对于任意两个自然数 <spanclass="math inline">\(n_1,n_2\)</span> ，下式恰有一个成立：<spanclass="math inline">\(n_1\in n_2,n_1=n_2,n_2\in n_1\)</span></li><li>良基性：不存在一个自然数的无穷递降序列</li></ul><h4 id="数学归纳法">数学归纳法</h4><h5 id="第一种">第一种</h5><p>设 <span class="math inline">\(N_n=\{0,1,...,n-1\}\)</span> ，<spanclass="math inline">\(\bar{N}_n=N-N_n={n,n+1,...}\)</span> ， <spanclass="math inline">\(n_0\in N\)</span></p><p>若对每个 <span class="math inline">\(n\in \bar{N}_{n0}\)</span>，命题 <span class="math inline">\(P(n)\)</span> 满足：</p><ol type="1"><li><span class="math inline">\(P(n_0)\)</span> 真</li><li>对任意 <span class="math inline">\(n\in \bar{N}_{n0}\)</span> ，若<span class="math inline">\(P(n)\)</span> 为真，则 <spanclass="math inline">\(P(n^{+})\)</span> 也为真</li></ol><p>则对所有 <span class="math inline">\(n\in\bar{N}_{n0}\)</span>，<span class="math inline">\(P(n)\)</span> 都为真</p><h5 id="第二种">第二种</h5><p>设 <span class="math inline">\(n_0\in N\)</span> ，若对每个 <spanclass="math inline">\(n\in \bar{N}_{n0}\)</span> ，<spanclass="math inline">\(P(n)\)</span> 满足：</p><ol type="1"><li><span class="math inline">\(P(n_0)\)</span> 为真</li><li>对任何自然数 <span class="math inline">\(n&gt;n_0\)</span> ，若当<span class="math inline">\(k\in N\)</span> ，且 <spanclass="math inline">\(n_0\leqslant k&lt;n\)</span> 时 <spanclass="math inline">\(P(k)\)</span> 为真，则 <spanclass="math inline">\(P(n)\)</span> 也为真</li></ol><p>则对所有 <span class="math inline">\(n\in\bar{N}_{n0}\)</span>，<span class="math inline">\(P(n)\)</span> 都为真</p><h5 id="二重归纳">二重归纳</h5><p>设 <span class="math inline">\(i_0,j_0\in N\)</span> ，对任意自然数<span class="math inline">\(i\geqslant i_0,j\geqslant j_0\)</span>，都有命题 <span class="math inline">\(P(i,j)\)</span> 满足</p><ol type="1"><li><span class="math inline">\(P(i_0,j_0)\)</span> 为真</li><li>对任意自然数 <span class="math inline">\(k\geqslant i_0,l\geqslantj_0\)</span> ，若 <span class="math inline">\(P(k,l)\)</span> 为真，则<span class="math inline">\(P(k+1,l)\)</span> 和 <spanclass="math inline">\(P(k,l+1)\)</span> 都为真</li></ol><p>则对任意自然数 <span class="math inline">\(i\geqslant i_0,j\geqslantj_0\)</span> ，<span class="math inline">\(P(i,j)\)</span> 都为真</p><h3 id="基数">基数</h3><h4 id="概念">概念</h4><p>等势：若存在从集合A到集合B的双射，则称A、B等势，记为 <spanclass="math inline">\(A\sim B\)</span></p><p>有穷与无穷：设 <span class="math inline">\(n={0,1,...n-1}\)</span>，若存在 <span class="math inline">\(n\in N\)</span> 使 <spanclass="math inline">\(A\sim N\)</span> ，称A为有穷集，否则为无穷集</p><p>有穷集的基数：即元素个数，表示为 <spanclass="math inline">\(\#(A),card(A),n(A)或|A|\)</span> ，且若 <spanclass="math inline">\(A\sim n\)</span>，则 <spanclass="math inline">\(\#(A)=n\)</span></p><p>无穷集的基数：<span class="math inline">\(\#(N)=\aleph_0\)</span></p><p>可数集：可数无穷集合+有穷集</p><p>可数无穷集合：任何与自然数集等势的集合</p><p>不可数集：无穷且不可数</p><h4 id="基数的大小">基数的大小</h4><p><span class="math inline">\(A\sim B\)</span> ，则基数相等，记为 <spanclass="math inline">\(\#(A)=\#(B)\)</span></p><p>存在从A到B的<strong>单射</strong>，则 <spanclass="math inline">\(\#(A)\leqslant\#(B)\)</span></p><p>若 <span class="math inline">\(\#(A)\leqslant\#(B)\)</span> 且 <spanclass="math inline">\(\#(A)\ne\#(B)\)</span> ，则 <spanclass="math inline">\(\#(A)&lt;\#(B)\)</span></p><p>对每个集合A，<spanclass="math inline">\(\#A&lt;\#\mathcal{P}(A)\)</span> ，且 <spanclass="math inline">\(\#(R)=\#\mathcal{P}(N)=\aleph\)</span>（二进制+特征函数证明）</p><p>定义 <spanclass="math inline">\(f:\mathcal{P}(N)\rightarrow[0,1]\)</span> <spanclass="math display">\[f(A)=\begin{cases}0,A=\emptyset\\1,A=N\\\sum\limits_{i=0}^{\infty}\dfrac{\chi_A(i)}{2^{i+1}}\end{cases}\]</span> 可证</p><h2 id="图论">图论</h2><h3 id="基础概念">基础概念</h3><h4 id="定义-2">定义</h4><p>设V、E是有限集合且V非空</p><p><strong>无向图</strong>：如果 <spanclass="math inline">\(\Psi:E\rightarrow\{\{v_1,v_2\}|v_1\in V且v_2\inV\}\)</span> ，则称 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> 为无向图</p><p><strong>有向图</strong>：<spanclass="math inline">\(\Psi:E\rightarrow V\times V\)</span>，则G为有向图</p><p>称V为<strong>结点集</strong>，E为<strong>边集</strong>，结点数目称<strong>阶</strong></p><p>若有 <span class="math inline">\(\Psi(e)=\{v_1,v_2\}\)</span> 或<span class="math inline">\(\Psi(e)=&lt;v_1,v_2&gt;\)</span> ，称e与<span class="math inline">\(v_1\)</span>互相<strong>关联</strong>，<span class="math inline">\(v_1\)</span> 与<span class="math inline">\(v_2\)</span> <strong>临接</strong>，无向图中<span class="math inline">\(v_1,v_2\)</span> 既是起点又是终点，有向图中<span class="math inline">\(v_1\)</span> 为起点，<spanclass="math inline">\(v_2\)</span> 为终点</p><p>若 <span class="math inline">\(e\)</span>关联的两个结点相同，则e为<strong>自圈</strong>（自环）。若 <spanclass="math inline">\(\Psi(e_1)=\Psi(e_2)\)</span> ，称 <spanclass="math inline">\(e_1\)</span> 与 <spanclass="math inline">\(e_2\)</span> <strong>平行</strong>（重边）</p><p><strong>简单图</strong>：G无自圈，无平行边</p><p>无向图中与v关联的边的数目之和称<strong>度</strong>，记为 <spanclass="math inline">\(d_G(v)\)</span></p><p>有向图中以v为起点的边的数目为v的<strong>出度</strong>，记为 <spanclass="math inline">\(d_G^{+}(v)\)</span>；以v为终点的边的数目为v的<strong>入度</strong>，记为<span class="math inline">\(d_G^{-}(v)\)</span> ；出度+入度=度，记为<span class="math inline">\(d_G(v)\)</span></p><p>度为奇数称<strong>奇结点</strong>，偶数为<strong>偶结点</strong>，0为<strong>孤立点</strong>，1为<strong>端点</strong>。</p><h4 id="定理">定理</h4><p>握手定理：设图G中有m条边，则 <span class="math inline">\(\sum_{v\inV}d_G(v)=2m\)</span></p><p>任何图中都有偶数个奇结点</p><h4 id="特殊的图">特殊的图</h4><p><strong>零图</strong>：结点都是孤立点的图</p><p><strong>平凡图</strong>：一阶零图</p><p><strong>d度正则图</strong>：所有结点的度均为自然数d的无向图</p><p><strong>完全无向图</strong>：n阶简单无向图G是n-1度正则图，则是完全无向图，记为<span class="math inline">\(K_n\)</span></p><p><strong>完全有向图</strong>：每个结点的出度与入度均为n-1的n阶简单有向图</p><p>零图也是正则图，正则图不一定是完全图</p><p><strong>圈图</strong>：结点恰形成一圈的n阶简单无向图（<spanclass="math inline">\(n\geqslant3\)</span>）</p><p><strong>轮图</strong>：n-1个结点形成一个圈图，且第n个结点与圈图上的每个结点邻接的n阶简单无向图（<spanclass="math inline">\(n\geqslant3\)</span>）</p><p><strong>立方图</strong>：</p><h3 id="图的运算">图的运算</h3><h4 id="同构">同构</h4><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span>，如果存在双射 <span class="math inline">\(f:V\rightarrowV&#39;,g:E\rightarrow E&#39;\)</span> 使得任意 <spanclass="math inline">\(e\in E\)</span> 及 <spanclass="math inline">\(v_1,v_2\in V\)</span> 都有 <spanclass="math inline">\(\Psi&#39;(g(e))=\{f(v_1),f(v_2)\}\)</span> 或<span class="math inline">\(&lt;f(v_1),f(v_2)&gt;\)</span>，则称G与G‘同构，记作 <span class="math inline">\(G\congG&#39;\)</span>，称f与g为G与G’间的同构映射。</p><p>必要条件：结点个数、边数、结点度数相同</p><p>相互同构的图的补图仍相互同构</p><p>当不要求f、g是双射时，称<strong>同态</strong></p><h4 id="子图">子图</h4><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span></p><p><strong>子图</strong>：<span class="math inline">\(V&#39;\subseteqV,E&#39;\subseteq E,\Psi\subseteq\Psi\)</span> ，记为 <spanclass="math inline">\(G&#39;\subseteq G\)</span></p><p><strong>真子图</strong>：<span class="math inline">\(V&#39;\subseteqV,E&#39;\subset E,\Psi\subset\Psi\)</span> ，记为 <spanclass="math inline">\(G&#39;\subset G\)</span></p><p><strong>生成子图</strong>：<spanclass="math inline">\(V&#39;=V,E&#39;\subseteqE,\Psi\subseteq\Psi\)</span></p><p><strong>结点导出子图</strong>： <spanclass="math inline">\(V&#39;\subseteq V,V&#39;\ne\emptyset\)</span>，以V'为结点集合，以所有起点和终点均在V'中的边的全体为边集的G的子图，记为<span class="math inline">\(G[V&#39;]\)</span> 。当 <spanclass="math inline">\(V&#39;\subset V\)</span> 时，导出子图 <spanclass="math inline">\(G[V-V&#39;]\)</span> 记为 <spanclass="math inline">\(G-V&#39;\)</span></p><p><strong>边导出子图</strong>：<spanclass="math inline">\(E&#39;\subseteqE,E&#39;\ne\emptyset,V&#39;=\{v|v\in V且\exists e\inE&#39;使v与e关联\}\)</span> ，记为 <spanclass="math inline">\(G[E&#39;]\)</span></p><h4 id="一些运算">一些运算</h4><h5 id="可运算">可运算</h5><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span>同为无向图或有向图</p><p>若对任意 <span class="math inline">\(e\in E\cap E&#39;\)</span> 均有<span class="math inline">\(\Psi(e)=\Psi&#39;(e)\)</span>，则称G和G‘可运算</p><p>若 <span class="math inline">\(V\cap V&#39;=E\capE&#39;=\emptyset\)</span> ，则称G和G’不相交</p><p>若 <span class="math inline">\(E\cap E&#39;=\emptyset\)</span>，则称G和G’边不相交</p><h5 id="交并环和">交、并、环和</h5><p>设图 <spanclass="math inline">\(G_1=&lt;V_1,E_1,\Psi_1&gt;,G_2=&lt;V_2,E_2,\Psi_2&gt;\)</span>可运算</p><p>交：<span class="math inline">\(G_1\cap G_2=&lt;V_1\cap V_2,E_1\capE_2,\Psi_1\cap\Psi_2&gt;\)</span> 。以 <spanclass="math inline">\(V_1\cap V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\cap E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1,G_2\)</span> 的公共子图。</p><p>并：<span class="math inline">\(G_1\cup G_2=&lt;V_1\cup V_2,E_1\cupE_2,\Psi_1\cup\Psi_2&gt;\)</span> 。以 <spanclass="math inline">\(V_1\cup V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\cup E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1,G_2\)</span> 的公共母图。</p><p>环和：<span class="math inline">\(G_1\oplus G_2=&lt;V_1\cupV_2,E_1\oplus E_2,\Psi_1\cup\Psi_{2E_1\oplus E_2}&gt;\)</span> 。以<span class="math inline">\(V_1\cup V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\oplus E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1\cup G_2\)</span> 的子图。</p><h5 id="边的增删">边的增删</h5><p>删边：设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,E&#39;\subseteq E\)</span> ，记<spanclass="math inline">\(&lt;V,E-E&#39;,\Psi|_{(E-E&#39;)}&gt;\)</span> 为<span class="math inline">\(G-E&#39;\)</span></p><p>增边：设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V,E&#39;,\Psi&#39;&gt;\)</span>同为无向图或有向图，若两图边不想交，且G‘无孤立点，则记 <spanclass="math inline">\(G\cup G&#39;\)</span> 为 <spanclass="math inline">\(G+E&#39;_{\Psi&#39;}\)</span></p><h5 id="补图">补图</h5><p>设n阶无向图 <span class="math inline">\(G=&lt;V,E,\Psi&gt;\)</span>是n阶完全无向图 <span class="math inline">\(K_n\)</span>的生成子图，则称 <span class="math inline">\(K_n-E\)</span>为G的补图，记为 <span class="math inline">\(\bar{G}\)</span></p><p><strong>自补图</strong>：与其补图同构的简单无向图图</p><h3 id="路径">路径</h3><h4 id="基本概念">基本概念</h4><p>设 <span class="math inline">\(n\inN；v_0,v_1,...,v_n；e_1,e_2,...,e_n\)</span> 是图G的结点、边，并且 <spanclass="math inline">\(v_{i-1}\)</span> 和 <spanclass="math inline">\(v_i\)</span> 分别是 <spanclass="math inline">\(e_i\)</span> 的起点和终点，则称序列 <spanclass="math inline">\(v_0e_1v_1e_2...v_{n-1}e_nv_n\)</span> 为图G中从<span class="math inline">\(v_0\)</span> 至 <spanclass="math inline">\(v_n\)</span> 的<strong>路径（链）</strong>， <spanclass="math inline">\(n\)</span> 称该路径的<strong>长度</strong></p><p><span class="math inline">\(v_0=v_n\)</span>，称该路径为<strong>闭</strong>的，否则是<strong>开</strong>的</p><p>边互不相同称<strong>简单路径（迹）</strong>，结点互不相同称<strong>基本路径（路径）</strong></p><p>图中存在从 <span class="math inline">\(v\)</span> 至 <spanclass="math inline">\(v&#39;\)</span> 的路径，则存在从 <spanclass="math inline">\(v\)</span> 至 <spanclass="math inline">\(v&#39;\)</span> 的基本路径</p><p>n阶图中的基本路径长度小于n</p><p>若图G中存在从 <span class="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的路径，则称在G中从 <spanclass="math inline">\(v_1\)</span> <strong>可达</strong> <spanclass="math inline">\(v_2\)</span> ，用 <spanclass="math inline">\(R(v)\)</span> 表示从v可达的全体结点的集合</p><p>若从 <span class="math inline">\(v_1\)</span> 可达 <spanclass="math inline">\(v_2\)</span> ，则称从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的路径中长度最短者为从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span>的<strong>测地线</strong>，该测地线的长度为从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的<strong>距离</strong>，记作 <spanclass="math inline">\(d(v_1,v_2)\)</span> 。不可达则 <spanclass="math inline">\(d(v_1,v_2)=\infty\)</span></p><p>图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>的<strong>直径</strong>定义为 <spanclass="math inline">\(\max_{v,v&#39;\in V}d(v,v&#39;)\)</span></p><p><strong>加权图</strong>：设图 <spanclass="math inline">\(G&lt;V,E,\Psi&gt;\)</span> ，若 <spanclass="math inline">\(W:E\rightarrow R_{+}\)</span> ，则称 <spanclass="math inline">\(&lt;G,W&gt;\)</span> 为加权图。</p><p>边 <span class="math inline">\(e\in E\)</span> ，称 <spanclass="math inline">\(W(e)\)</span>为e的<strong>加权长度</strong>，路径中所有边的加权长度之和为该路径的加权长度，类似有最短路径、加权距离</p><h4 id="连通性">连通性</h4><h6 id="无向图">无向图</h6><p>若图G的任意两个结点都相互可达，则称G是<strong>连通</strong>的</p><p>连通的充分条件：n阶简单无向图任意两个结点的度数之和大于等于n-1</p><p><strong>极大子图</strong>：设G‘是图G的具有某性质P的子图，并且对于G的具有该性质的任意子图G’‘，只要有<span class="math inline">\(G&#39;\subseteq G&#39;&#39;\)</span> ，就有<span class="math inline">\(G&#39;=G&#39;&#39;\)</span>，则称G'相对于该性质是G的极大子图</p><p>无向图G的极大连通子图称G的<strong>连通分支</strong>，简称<strong>分支</strong></p><h6 id="有向图">有向图</h6><p><strong>基础图</strong>：设有向图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> ，定义 <spanclass="math inline">\(\Psi&#39;:E\rightarrow\{\{v_1,v_2\}|v_1\in V\landv_2\in V\}\)</span> 使得对任意 <span class="math inline">\(e\inE\)</span> 和 <span class="math inline">\(v_1,v_2\in V\)</span> ，若<span class="math inline">\(\Psi(e)=&lt;v_1,v_2&gt;\)</span> ，则 <spanclass="math inline">\(\Psi&#39;(e)=\{v_1,v_2\}\)</span> 。称 <spanclass="math inline">\(G&#39;=&lt;V,E,\Psi&#39;&gt;\)</span>为有向图G的基础图</p><p>若有向图G中任意两个结点都相互可达，则称G是<strong>强连通</strong>的</p><p>若对于G任意两结点，必有一结点可达另一结点，则称G是<strong>单向连通</strong>的</p><p>若G的基础图是连通的，则称G是<strong>弱连通</strong>的</p><p>G的极大强/单向/弱连通子图称G的<strong>强/单向/弱分支</strong></p><h4 id="回路">回路</h4><p>设G’是有向图G的基础图，则G‘中的路径称G中的<strong>半路径</strong></p><p>设 <span class="math inline">\(v_0e_1v_1...v_{m-1}e_mv_m\)</span>是G中的半路径，对每个 <span class="math inline">\(i(1\leqslanti\leqslant m)\)</span> ，若 <spanclass="math inline">\(\Psi(e_i)=&lt;v_{i-1},v_i&gt;\)</span> 则称 <spanclass="math inline">\(e_i\)</span>是该半路径中的<strong>正向边</strong>，若 <spanclass="math inline">\(\Psi(e_i)=&lt;v_i,v_{i-1}&gt;\)</span> 则称 <spanclass="math inline">\(e_i\)</span>是该半路径中的<strong>反向边</strong></p><p><strong>回路</strong>：连通2度正则图</p><p><strong>半回路</strong>：基础图是回路的有向图</p><p><strong>有向回路</strong>：每个结点的出度和入度均为1的弱连通有向图</p><p>回路中边的数目称为回路的<strong>长度</strong></p><p>若回路（有向回路，半回路）C是图G的子图，则称G有回路C</p><p>有向图G有有向回路的充分条件：图G有子图G’使得对G‘的任意结点v，都有<span class="math inline">\(d_{G&#39;}^{+}&gt;0\)</span> 或都有 <spanclass="math inline">\(d_{G&#39;}^{+}&lt;0\)</span></p><p><strong>非循环图</strong>：没有回路的无向图和没有半回路的有向图</p><p>图G不是非循环图 <span class="math inline">\(\Leftrightarrow\)</span>G有子图G‘使得对于G'的任意结点v，都有 <spanclass="math inline">\(d_{G&#39;}(v)&gt;1\)</span></p><h4 id="割集与连通度">割集与连通度</h4><p>设无向图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>为连通图，若有点集 <span class="math inline">\(V_1\subset V\)</span>使得</p><ol type="1"><li>图G删除了 <span class="math inline">\(V_1\)</span>的所有结点后，所得子图是不连通图</li><li>图G删除了 <span class="math inline">\(V_1\)</span>的任意真子集后，所得子图仍是连通图</li></ol><p>则称 <span class="math inline">\(V_1\)</span>是G的一个<strong>点割集</strong>，某点构成一个点割集则称该点为<strong>割点</strong></p><p><span class="math inline">\(k(G)=\min\{|V_1|V_1是G的点割集\}\)</span>是G的<strong>（点）连通度</strong></p><p>设无向图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>为连通图，若有边集 <span class="math inline">\(E_1\subset E\)</span>使得</p><ol type="1"><li>图G删除了 <span class="math inline">\(E_1\)</span>的所有边后，所得子图是不连通图</li><li>图G删除了 <span class="math inline">\(E_1\)</span>的任意真子集后，所得子图仍是连通图</li></ol><p>则称 <span class="math inline">\(E_1\)</span>是G的一个<strong>边割集</strong>，某边构成一个边割集则称该点为<strong>割边（桥）</strong></p><p><spanclass="math inline">\(\lambda(G)=\min\{|E_1|E_1是G的边割集\}\)</span>是G的<strong>边连通度</strong></p><h3 id="欧拉图">欧拉图</h3><p>图G中包含其所有边的简单开路径成为G的<strong>欧拉路径</strong>，简单闭路径为<strong>欧拉闭路</strong></p><p><strong>欧拉图</strong>：每个结点都是偶节点的无向图</p><p><strong>欧拉有向图</strong>：每个结点的出度与入度都相等的有向图</p><p>若G是连通无向图，则G是欧拉图当且仅当G有欧拉闭路；若G不连通，则G是欧拉图当且仅当G的每个分支都有欧拉闭路。</p><p>连通无向图有一条从 <span class="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的欧拉路径当且仅当G恰有两个奇结点<span class="math inline">\(v_1\)</span> 和 <spanclass="math inline">\(v_2\)</span></p><p>若 <span class="math inline">\(G_1\)</span> 和 <spanclass="math inline">\(G_2\)</span> 是可运算欧拉图，则 <spanclass="math inline">\(G_1\oplus G_2\)</span>是欧拉图。但有向欧拉图的环和不一定是欧拉图</p><h3 id="哈密顿图">哈密顿图</h3><p>图G中包含它的所有结点的基本路径成为G的<strong>哈密顿路径</strong>，若回路（有向回路）C是图G的生成子图，则称C为G的<strong>哈密顿回路</strong></p><p><strong>哈密顿图（哈密顿有向图）</strong>：有哈密顿回路的图</p><p>有哈密顿回路的必要条件：</p><ol type="1"><li>用黑白两种颜色给图中点着色，使相邻点颜色不同，若能染色且黑白结点个数不同，则无哈密顿回路。数目相差大于1，则无哈密顿路径</li><li>设 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>是哈密顿图，则对V的任意非空真子集 <spanclass="math inline">\(v_1\)</span> 有 <spanclass="math inline">\(W(G-V_1)\leqslant|V_1|\)</span> 。其中 <spanclass="math inline">\(W(G-V_1)\)</span> 为 <spanclass="math inline">\(G-V_1\)</span>的分支个数。即删掉的点的个数应当大于等于剩下部分的分支数。</li><li>哈密顿图不存在悬挂边或孤立点</li></ol><p>哈密顿图的充分条件：</p><ol type="1"><li>欧尔定理：设G是一个n阶简单图(n&gt;1)，若G中任意一对顶点u和v，都满足<span class="math inline">\(d_G(u)+d_G(v)\geqslant n-1\)</span>，则G中存在哈密顿路径</li><li>设G是一个n阶简单图(n&gt;2)，若G中任意一对顶点u和v，都满足 <spanclass="math inline">\(d_G(u)+d_G(v)\geqslant n\)</span>，则是哈密顿图</li></ol><p>中国邮递员问题：给定一个连通图G，每边有非负权，求一条回路经过每条边至少一次且总权最小</p><h3 id="图的表示">图的表示</h3><h4 id="邻接矩阵">邻接矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> ，定义G的邻接矩阵<span class="math inline">\(X(G)\)</span> 为 <spanclass="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\((x_{ij})\)</span> ，其中 <spanclass="math inline">\(x_{ij}\)</span> 为分别以 <spanclass="math inline">\(v_i\)</span> 和 <spanclass="math inline">\(v_j\)</span> 为起点和终点的边的数目。</p><p>若两图同构，则边边互换、对应列再互换后，邻接矩阵相同</p><ul><li>无向图的邻接矩阵对称</li><li>简单图元素均为0或1，对角线元素为0</li><li>零图即零矩阵</li><li>无向图有k个分支则可矩阵分块后对角线有k个1矩阵？</li><li>记图G的邻接矩阵X的m次幂后的元素为 <spanclass="math inline">\(x_{ij}^{(m)}\)</span> ，则它表示 <spanclass="math inline">\(v_i\)</span> 到 <spanclass="math inline">\(v_j\)</span> 的长度为m的路径数</li></ul><h4 id="路径矩阵">路径矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span>，定义G的路径矩阵（可达性矩阵） <spanclass="math inline">\(X(G)\)</span> 为 <spanclass="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\(P=(p_{ij})\)</span> ，其中 <spanclass="math inline">\(p_{ij}=\begin{cases}1\ \ 从v_i可达v_j\\0\ \从v_i不可达v_j\end{cases}\)</span></p><h4 id="距离矩阵">距离矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> ，定义G的邻接矩阵为<span class="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\(D=(d_{ij})\)</span> ，其中 <spanclass="math inline">\(d_{ij}\)</span> 为分别从 <spanclass="math inline">\(v_i\)</span> 至 <spanclass="math inline">\(v_j\)</span> 的距离。</p><h4 id="关联矩阵">关联矩阵</h4><p>设无自圈的n阶<strong>无向图</strong>G的结点集和边集分别为为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> 和 <spanclass="math inline">\(\{e_1,e_2,...,e_m\}\)</span> ，定义G的关联矩阵<span class="math inline">\(A(G)\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 矩阵 <spanclass="math inline">\((a_{ij})\)</span> ，其中 <spanclass="math inline">\(a_{ij}=\begin{cases}1,\ e_j与v_i关联\\0,\e_j与v_i不关联\end{cases}\)</span></p><p>设无自圈的n阶<strong>有向图</strong>G的结点集和边集分别为为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> 和 <spanclass="math inline">\(\{e_1,e_2,...,e_m\}\)</span> ，定义G的关联矩阵<span class="math inline">\(A(G)\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 矩阵 <spanclass="math inline">\((a_{ij})\)</span> ，其中 <spanclass="math inline">\(a_{ij}=\begin{cases}1,\ v_i是e_j的起点\\-1,\v_i是e_j的终点\\0,\ e_j与v_i不关联\end{cases}\)</span></p><h2 id="树">树</h2><h3 id="无向树">无向树</h3><p><strong>树</strong>：非循环连通无向图</p><p><strong>平凡树</strong>：只有一个顶点的平凡图</p><p>树T中，度数为1的结点称<strong>叶子结点</strong>，度数大于1的结点称<strong>分支结点</strong></p><p>树定义的等价条件（设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> 是n阶无向图）：</p><ol type="1"><li>G连通且非循环</li><li>G连通且 <span class="math inline">\(G-e\)</span> 非连通</li><li>G连通且 <span class="math inline">\(|E|=n-1\)</span></li><li>G非循环且 <span class="math inline">\(|E|=n-1\)</span></li></ol><p><strong>森林</strong>：每个分支都是树的无向图</p><p>若森林F有n个结点，m条边，k个分支，则 <spanclass="math inline">\(m=n-k\)</span></p><p>若树T是无向图G的生成子图，则称T为G的<strong>生成树</strong>。若森林F是无向图G的生成子图，则称F为G的<strong>生成森林</strong></p><p>每个无向图均有生成森林，若连通才有生成树</p><p>生成树构造方法：破圈法、</p><p><strong>最小生成树</strong>：连通无向加权图的加权长度最小的生成树</p><p>设T是连通无向图G的生成树，称T的边为<strong>枝</strong>，G的不属于T的边称<strong>弦</strong></p><p>对n阶无向图G，有m条边，任何生成树T，都有 <spanclass="math inline">\(n-1\)</span> 条枝，<spanclass="math inline">\(m-n+1\)</span> 条弦</p><p>若n阶无向图G有m条边和k个分支，则G的<strong>余圈秩</strong> <spanclass="math inline">\(r=n-k\)</span> ，<strong>圈秩</strong> <spanclass="math inline">\(\mu=m-n+k\)</span></p><p>G的只包含一条弦的回路称<strong>基本回路</strong></p><p>设T是连通无向图G的任意生成树，则</p><ol type="1"><li>基本回路的数目等于G的圈秩</li><li>对G的任意回路C，总可以找到若干个基本回路 <spanclass="math inline">\(C_1,C_2,...C_k\)</span> ，使C与 <spanclass="math inline">\(C_1\oplus C_2\oplus...\oplus C_k\)</span>的差别仅在于孤立点</li></ol><h3 id="有向树">有向树</h3><p><strong>有向树</strong>：一个结点的入度为0，其余结点的入度为1的弱连通有向图</p><p>有向树中入度为0的结点称为<strong>根</strong>，出度为0的结点称<strong>叶</strong>，出度大于0为<strong>分支结点</strong>。从根至任意结点的距离称为该结点的<strong>级</strong>，所有结点的级的最大值称有向树的<strong>高度</strong></p><p>设 <span class="math inline">\(v_0\)</span> 是有向图G的结点，则D是以<span class="math inline">\(v_0\)</span> 为根的有向树当且仅当从 <spanclass="math inline">\(v_0\)</span> 到D的任意结点恰有一条路径</p><p><strong>有向森林</strong>：每个弱分支都是有向树的有向图</p><p>若有向树的结点出度的最大值m，则称D为<strong>m元有向树</strong>。每个结点出度均为m或0，则称D为<strong>完全m有向树</strong>。</p><h3 id="二叉树">二叉树</h3><p><strong>二叉树</strong>：完全二元有向树</p><p><strong>叶加权二叉树</strong>：设V是二叉树D的叶的集合， <spanclass="math inline">\(W:V\rightarrow R_{+}\)</span> ，则称 <spanclass="math inline">\(&lt;D,W&gt;\)</span></p><p>对于D的任意v，称W(v)为v的权， <span class="math inline">\(\sum_{v\inV}(W(v)L(v))\)</span>称叶加权二叉树的<strong>叶加全路径长度</strong>，其中 L(v)为v的级</p><p><strong>最优二叉树</strong>：设 <spanclass="math inline">\(&lt;D,W&gt;\)</span>是叶加权二叉树，如果对任一叶加权二叉树 <spanclass="math inline">\(&lt;D&#39;,W’&gt;\)</span>，只要对于任意正实数r，D和D‘中权等于r的叶的数目相同，就有 <spanclass="math inline">\(&lt;D,W&gt;\)</span> 的叶加权路径长度不大于 <spanclass="math inline">\(&lt;D&#39;,W’&gt;\)</span> 的叶加权路径长度，则称<span class="math inline">\(&lt;D,W&gt;\)</span> 为最优的</p><p>哈夫曼的最优二叉树的求解</p><h3 id="有序树">有序树</h3><p><strong>有序树</strong>：每一级上的结点规定了次序的有向树</p><p><strong>有序森林</strong>：有向森林中每个弱分支都规定了次序</p><p><strong>定位有序树</strong>：为每个分支结点的儿子规定了位置的有序树</p><p>若用空字符串表示根，a0表示分支节点a的左儿子，a1表示a的右儿子，则每个结点都有了唯一的编码表示，并且不同结点的编码表示不同。</p><p>定位二元有序树的全体叶的编码表示集合称为它的<strong>前缀编码</strong></p>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大物2笔记</title>
    <link href="/2024/01/14/%E5%A4%A7%E7%89%A92%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E5%A4%A7%E7%89%A92%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h4 id="物理常数">物理常数</h4><p>电子电荷 <span class="math inline">\(e=1.6\times10^{-19}C\)</span>电子质量 <span class="math inline">\(m_e=9.1\times10^{-31}kg\)</span></p><p>普适气体常量 <span class="math inline">\(R=8.31J/(mol·K)\)</span>玻尔兹曼常数 <spanclass="math inline">\(k=\dfrac{R}{N_A}=1.38\times10^{-23}J/K\)</span></p><p>普朗克常数 <span class="math inline">\(h=6.63\times10^{-34}J\cdots\)</span> 约化普朗克常数 <spanclass="math inline">\(\hbar=\dfrac{h}{2\pi}=1.0546\times10^{-34}J\cdots\)</span></p><p>真空介电常数 <spanclass="math inline">\(\varepsilon_0=8.854\times10^{-12}F/m\)</span>真空磁导率 <spanclass="math inline">\(\mu_0=4\pi\times10^{-7}N/A^2\)</span></p><p>万有引力常量 <spanclass="math inline">\(G=6.67\times10^{-11}m^3/(kg\cdot s^2)\)</span></p><h2 id="热学">热学</h2><p>热力学第零定律：分别与第三个系统处于热平衡的两个系统彼此也处于热平衡</p><h3 id="理想气体的参量">理想气体的参量</h3><p>理想气体状态方程：<spanclass="math inline">\(pV=\frac{m}{M}RT\)</span></p><p>*范德瓦尔斯方程：<spanclass="math inline">\((p+\frac{a}{V_m^2})(V_m-b)=RT\)</span></p><p>普适气体常量 <spanclass="math inline">\(R=8.31J/(mol·K)\)</span>，玻尔兹曼常数 <spanclass="math inline">\(k=\dfrac{R}{N_A}=1.38\times10^{-23}J/K\)</span></p><p><strong>压缩气体需要力，不说明分子间存在斥力</strong></p><p>理想气体压强：<spanclass="math inline">\(p=\frac{1}{3}nm\bar{v^2}=\frac{2}{3}n\bar{E_k}=nkT\)</span>，其中<spanclass="math inline">\(\bar{E_k}=\frac{1}{2}m\bar{v^2}\)</span>，n为分子数密度</p><p>理想气体温度：<spanclass="math inline">\(\bar{E_k}=\frac{3}{2}kT\)</span></p><p>能量按自由度均分定理：温度为T的平衡态下，物质分子的每一自由度都具有相同的平均动能<span class="math inline">\(E_k=\frac{1}{2}kT\)</span>，一个分子的平均平动动能为 <spanclass="math inline">\(\bar{E_k}=\frac{1}{2}m\bar{v^2}\)</span></p><p>理想气体的内能：<spanclass="math inline">\(E=\dfrac{m}{M}\dfrac{i}{2}RT\)</span></p><h3 id="麦克斯韦速率分布律">麦克斯韦速率分布律</h3><p>速率分布函数（可类比概率密度函数）：<spanclass="math inline">\(f(v)=\lim\limits_{\Delta v\to0}\dfrac{\DeltaN}{N\Delta v}=\dfrac{dN}{Ndv}=4\pi(\dfrac{m}{2\pikT})^{\frac{3}{2}}e^{-\tfrac{mv^2}{2kT}}v^2\)</span></p><p>另有：v附近 <span class="math inline">\(\Delta v\)</span>范围内分子占分子总数的比例 <span class="math inline">\(\dfrac{\DeltaN}{N}=f(v)\Deltav=\dfrac{4}{\sqrt{\pi}}\dfrac{v^2}{v_p^3}e^{-\tfrac{v^2}{v_p^2}}\Deltav\)</span></p><p>归一化条件：<spanclass="math inline">\(\int_0^{\infty}f(v)dv=1\)</span></p><p>最概然速率：<spanclass="math inline">\(v_p=\sqrt{\dfrac{2kT}{m_0}}\)</span></p><p>方均根速率：<spanclass="math inline">\(\sqrt{\bar{v^2}}=\sqrt{\dfrac{3kT}{m_0}}=\sqrt{\dfrac{3RT}{M}}\)</span></p><p>平均速率：<spanclass="math inline">\(\bar{v}=\int_0^{\infty}vf(v)dv=\sqrt{\dfrac{8kT}{\pim_0}}\)</span></p><p>平均碰撞频率：<span class="math inline">\(\bar{Z}=Vn=\pid^2\bar{v_r}n=\sqrt{2}\pi d^2\bar{v}n\)</span>，其中 <spanclass="math inline">\(\bar{v_r}\)</span>是平均相对速率，d是分子碰撞时中心间距，n是分子数密度</p><p>分子平均自由程：<spanclass="math inline">\(\bar{\lambda}=\dfrac{\bar{v}}{\bar{Z}}=\dfrac{1}{\sqrt{2}\pid^2n}=\dfrac{kT}{\sqrt{2}\pi d^2p}\)</span></p><p><strong>速率在v1和v2之间的分子的平均速率不是 <spanclass="math inline">\(\int_{v_1}^{v_2}vf(v)dv\)</span>，而是 <spanclass="math inline">\(\dfrac{\int_{v_1}^{v_2}vf(v)dv}{\int_{v_1}^{v_2}f(v)dv}\)</span></strong></p><p>分子数密度按势能分布： <spanclass="math inline">\(n=n_0e^{-\tfrac{E_p}{kT}}\)</span></p><p>等温气压公式：<spanclass="math inline">\(p=p_0e^{-\tfrac{mgh}{kT}}\)</span></p><h3 id="近平衡态的运输现象">*近平衡态的运输现象</h3><p>粘滞力：<span class="math inline">\(f=\pm \eta\frac{dv}{dx}\DeltaS\)</span>，其中 <span class="math inline">\(\frac{dv}{dx}\)</span>为速度梯度，动力粘度 <spanclass="math inline">\(\eta=\frac{1}{3}\rho\bar{v}\bar{\lambda}\)</span></p><p>热传导：<span class="math inline">\(\frac{\Delta Q}{\Deltat}=-\kappa\frac{dT}{dx}\Delta S\)</span> ，热导率 <spanclass="math inline">\(\kappa=\frac{1}{3}\frac{C_{v,m}}{M}\rho\bar{v}\bar{\lambda}\)</span></p><p>扩散现象：<span class="math inline">\(\frac{\Delta m}{\Deltat}=-D\frac{d\rho}{dx}\Delta S\)</span>，扩散系数 <spanclass="math inline">\(D=\frac{1}{3}\bar{v}\bar{\lambda}\)</span></p><h3 id="热力学过程">热力学过程</h3><p>热力学第一定律：设外界对系统传递热量Q，系统对外做功A，系统内能为E，则<span class="math inline">\(Q=E_2-E_1+A\)</span></p><p>摩尔热容 <spanclass="math inline">\(C_m=\dfrac{dQ}{\frac{m}{M}dT}\)</span>，即一摩尔物质变化单位温度所需的热量</p><p>计算思路：气体做功可用 <span class="math inline">\(\int pdV\)</span>，内能变化可用 <span class="math inline">\(\DeltaE=\dfrac{i}{2}\dfrac{m}{M}R\Delta T\)</span> ，热量可用 <spanclass="math inline">\(\Delta Q=C_m\dfrac{m}{M}\Delta T\)</span>。除此之外还可利用热力学第一定律间接计算</p><h4 id="等体过程">等体过程</h4><p>条件：<span class="math inline">\(dV=0\RightarrowA=0,Q=E_2-E_1\)</span></p><p>摩尔定容热容：<span class="math inline">\(C_{v,m}=\dfrac{\deltaQ_v}{\frac{m}{M}dT}=\dfrac{i}{2}R\)</span></p><p><span class="math inline">\(dE=\frac{m}{M}C_{v,m}dT\)</span></p><h4 id="等压过程">等压过程</h4><p><span class="math inline">\(dp=0\Rightarrow A=p\DeltaV,Q_p=E_2-E_1+\frac{m}{M}R(T_2-T_1)\)</span></p><p>摩尔定压热容：<span class="math inline">\(C_{p,m}=\dfrac{\deltaQ_p}{\frac{m}{M}dT}=C_{v,m}+R\)</span></p><p>摩尔热容比：<spanclass="math inline">\(\gamma=\dfrac{C_{p,m}}{C_{v,m}}=\dfrac{i+2}{i}\)</span></p><h4 id="等温过程">等温过程</h4><p><span class="math inline">\(dT=0\Rightarrow \DeltaE=0,Q_T=A=\int_{V_1}^{V_2}pdV=p_1V_1\ln\frac{p_1}{p_2}=p_1V_1\ln\frac{V_2}{V_1}\)</span></p><h4 id="绝热过程">绝热过程</h4><p><span class="math inline">\(\delta Q=0\RightarrowdE+pdV=0\)</span>，据此可推出绝热过程方程：</p><p><spanclass="math inline">\(pV^{\gamma}=C_1,V^{\gamma-1}T=C_2,p^{\gamma-1}T^{-\gamma}=C_3\)</span></p><p>其中 <span class="math inline">\(C_1,C_2,C_3\)</span> 均为常量，<spanclass="math inline">\(\gamma\)</span> 为摩尔热容比</p><h3 id="循环过程">循环过程</h3><p>系统经某一过程后又回到初始状态称循环过程，若循环过程每一分过程均为准静态，则可用p-V图表示且为一闭合曲线。曲线方向顺时针为正循环、热机，逆时针为逆循环、制冷机</p><p>热机效率：<spanclass="math inline">\(\eta=\dfrac{A}{Q_1}=\dfrac{Q_1-Q_2}{Q_1}=1-\dfrac{Q_2}{Q_1}\)</span></p><p>一般的热机效率 <spanclass="math inline">\(\eta=\dfrac{W_{循环}}{Q_{总吸}}\)</span></p><p>制冷系数：<spanclass="math inline">\(w=\dfrac{Q_2}{A}=\dfrac{Q_2}{Q_1-Q_2}\)</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是从高温热源吸收的热量， <span class="math inline">\(Q_2\)</span>是向低温热源放出的热量， <span class="math inline">\(A\)</span>是对外界做的功</p><p>热力学第三定律：不可能通过有限的过程使物体冷却到绝对零度</p><h4 id="卡诺循环">卡诺循环</h4><p>在两温度恒定的热源之间工作的循环过程，工质只与热源交换能量</p><p><spanclass="math inline">\(\eta_c=1-\dfrac{T_2}{T_1},w_c=\dfrac{T_2}{T_1-T_2}\)</span></p><h3 id="熵">熵</h3><p>热力学第二定律：</p><ul><li><p>开尔文表述：不可能从单一热源取热，把它全部变为功而不产生其他任何影响</p></li><li><p>克劳修斯表述：热不可能自发地从低温物体传至高温物体</p></li></ul><p>可逆过程：若过程 <span class="math inline">\(A\rightarrowB\)</span>，存在另一过程 <span class="math inline">\(B\rightarrowA\)</span>，且周围一切各自回复原状，称可逆过程</p><p>卡诺定理：</p><ol type="1"><li><p>同样高低温热源之间工作的一切可逆机，效率都等于 <spanclass="math inline">\(1-\dfrac{T_2}{T_1}\)</span></p></li><li><p>同样高低温热源之间工作的不可逆机效率 <spanclass="math inline">\(\eta\leqslant1-\dfrac{T_2}{T_1}\)</span></p></li></ol><p>熵：<span class="math inline">\(S_2-S_1=\int_1^2\dfrac{\deltaQ}{T},\delta S=\dfrac{\delta Q}{T}\)</span> ，可逆过程熵变为0 <spanclass="math inline">\(\oint\dfrac{\delta Q}{T}=0\)</span></p><p>设系统状态所包含的微观状态数为W，则有 <spanclass="math inline">\(S=k\ln W\)</span>，其中k为玻尔兹曼常量</p><h2 id="振动">振动</h2><h3 id="简谐振动">简谐振动</h3><p>方程：<spanclass="math inline">\(\dfrac{d^2x}{dt^2}=\dfrac{F}{m}=-\dfrac{k}{m}x\)</span>，设<span class="math inline">\(\omega^2=\dfrac{k}{m}\)</span>，则有 <spanclass="math inline">\(\dfrac{d^2x}{dt^2}=-\omega^2x\)</span>，解得 <spanclass="math inline">\(x=A\cos(\omega t+\phi_0)\)</span></p><p>特征量：</p><ul><li><p>振幅 <spanclass="math inline">\(|A|=\sqrt{x_0^2+\dfrac{v_0^2}{\omega^2}}\)</span></p></li><li><p>初相 <spanclass="math inline">\(\phi_0=\arctan(-\dfrac{v_0}{\omegax_0})\)</span></p></li><li><p>周期 <spanclass="math inline">\(T=\dfrac{2\pi}{\omega}=2\pi\sqrt{\dfrac{m}{k}}\)</span></p></li><li><p>总能量 <spanclass="math inline">\(E=\frac{1}{2}kA^2\)</span></p></li></ul><p>常见举例：</p><ul><li><p>单摆：<span class="math inline">\(\theta=\theta_m\cos(\omegat+\phi_0)\)</span> <spanclass="math inline">\(T=2\pi\sqrt{\dfrac{l}{g}}\)</span> <spanclass="math inline">\(-mg\sin\theta=ml\dfrac{d^2\theta}{dt^2}\)</span></p></li><li><p>复摆：<span class="math inline">\(\theta=\theta_m\cos(\omegat+\phi_0)\)</span> <spanclass="math inline">\(T=2\pi\sqrt{\dfrac{J}{mgh}}\)</span> <spanclass="math inline">\(-mgh\theta=J\dfrac{d^2\theta}{dt^2}\)</span>，其中h是质心到定轴的距离</p></li></ul><h3 id="其他振动">其他振动</h3><h4 id="阻尼振动">阻尼振动</h4><p><span class="math inline">\(f=-\mu v\)</span> ，<spanclass="math inline">\(\mu\)</span> 为阻力系数。设 <spanclass="math inline">\(\dfrac{\mu}{m}=2\delta\)</span> （<spanclass="math inline">\(\delta\)</span>为阻尼系数），则有</p><p>弱阻尼：<spanclass="math inline">\(\delta^2&lt;\omega_0^2,x=Ae^{-\deltat}\cos(\sqrt{\omega_0^2-\delta^2}t+\phi)\)</span></p><p>临界阻尼：<spanclass="math inline">\(\delta^2=\omega_0^2,x=(A+Bt)e^{-\deltat}\)</span></p><p>过阻尼：<spanclass="math inline">\(\delta^2&gt;\omega_0^2,x=Ce^{-(\delta-\sqrt{\delta^2-\omega_0^2})t}+De^{-(\delta+\sqrt{\delta^2-\omega_0^2})t}\)</span></p><h4 id="受迫振动">受迫振动</h4><p><span class="math inline">\(F=F_0\cos wt\)</span></p><p><span class="math inline">\(x=A_0e^{-\deltat}\cos(\sqrt{\omega_0^2-\delta^2}t+\phi_0^{&#39;})+A\cos(\omegat+\phi)\)</span> ，一段时间后为 <spanclass="math inline">\(x=A\cos(\omega t+\phi)\)</span> ，其中 <spanclass="math inline">\(A=\dfrac{F_0}{m\sqrt{(\omega_0^2-\omega^2)^2+4\delta^2\omega^2}}\)</span>，<spanclass="math inline">\(\tan\phi=-\dfrac{2\delta\omega}{\omega_0^2-\omega^2}\)</span></p><h4 id="电磁震荡">*电磁震荡</h4><h3 id="一维振动的合成">一维振动的合成</h3><p>同频率：</p><ol type="1"><li><p><span class="math inline">\(x_1=A_1\cos(\omegat+\phi_{01}),x_2=A_2\cos(\omega t+\phi_{02})\Rightarrow x=A\cos(\omegat+\phi_0)\)</span> ，其中</p><p><spanclass="math inline">\(A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos(\phi_{01}-\phi_{02})},\tan\phi_0=\dfrac{A_1\sin\phi_{01}+A_2\sin\phi_{02}}{A_1\cos\phi_{01}+A_2\cos\phi_{02}}\)</span></p></li><li><p><span class="math inline">\(x_i=A\cos[\omegat+(i-1)\phi_0]\Rightarrow\sum\limits_{i=1}^nx_i=A\dfrac{\sin{\frac{n\phi_0}{2}}}{\sin{\frac{\phi_0}{2}}}\cos(\omegat+\frac{n-1}{2}\phi_0)\)</span></p></li></ol><p>不同频率：</p><p><span class="math inline">\(x_1=A_1\cos(\omegat+\phi_{01}),x_2=A_2\cos(\omega t+\phi_{02})\)</span></p><p>当 <spanclass="math inline">\(A_1=A_2=A,\phi_{01}=\phi_{02}=\phi_0\)</span>，有<spanclass="math inline">\(x=2A\cos(\dfrac{\omega_2-\omega_1}{2}t)\cos(\dfrac{\omega_2+\omega_1}{2}t+\phi_0)\)</span></p><p>当上式满足 <spanclass="math inline">\(|\omega_1-\omega_2|&lt;&lt;\omega_1或\omega_2\)</span>，振幅随时间缓慢变化，变化频率即拍频<spanclass="math inline">\(=|\dfrac{\omega_1-\omega_2}{2\pi}|=|\nu_1-\nu_2|\)</span>称拍频</p><h2 id="波">波</h2><h3 id="介质的形变及其模量">介质的形变及其模量</h3><ol type="1"><li><p>线变：设柱体长l，截面面积S，两端受力F，则 <spanclass="math inline">\(\dfrac{F}{S}=E\dfrac{\Deltal}{l}\)</span>。即线应变正比于正应力，其中 <spanclass="math inline">\(E\)</span> 称为弹性模量（杨氏模量）</p></li><li><p>体变：设体积V，压强p，则有 <span class="math inline">\(\Deltap=-K\dfrac{\Delta V}{V}\)</span> ，其中K为体积模量</p></li><li><p>切变：<span class="math inline">\(\dfrac{F}{S}=G\theta\)</span>，其中G为切变模量</p></li></ol><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">绳索</th><th style="text-align: center;">固体（横波）</th><th style="text-align: center;">固体（纵波）</th><th style="text-align: center;">流体（纵波）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">波速</td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{F}{\rho_1}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{G}{\rho}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{E}{\rho}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{K}{\rho}}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(\rho_1\)</span> 是线密度，<spanclass="math inline">\(\rho\)</span> 为密度</p><h3 id="波的特征描述与波函数">波的特征描述与波函数</h3><p>波长 <spanclass="math inline">\(\lambda\)</span>：同一波线上两个相邻的、相位差为<span class="math inline">\(2\pi\)</span> 的质元之间的距离</p><p>周期 <span class="math inline">\(T\)</span>：波前进一个波长的时间</p><p>波速 <spanclass="math inline">\(u\)</span>：单位时间内振动状态传播的距离</p><p>角频率 <spanclass="math inline">\(\omega=2\pi\nu=\dfrac{2\pi}{T}\)</span></p><p>角波数、空间角频率：<spanclass="math inline">\(k=\dfrac{2\pi}{\lambda}\)</span>，表示单位长度上波的相位的变化</p><p>满足 <spanclass="math inline">\(u=\dfrac{\lambda}{T}=\nu\lambda\)</span></p><p>波函数：<spanclass="math inline">\(\xi(\vec{r},t)=f(\vec{r},t)=f(x,y,z,t)\)</span></p><p>平面简谐波：<spanclass="math inline">\(y(x,t)=A\cos[\omega(t-\frac{x}{u})+\phi_0]\)</span>，表示振幅为A、波速为u、波源初相 <spanclass="math inline">\(\phi_0\)</span>、波线上距原点为x、时间t时的振动方程</p><p>平面波的波动方程：<spanclass="math inline">\(\dfrac{\partial^2y}{\partialx^2}=\dfrac{1}{u^2}\dfrac{\partial^2y}{\partial t^2}\)</span></p><p>球面波：<spanclass="math inline">\(\xi=\dfrac{A_0r_0}{r}\cos[\omega(t-\frac{r}{u})-\phi_0]\)</span>，振幅和离开波源的距离成反比</p><h3id="波的能量与强度声压声强与分贝">波的能量与强度、声压声强与分贝</h3><p>在弦线中 <span class="math inline">\(x\)</span> 处取线元 <spanclass="math inline">\(\Delta x\)</span> 、线密度 <spanclass="math inline">\(\rho_l\)</span> 、张力 <spanclass="math inline">\(F\)</span>，则有</p>$$<span class="math display">\[\begin{aligned}\Delta E_k&amp;=\frac{1}{2}\rho_l\Delta x(\frac{\partial y}{\partialt})^2\\\Delta E_p&amp;=\frac{1}{2}F\Delta x(\frac{\partial y}{\partial x})^2\end{aligned}\]</span><p>$$</p><p>代入 <span class="math inline">\(u=\sqrt{\dfrac{F}{\rho_l}}\)</span>得 <span class="math inline">\(\Delta E_k=\DeltaE_p=\frac{1}{2}\rho_lA^2\omega^2\Deltax\sin^2[\omega(t-\frac{x}{u})+\phi_0]\)</span>，即质元的动能与势能相等且同相位变化（<strong>与单一的简谐振动不同！</strong>）</p><p>波的能量密度 <span class="math inline">\(w=\dfrac{\Delta E}{S\Deltax}=\rho_lA^2\omega^2\sin^2[\omega(t-\frac{x}{u})+\phi_0]\)</span></p><p>平均能量密度 <span class="math inline">\(\bar{w}=\frac{1}{2}\rhoA^2\omega^2\)</span></p><p>平均能流（单位时间内通过介质中某截面S的波动能量）：<spanclass="math inline">\(\bar{P}=\bar{w}uS\)</span></p><p>平均能流密度（声强）：<spanclass="math inline">\(I=\bar{w}u=\frac{1}{2}\rho_lu\omega^2A^2=\frac{1}{2}Z\omega^2A^2\)</span>，单位 <span class="math inline">\(W/m^2\)</span> ，其中 <spanclass="math inline">\(Z=\rho_lu\)</span> 称特性阻抗</p><p>声压：<span class="math inline">\(p=-\rho\omegauA\sin[\omega(t-\frac{x}{u})+\phi_0]\)</span> ，记 <spanclass="math inline">\(p_m=\rho u\omega A\)</span> ，称声压振幅</p><p>声强级（分贝）：<spanclass="math inline">\(I_L=10\lg\dfrac{I}{I_0}\)</span> ，其中 <spanclass="math inline">\(I_0=10^{-12}W/m^2\)</span> ，是人类听觉下限</p><h3 id="电磁波">*电磁波</h3><h3 id="波的谜之操作">波的谜之操作</h3><h4 id="理论基础">理论基础</h4><p>惠更斯原理：介质中任一波面上的各点，都可看成是产生球面子波的波源；在其后的任一时刻，这些子波的包络面构成新的波面。</p><p>波的叠加原理：在几列波相遇的区域内，任一质元振动的位移是各列波单独传播时在该点引起的位移的矢量和。</p><h4 id="反射与折射">反射与折射</h4><p>类似光</p><h4 id="衍射">衍射</h4><p>波传播过程中当遇到障碍物时，能绕过障碍物发生偏折的现象</p><h4 id="干涉">干涉</h4><p>两列波在空间相遇叠加，结果在空间的某些地方振动始终加强，而在空间的另一些地方振动始终减弱或完全消失的现象。</p><p>相干波：能产生干涉现象的波</p><p>相干条件：两列波频率相同、振动方向相同、相位差恒定</p><p>设有两相干源 <span class="math inline">\(S_1\)</span> ，<spanclass="math inline">\(S_2\)</span> ，波在距波源为 <spanclass="math inline">\(r_1\)</span> ，<spanclass="math inline">\(r_2\)</span> 的 <spanclass="math inline">\(P\)</span> 点相遇，波动方程分别为</p>$$<span class="math display">\[\begin{aligned}y_1&amp;=A_1\cos(\omega t+\phi_{01}-\frac{2\pi r_1}{\lambda})\\y_2&amp;=A_2\cos(\omega t+\phi_{02}-\frac{2\pi r_2}{\lambda})\end{aligned}\]</span><p>$$</p><p>则有</p>$$<span class="math display">\[\begin{aligned}y_1+y_2&amp;=A\cos(\omega t+\phi_0)\\\Delta\phi&amp;=\phi_{02}-\phi_{01}-2\pi\frac{r_2-r_1}{\lambda}\\A&amp;=\sqrt{A_1^2+A_2^2+2A_1A_2\cos\Delta\phi}\\\tan\phi_0&amp;=\dfrac{A_1\sin(\phi_{01}-\frac{2\pir_1}{\lambda})+A_2\sin(\phi_{02}-\frac{2\pir_2}{\lambda})}{A_1\cos(\phi_{01}-\frac{2\pir_1}{\lambda})+A_2\cos(\phi_{02}-\frac{2\pi r_2}{\lambda})}\\I&amp;=I_1+I_2+2\sqrt{I_1I_2}\cos\Delta\phi\end{aligned}\]</span><p>$$</p><h4 id="驻波">驻波</h4><p>两列振幅相同的相干波沿相反方向传播叠加而成</p>$$<span class="math display">\[\begin{aligned}y_1&amp;=A\cos[2\pi(\frac{t}{T}-\frac{x}{\lambda})]\\y_2&amp;=A\cos[2\pi(\frac{t}{T}+\frac{x}{\lambda})]\\y_1+y_2&amp;=2A\cos\frac{2\pi}{\lambda}x\cos\frac{2\pi}{T}t\end{aligned}\]</span><p>$$</p><p>振幅：每个点振幅不变，但不同位置振幅不同。不动的质元称波节，振幅最大的称波腹。相邻的波节、波腹相距<span class="math inline">\(\dfrac{\lambda}{2}\)</span></p><p>相位：同一分段内各点振动相位相同，一个波节的两侧相邻分段内的各振动点反相位</p><p>能量：波节处只有势能，波腹处只有动能</p><h4 id="半波损失">半波损失</h4><p><span class="math inline">\(\rho u\)</span>较大称波密介质，较小称波疏介质。当波从波疏介质向波密介质传播时，入射波在反射点反射时有相位<span class="math inline">\(\pi\)</span> 的突变，称之为半波损失。</p><h3 id="多普勒效应">多普勒效应</h3><p>设观测者相对介质运动速度为 <span class="math inline">\(v_R\)</span>，向波源方向运动取正；波源相对于介质运动速度为 <spanclass="math inline">\(v_S\)</span> ，向观测者方向运动为正；波速为 <spanclass="math inline">\(u\)</span></p><p>设波源的频率为 <span class="math inline">\(\nu_S\)</span>，观测者收到的频率为 <span class="math inline">\(\nu_R\)</span></p><p>则有 <spanclass="math inline">\(\nu_R=\dfrac{u+v_R}{u-v_S}\nu_S\)</span></p><p>*电磁波则化为 <spanclass="math inline">\(\nu_R=\sqrt{\dfrac{c+v}{c-v}}\nu_S\)</span></p><p>*冲击波：波源速度超过波速，马赫数即 <spanclass="math inline">\(\dfrac{u_S}{u}\)</span> ，<spanclass="math inline">\(\sin\alpha=\dfrac{u}{u_S}\)</span></p><h2 id="光学">光学</h2><h3 id="几何光学简介">*几何光学简介</h3><p>直线传播、独立传播、折射与反射定律</p><p><spanclass="math inline">\(\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}\)</span></p><h3 id="光的相干">光的相干</h3><p>光的叠加：<spanclass="math inline">\(I=\dfrac{1}{2}\sqrt{\dfrac{\varepsilon}{\mu}}E_0^2\propto\vec{E}^2,I_P=I_1+I_1+2\sqrt{I_1I_2}\cos[(\phi_1-\phi_2)-\dfrac{\omega(r_1-r_2)}{c}]\)</span></p><p>相干条件：同频率、相位差恒定、光矢量振动方向平行且振幅相差不大</p><p>获得方法：分波阵面法、分振幅法</p><p>光程：真空中为光走过的距离，介质中为发生相同相变需要在真空中走过的距离，即<span class="math inline">\(r&#39;=nr\)</span></p><p>光程差：<span class="math inline">\(\delta\)</span> ，则相位差 <spanclass="math inline">\(\Delta\phi=\dfrac{2\pi}{\lambda}\delta\)</span>，且透镜不改变光程差</p><p>干涉条纹的可见度：<spanclass="math inline">\(V=\dfrac{I_{\max}-I_{\min}}{I_{\max}+I_{\min}}=\dfrac{2\sqrt{\frac{I_2}{I_1}}}{1+\frac{I_2}{I_1}}\)</span></p><h4 id="杨氏干涉实验">杨氏干涉实验</h4><figure><img src="/img/image-20231218094602706.png"alt="image-20231218094602706" /><figcaption aria-hidden="true">image-20231218094602706</figcaption></figure><p><span class="math inline">\(\delta=r_2-r_1\approx d\sin\theta\approxd\dfrac{x}{D},\Delta\phi=\dfrac{2\pi}{\lambda}\delta\)</span></p><p>明纹：<span class="math inline">\(x_{\pm k}=\pmk\dfrac{D}{d}\lambda,k=0,1,2...\)</span></p><p>暗纹：<span class="math inline">\(x_{\pm 2k+1}=\pm(2k+1)\dfrac{D}{d}\lambda,k=0,1,2...\)</span></p><p>相邻明暗条纹间距：<span class="math inline">\(\Deltax=\dfrac{D}{d}\lambda\)</span></p><p>光源线度的约束条件：<spanclass="math inline">\(b&lt;\dfrac{B}{d}\lambda\)</span> ，<spanclass="math inline">\(B\)</span> 是光源到2小孔的板之间的距离</p><h4 id="劳埃德镜实验">劳埃德镜实验</h4><figure><img src="/img/image-20231218105005487.png"alt="image-20231218105005487" /><figcaption aria-hidden="true">image-20231218105005487</figcaption></figure><h4 id="薄膜干涉">薄膜干涉</h4><figure><img src="/img/image-20231218105606726.png"alt="image-20231218105606726" /><figcaption aria-hidden="true">image-20231218105606726</figcaption></figure><p><strong>注意是否有半波损失</strong></p><h4 id="劈尖干涉">劈尖干涉</h4><figure><img src="/img/image-20231218105845796.png"alt="image-20231218105845796" /><figcaption aria-hidden="true">image-20231218105845796</figcaption></figure><p>两相邻明条纹对应的厚度差 <span class="math inline">\(\Deltad=\dfrac{\lambda}{2n_2}\)</span> ，间距 <spanclass="math inline">\(l=\dfrac{\lambda}{2n_2\theta}\)</span></p><h4 id="牛顿环">牛顿环</h4><figure><img src="/img/image-20231218192505501.png"alt="image-20231218192505501" /><figcaption aria-hidden="true">image-20231218192505501</figcaption></figure><p>明纹：<spanclass="math inline">\(r=\sqrt{(2k-1)\dfrac{R\lambda}{2}},k=1,2,3...\)</span></p><p>暗纹：<span class="math inline">\(r=\sqrt{k\lambdaR},k=0,1,2\)</span></p><h4 id="迈克耳孙干涉仪">迈克耳孙干涉仪</h4><figure><img src="/img/image-20231218194701314.png"alt="image-20231218194701314" /><figcaption aria-hidden="true">image-20231218194701314</figcaption></figure><p><span class="math inline">\(M_1\)</span> 平移 <spanclass="math inline">\(\Delta d\)</span> 时，干涉条纹移过N条，则 <spanclass="math inline">\(\lambda=\dfrac{2\Delta d}{N}\)</span></p><h3 id="光的衍射">光的衍射</h3><p>光在传播过程中遇到大小与波长近似的障碍物时，能绕过障碍物，偏离直线传播的现象</p><p>菲涅尔衍射：光源与衍射屏、衍射屏与接收屏为有限远</p><p>夫琅禾费衍射：均为无限远</p><p>惠更斯-菲涅尔原理：从同一波阵面上各点发出的子波都是相干波，在空间某点相遇时，将进行相干叠加</p><figure><img src="/img/image-20231218195431717.png"alt="image-20231218195431717" /><figcaption aria-hidden="true">image-20231218195431717</figcaption></figure><h4 id="夫琅禾费衍射">夫琅禾费衍射</h4><figure><img src="/img/image-20231218195526995.png"alt="image-20231218195526995" /><figcaption aria-hidden="true">image-20231218195526995</figcaption></figure><p>半波带法：若通过缝的光恰能分为偶数个半波带，则全部干涉相消（暗纹），否则为明纹</p><p>暗纹：<spanclass="math inline">\(a\sin\varphi=\pm2k\dfrac{\lambda}{2},k=1,2,3...\)</span>（倾斜入射时为 <spanclass="math inline">\(a(\sin\varphi\pm\sin\theta)\)</span> ）</p><p>明纹：<spanclass="math inline">\(a\sin\varphi=\pm(2k+1)\dfrac{\lambda}{2},k=1,2,3...\)</span></p><p>中央明纹：<span class="math inline">\(\varphi=0\)</span></p><p>角宽度：<spanclass="math inline">\(\Delta\varphi=\dfrac{\lambda}{a}\)</span>，线宽度：<span class="math inline">\(\Deltax_0=f\tan\varphi=f\dfrac{\lambda}{a}\)</span>。中央明纹角宽度、线宽度均为2倍</p><p>光强分布：<spanclass="math inline">\(I_\varphi=I_m(\dfrac{\sin\alpha}{\alpha})^2\)</span>，<span class="math inline">\(I_m\)</span> 为中央明纹中心处的光强，<spanclass="math inline">\(\alpha=\dfrac{\pia\sin\varphi}{\lambda}\)</span></p><h4 id="分辨功能">分辨功能</h4><figure><img src="/img/image-20231218202254866.png"alt="image-20231218202254866" /><figcaption aria-hidden="true">image-20231218202254866</figcaption></figure><h4 id="光栅衍射">光栅衍射</h4><p>光栅：大量等宽等间距的平行狭缝（或反射面）</p><p>a是透光部分的宽度，b是不透光部分的宽度，则光栅常数 <spanclass="math inline">\(d=a+b\)</span></p><p>光栅的夫琅禾费衍射=单缝衍射+多光束干涉</p><p>光栅方程：<span class="math inline">\(d\sin\varphi=\pmk\lambda,k=0,1,2,...\)</span> 主极大明纹</p><p>暗纹：<spanclass="math inline">\(d\sin\varphi=\pm\dfrac{m\lambda}{N},m\nekN\)</span></p><p>明纹缺级：干涉极大但衍射极小，<spanclass="math inline">\(\dfrac{d}{a}=\dfrac{k}{k&#39;}\)</span></p><p>光强：</p><p><span class="math inline">\(\alpha=\dfrac{\beta}{2}=\dfrac{\pia\sin\varphi}{\lambda},\Delta\varphi=\dfrac{2\pi}{\lambda}(a+b)\sin\varphi\)</span>其中 <span class="math inline">\(\varphi\)</span> 含义与单缝衍射相同</p><p>则 <spanclass="math inline">\(I_0=I_m(\dfrac{\sin\alpha}{\alpha})^2(\dfrac{\sin\frac{N\Delta\varphi}{2}}{\sin\frac{\Delta\varphi}{2}})^2\)</span></p><p>光栅的分辨本领：</p><p>把 <span class="math inline">\(\lambda\)</span> 和 <spanclass="math inline">\(\lambda+\Delta\lambda\)</span> 分开的能力，定义为<span class="math inline">\(R=\dfrac{\lambda}{\Delta\lambda}\)</span>，计算得 <span class="math inline">\(R=kN\)</span>，k为主极大级次，N为总缝数</p><h4 id="x射线衍射">X射线衍射</h4><p>布拉格公式 <spanclass="math inline">\(2d\sin\varphi=k\lambda\)</span></p><h3 id="光的偏振">光的偏振</h3><h4 id="原理与分类">原理与分类</h4><p>原理：光矢量 <span class="math inline">\(\vec{E}\)</span>与光的传播方向垂直，但 <span class="math inline">\(\vec{E}\)</span>在与传播方向垂直的平面内可有不同振动方向、状态</p><ul><li><p>线偏振光：光矢量始终沿某一方向振动</p></li><li><p>自然光：各个方向都有大小、前后不同的光矢量的振动，是对称的</p></li><li><p>部分偏振光：自然光的振动可分解为垂直的两个方向，部分移去其中一个矢量</p></li><li><p>圆（椭圆）偏振光：光矢量绕着光的传播方向旋转，旋转角速度对应于光的角频率。可看成2个振动相互垂直、相位差为<span class="math inline">\(\dfrac{\pi}{2}\)</span>的线偏振光的合成</p></li></ul><p>表示方法：</p><figure><img src="/img/image-20231219222339407.png"alt="image-20231219222339407" /><figcaption aria-hidden="true">image-20231219222339407</figcaption></figure><figure><img src="/img/image-20231219222349776.png"alt="image-20231219222349776" /><figcaption aria-hidden="true">image-20231219222349776</figcaption></figure><figure><img src="/img/image-20231219222358180.png"alt="image-20231219222358180" /><figcaption aria-hidden="true">image-20231219222358180</figcaption></figure><h4 id="起偏与检偏">起偏与检偏</h4><h5 id="概念">概念</h5><p>起偏：用起偏器（如偏振片）从自然光获得偏振光</p><p>偏振片：只允许沿某个方向振动的光矢量透过，此方向称偏振化方向</p><p>检偏：分析光的偏振态</p><h5 id="两大定律">两大定律</h5><p>马吕斯定律：</p><p>强度为 <span class="math inline">\(I_0\)</span>的线偏振光，通过检偏振器后，透射光的强度为 <spanclass="math inline">\(I=I_0\cos^2\alpha\)</span> 。其中 <spanclass="math inline">\(\alpha\)</span>为线偏振光的光振动方向与检偏器的偏振化方向的夹角。自然光通过后强度减半。</p><p>自然光反射、折射后产生部分偏振光</p><p>布儒斯特定律：</p><p>当入射角 <span class="math inline">\(i_B\)</span> 与折射角 <spanclass="math inline">\(\gamma\)</span> 满足 <spanclass="math inline">\(i_B+\gamma=90^\circ\)</span>时，反射光为振动方向垂直于入射面的线偏振光。此时入射角称布儒斯特角或起偏角，且有<span class="math inline">\(\tan i_B=\dfrac{n_2}{n_1}\)</span></p><h5 id="产生方法">产生方法</h5><p>玻璃片堆，多次反射、折射后，可使反射光强度较高，且折射光的偏振度足够高</p><h4 id="双折射">双折射</h4><h5 id="概念-1">概念</h5><p>一束光入射到各向异性介质后，出现两束折射光：寻常光（o光）与非常光（e光）。其中o光遵循折射定律而e光不遵循。o光的光矢量振动方向与o光主平面垂直，e光的光矢量振动方向与e光主平面平行，光轴在入射面时，振动方向相互垂直</p><p>光轴：当光沿此方向入射传播时，不发生双折射。可分为单轴晶体、双轴晶体</p><p>主平面：晶体中光的传播方向与光轴构成的平面</p><p>惠更斯解释：光在晶体中的传播速度与光的传播方向（e光）和偏振状态有关。</p><p><span class="math inline">\(n_e&gt;n_o\)</span>称正晶体，反之称负晶体</p><h5 id="一些镜子">一些镜子</h5><p>尼科耳棱镜：方解石切半+加拿大树胶，射出一束振动方向在纸面内的线偏振光</p><p>沃拉斯顿棱镜：两块方解石、光轴方向垂直、斜向拼接，射出两束分开的、振动方向垂直的线偏振光</p><p>波晶片：表面与晶体光轴平行。当线偏振光垂直表面入射时，设 <spanclass="math inline">\(\alpha\)</span> 为振动方向与光轴的夹角，则 <spanclass="math inline">\(E_o=E\sin\alpha,E_e=E\cos\alpha,\delta=|n_o-n_e|d\)</span>。射出两束传播方向相同、振动方向相互垂直、频率相等、相位差恒定的线偏振光。</p><p>光程差为 <span class="math inline">\(\dfrac{1}{4}\lambda\)</span>的称 <span class="math inline">\(\dfrac{1}{4}\)</span>波片，类推有半波片、全波片</p><h5 id="偏振光的干涉">*偏振光的干涉</h5><figure><img src="/img/image-20231221143642279.png"alt="image-20231221143642279" /><figcaption aria-hidden="true">image-20231221143642279</figcaption></figure><p>光强分布：</p><ol type="1"><li><p>自然光到线偏振光，光强变为 <spanclass="math inline">\(\dfrac{1}{2}I_0\)</span> ，振幅为 <spanclass="math inline">\(A_1\)</span></p></li><li><p>波晶片中 <spanclass="math inline">\(A_{1o}=A_1\cos\alpha,A_{1e}=A_1\sin\alpha,\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d\)</span></p></li><li><p>偏振片P2中 <spanclass="math inline">\(A_{2o}=A_{1o}\sin\beta,A_{2e}=A_{1e}\cos\beta,\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi\)</span></p></li></ol><figure><img src="/img/image-20231221144529306.png"alt="image-20231221144529306" /><figcaption aria-hidden="true">image-20231221144529306</figcaption></figure><p>此例中有附加相位差的原因为 <spanclass="math inline">\(\vec{A_{2e}}\)</span> 和 <spanclass="math inline">\(\vec{A_{2o}}\)</span> 方向相反</p><p>屏幕上光强 <span class="math inline">\(I\proptoA^2=A_{2o}^2+A_{2e}^2+2A_{2o}A_{2e}\cos\Delta\varphi\)</span></p><p>干涉相长：<spanclass="math inline">\(\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi=2k\pi\)</span>，其中 <span class="math inline">\(k=1,2,3,...\)</span></p><p>干涉相消：<spanclass="math inline">\(\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi=(2k+1)\pi\)</span>，其中 <span class="math inline">\(k=0,1,2,3,...\)</span></p><h5 id="人为双折射">*人为双折射</h5><p>光弹效应：<span class="math inline">\(|n_o-n_e|=cp\)</span>，c是与材料有关的常数，p为样品材料中的应力</p><p>电光效应：<span class="math inline">\(|n_o-n_e|=kE^2\)</span>，k为液体的克尔常数，E为外加电场的电场强度</p><h5 id="旋光性">*旋光性</h5><p>线偏振光通过某些透明物质时，振动面将以光的传播方向为轴线旋转一定角度<span class="math inline">\(\theta=ad\)</span>。a（旋光率）与物质性质、波长有关，d为厚度</p><h2 id="量子物理">量子物理</h2><h3 id="热辐射与量子假设">热辐射与量子假设</h3><h4 id="辐出度基尔霍夫辐射定律">辐出度、基尔霍夫辐射定律</h4><p>辐出度：物体在温度T下单位表面在单位时间内发出的各种波长的总辐射能，记为<span class="math inline">\(M(T)\)</span> ，单位 <spanclass="math inline">\(W/m^2\)</span></p><p>单色辐出度：一定温度T下，单位时间内从物体表面单位面元上发射的波长在<span class="math inline">\(\lambda\sim\lambda+d\lambda\)</span>内的辐射能 <span class="math inline">\(dM_{\lambda}\)</span> 与波长间隔<span class="math inline">\(d\lambda\)</span> 的比值。<spanclass="math inline">\(M_\lambda(T)=\dfrac{dM_\lambda}{d\lambda}\)</span></p><p>单色吸收比：温度T时，物体吸收波长在 <spanclass="math inline">\(\lambda\sim\lambda+d\lambda\)</span>内的辐射能与相应范围内的入射能之比，介于0和1之间，记为 <spanclass="math inline">\(\alpha(\lambda,T)\)</span>。当值为1时，为黑体。</p><p>热辐射是连续的，频谱分布随温度变化，辐射本领强吸收本领也强</p><p>基尔霍夫辐射定律：处于热辐射平衡态的物体，单色辐出度与单色吸收系数的比值都相等，且等于同温度下黑体的单色辐出度</p><p><spanclass="math inline">\(\dfrac{M_{1\lambda}(T)}{\alpha_1(\lambda,T)}=\dfrac{M_{2\lambda}(T)}{\alpha_2(\lambda,T)}=...=M_{B\lambda}(T)\)</span></p><h4 id="黑体辐射定律">黑体辐射定律</h4><p>斯特藩-玻耳兹曼定律： <spanclass="math inline">\(M_B(T)=\int_0^{\infty}M_{B\lambda}(T)d\lambda=\sigmaT^4\)</span> ，其中 <spanclass="math inline">\(\sigma\approx5.67\times10^{-8}W/(m^2\cdotK^4)\)</span> ，称斯特藩常量</p><p>维恩位移定律：峰值波长 <span class="math inline">\(\lambda_m\)</span>满足 <span class="math inline">\(T\lambda_m=b\)</span>，其中b为维恩常量， <span class="math inline">\(b\approx2.898\times10^{-3}m\cdot K\)</span></p><p>普朗克公式：<span class="math inline">\(M_{B\lambda}(T)=\dfrac{2\pic^2h}{\lambda^5}\dfrac{1}{e^{\tfrac{hc}{\lambda kT}}-1}\)</span>，其中k为玻尔兹曼常量</p><p>量子假说：电磁辐射的能量交换只能是量子化的</p><h3 id="光的粒子性">光的粒子性</h3><h4 id="光电效应">光电效应</h4><p>光电效应：光照射某些金属时，能从表面释放出电子</p><p>遏止电压 <span class="math inline">\(U_a\)</span> ：<spanclass="math inline">\(\dfrac{1}{2}mv_m^2=eU_a\)</span></p><p>遏制频率（红限）：<span class="math inline">\(h\nu_0=W_0\)</span></p><p>爱因斯坦光电效应方程：<spanclass="math inline">\(h\nu=\dfrac{1}{2}mv_m^2+A\)</span></p><h4 id="康普顿散射">康普顿散射</h4><figure><img src="/img/image-20231221182623231.png"alt="image-20231221182623231" /><figcaption aria-hidden="true">image-20231221182623231</figcaption></figure><p><spanclass="math inline">\(\Delta\lambda=\dfrac{h}{m_0c}(1-\cos\varphi)=2\lambda_c\sin^2\dfrac{\varphi}{2}\)</span>，其中 <span class="math inline">\(\lambda_c=\dfrac{h}{m_0c}\)</span>称康普顿波长</p><p>对于光： <spanclass="math inline">\(E=h\nu,p=\dfrac{h}{\lambda},m=\dfrac{h}{c\lambda}\)</span></p><h3 id="波尔氢原子理论">波尔氢原子理论</h3><p>氢原子光谱线系：<spanclass="math inline">\(\dfrac{1}{\lambda}=R(\dfrac{1}{k^2}-\dfrac{1}{n^2}),n=k+1,k+2,...\)</span>其中 <spanclass="math inline">\(R=\dfrac{me^4}{8\varepsilon_0^2h^3c}=1.097373\times10^7m^{-1}\)</span>称里德伯常数，k=2时是巴尔末线系</p><p>波尔理论的基本假设：</p><ol type="1"><li><p>定态假设。原子只能处于一系列不连续的能量状态中</p></li><li><p>频率条件。跃迁时，吸收 <spanclass="math inline">\(\nu_{kn}=\dfrac{|E_n-E_k|}{h}\)</span>能量</p></li><li><p>量子化条件。电子绕核作圆周运动时的角动量L是量子化的，只能取 <spanclass="math inline">\(\hbar=\dfrac{h}{2\pi}\)</span> 的整数倍，其中<span class="math inline">\(\hbar\)</span> 是约化普朗克常量</p></li></ol><p>轨道半径 <spanclass="math inline">\(r_n=n^2\dfrac{\varepsilon_0h^2}{\pime^2}=n^2r_1,n=1,2,3...\)</span></p><p>原子能量 <spanclass="math inline">\(E_n=-\dfrac{e^2}{8\pi\varepsilon_0r_n}=-\dfrac{1}{n^2}\dfrac{me^4}{8\varepsilon_0^2h^2},n=1,2,3...\)</span>，其中 <span class="math inline">\(E_1=-13.6eV\)</span></p><h3 id="德布罗意波不确定性原理">德布罗意波、不确定性原理</h3><p>物质波 <spanclass="math inline">\(\lambda=\dfrac{h}{p}=\dfrac{h}{m_0v}\sqrt{1-\dfrac{v^2}{c^2}}\)</span></p><p>动量-坐标不确定关系 <span class="math inline">\(\Delta x\Deltap_x\geqslant\dfrac{\hbar}{2}\)</span></p><p>能量-时间不确定关系 <span class="math inline">\(\Delta E\Deltat\geqslant\dfrac{\hbar}{2}\)</span>，如原子能级宽度和原子在该能级的平均寿命之间的关系</p><h3 id="波函数与薛定谔方程">波函数与薛定谔方程</h3><h4 id="一堆方程">一堆方程</h4><p>物质波的波函数 <span class="math inline">\(\Psi\)</span> 的模的平方<span class="math inline">\(|\Psi(\vec{r},t)|^2\)</span>代表t时刻，r端点处单位体积中发现一个粒子的概率，称概率密度</p><p>波函数应满足以下要求：</p><ol type="1"><li>有限性：概率为有限值</li><li>归一性：<spanclass="math inline">\(\iiint\limits_\Omega|\Psi(\vec{r},t)|^2dV=1\)</span></li><li>单值性：概率密度在任意位置、时刻都是确定的</li><li>连续性：势场性质与边界条件要求波函数及其一阶导数连续</li></ol><p>状态叠加原理：若体系具有一些列互异的可能状态 <spanclass="math inline">\(\{\Psi_1,\Psi_2...\}\)</span> ，则其线性组合 <spanclass="math inline">\(\Psi=\sum C_n\Psi_n\)</span>也是该体系的一个可能状态</p><p>一维自由粒子的波函数： <spanclass="math inline">\(\Psi(x,t)=\Psi_0e^{-i\frac{1}{\hbar}(Et-px)}\)</span>三维：<spanclass="math inline">\(\Psi(\vec{r},t)=\Psi_0e^{-\frac{i}{\hbar}(Et-\vec{p}\vec{x})}\)</span></p><p>一维自由粒子波函数满足的微分方程：<spanclass="math inline">\(i\hbar\dfrac{\partial\Psi}{\partialt}=-\dfrac{\hbar^2}{2m}\dfrac{\partial^2\Psi}{\partial x^2}\)</span></p><p>势场中 <span class="math inline">\(E=\dfrac{p^2}{2m}+V(x,t)\)</span>，有 <span class="math inline">\(i\hbar\dfrac{\partial\Psi}{\partialt}=-\dfrac{\hbar^2}{2m}\dfrac{\partial^2\Psi}{\partialx^2}+V\Psi\)</span></p><p>当势场与时间无关、粒子能量取定值时，有定态波函数 <spanclass="math inline">\(\Psi(x,t)=\Psi(x)e^{-\frac{i}{\hbar}Et}\)</span>，一维定态薛定谔方程 <spanclass="math inline">\(\dfrac{d^2\psi(x)}{dx^2}+\dfrac{2m}{\hbar^2}(E-V)\psi(x)=0\)</span></p><p>三维定态薛定谔方程 <spanclass="math inline">\(\nabla^2\psi(\vec{r})+\dfrac{2m}{\hbar^2}(E-V)\psi(\vec{r})=0\)</span></p><h4 id="一维无限深势阱">一维无限深势阱</h4><p>势能函数满足 <span class="math inline">\(V(x)=\begin{cases}0,\0&lt;x&lt;a \\ \infty,\ 其他\end{cases}\)</span>，类似金属内部自由电子的运动</p><p>解一维定态薛定谔方程得 <spanclass="math inline">\(E_n=\dfrac{h^2}{8ma^2}n^2,\ n=1,2,3,...\)</span>其中 <span class="math inline">\(E_1\)</span> 称零点能。波长 <spanclass="math inline">\(\lambda_n=\dfrac{2a}{n}\)</span></p><p>波函数为 <spanclass="math inline">\(\Psi_n(x,t)=\pm\sqrt{\dfrac{2}{a}}\sin\dfrac{n\pi}{a}xe^{-\tfrac{i}{\hbar}E_nt}\)</span></p><h4 id="势垒穿透">*势垒穿透</h4><p>势能函数满足 <span class="math inline">\(V(x)=\begin{cases}0,\x\leqslant0 \\ U_0,\ x&gt;0\end{cases}\)</span></p><p>粒子从 <span class="math inline">\(-\infty\)</span> 处以能量E入射，<span class="math inline">\(E&lt;U_0\)</span>，类似金属或半导体接触处</p><p>解一维定态薛定谔方程得</p><p>入射波、反射波： <spanclass="math inline">\(\Psi_1(x)=Ae^{ik_1x}+Be^{-ik_1x},k_1=\sqrt{\dfrac{2mE}{\hbar^2}}\)</span></p><p>透射波： <spanclass="math inline">\(\Psi_2(x)=Ce^{-k_2x}=Ce^{-\tfrac{1}{\hbar}\sqrt{2m(U_0-E)}x}\)</span></p><p>若势垒有限宽，即 <span class="math inline">\(V(x)=\begin{cases}0,\x\leqslant0 \\ U_0,\ 0&lt;x&lt;a\\ 0,x\geqslant a\end{cases}\)</span>，则波穿过后以平面波的形式继续前进，振幅为 <spanclass="math inline">\(\Psi_2(a)=Ce^{-\tfrac{a}{\hbar}\sqrt{2m(U_0-E)}}\)</span></p><h4 id="一维谐振子">*一维谐振子</h4><p>势能 <spanclass="math inline">\(V(x)=\dfrac{1}{2}kx^2=\dfrac{1}{2}m\omega^2x^2\)</span></p><p>谐振子的定态薛定谔方程 <spanclass="math inline">\(\dfrac{d^2\psi(x)}{dx^2}+\dfrac{2m}{\hbar^2}(E-\dfrac{1}{2}m\omega^2x^2)\psi(x)=0\)</span></p><p>解得 <spanclass="math inline">\(E_n=(n+\dfrac{1}{2})\hbar\omega=(n+\dfrac{1}{2})h\nu,n=0,1,2...\)</span></p><h4 id="氢原子">*氢原子</h4><p><spanclass="math inline">\(\nabla^2\psi(\vec{r})+\dfrac{2m}{\hbar^2}(E-V)\psi(\vec{r})=0\)</span>，<spanclass="math inline">\(V(r)=-\dfrac{e^2}{4\pi\varepsilon_0r}\)</span></p><p><spanclass="math inline">\(E_n=-\dfrac{me^4}{8h^2\varepsilon_0^2}\dfrac{1}{n^2}=-\dfrac{13.6}{n^2}(eV),n=1,2,3...\)</span><span class="math inline">\(n\)</span> 为主量子数</p><p><spanclass="math inline">\(L=\sqrt{l(l+1)}\hbar,l=0,1,...n-1\)</span> ，其中<span class="math inline">\(l\)</span> 称角（副）量子数</p><p>角动量在空间的取向也是量子化的，<spanclass="math inline">\(L_z=m_l\hbar,m_l=0,\pm1,...\pm l\)</span> ，<spanclass="math inline">\(m_l\)</span> 称磁量子数</p><p>波函数 <spanclass="math inline">\(\Psi_{n,l,m_l}(r,\theta,\varphi)=R_{nl}(r)Y_{lm_l}(\theta,\varphi)\)</span>，可分为镜像波函数、角向波函数</p><h3 id="原子中的电子">原子中的电子</h3><h4 id="电子自旋与四个量子数">电子自旋与四个量子数</h4><p>自旋量子数s，自旋磁量子数 <span class="math inline">\(m_S\)</span>，自旋角动量 <span class="math inline">\(S=\sqrt{s(s+1)}\hbar\)</span>自旋角动量在外磁场方向的投影 <spanclass="math inline">\(S_z=m_S\hbar\)</span></p><p>原子中的电子运动由4个量子数决定</p><ol type="1"><li>主量子数 <span class="math inline">\(n=1,2,3...\)</span>，大体决定原子中电子的能量</li><li>角量子数 <span class="math inline">\(l=0,1,2...(n-1)\)</span>，决定电子轨道角动量大小 <spanclass="math inline">\(L=\sqrt{l(l+1)}\hbar\)</span></li><li>磁量子数 <span class="math inline">\(m_l=0,\pm1,\pm2,...\pml\)</span> ，决定电子的轨道角动量在外磁场方向的投影 <spanclass="math inline">\(L_z=m_l\hbar\)</span></li><li>自旋磁量子数 <spanclass="math inline">\(m_s=\pm\dfrac{1}{2}\)</span>，决定电子的自旋角动量在外磁场方向的投影 <spanclass="math inline">\(S_z=m_s\hbar\)</span></li></ol><h4 id="电子壳层结构">电子壳层结构</h4><p>泡利不相容原理：同一原子中，不可能有两个或两个以上的电子具有完全相同的量子状态</p><p>主量子数为n的壳层内最多容纳 <spanclass="math inline">\(Z_n=2n^2\)</span> 个电子，l支壳层最多容纳 <spanclass="math inline">\(2(2l+1)\)</span></p><p>能量最小原理：原子系统处于正常状态时，每个电子趋向占有最低的能级</p><p>主量子数n对应 <span class="math inline">\(1s,2s,...ns\)</span>，角量子数l则对应 <span class="math inline">\(4s,4p,4d,4f...\)</span>中的spdf</p><p>经验规律： <span class="math inline">\(n+0.7l\)</span>的值越小，能级越低</p><p>填充顺序： <spanclass="math inline">\(1s,2s,2p,3s,3p,4s,3d,4p,5s,4d,5p,6s,4f,5d,6p...\)</span></p><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/df87013877101c94316fec62af77c22e.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概统笔记</title>
    <link href="/2024/01/14/%E6%A6%82%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E6%A6%82%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h2 id="随机事件的概率">随机事件的概率</h2><h3 id="概念">概念</h3><p><span class="math inline">\(P(A)=0\nRightarrowA=\emptyset\)</span></p><p><span class="math inline">\(A\cap B=\emptyset\nRightarrow\)</span><span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span> 独立</p><p><span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span> 独立 <spanclass="math inline">\(\nRightarrow\bar{A}\)</span>、<spanclass="math inline">\(B\)</span> 独立</p><p>互不相容（交集为空）、互逆根据事件定义，独立根据概率定义</p><h3 id="公式">公式</h3><p>加法公式：<spanclass="math inline">\(P(A+B)=P(A)+P(B)-P(AB)\)</span></p><p>条件概率：<spanclass="math inline">\(P(A|B)=\dfrac{P(AB)}{P(B)}\)</span></p><p>全概率公式：<spanclass="math inline">\(P(A)=\sum\limits_{i=1}^nP(B_i)P(A|B_i)\)</span>，其中<span class="math inline">\(\sum\limits_{i=1}^nP(B_i)=S\)</span>、<spanclass="math inline">\(P(B_i)&gt;0\)</span> 且 <spanclass="math inline">\(B_i\)</span> 互不相容</p><p>另有 <span class="math inline">\(P(A)=P(AB)+P(A\bar{B})\)</span></p><p>贝叶斯公式：<spanclass="math inline">\(P(A|B)=\dfrac{P(A)P(B|A)}{P(B)}=\dfrac{P(A)P(B|A)}{P(A)P(B|A)+P(\bar{A})P(B|\bar{A})}\)</span></p><h2 id="随机变量及其分布">随机变量及其分布</h2><h3 id="一维随机变量">一维随机变量</h3><h4 id="两点分布">两点分布</h4><h4 id="泊松分布">泊松分布</h4><p><spanclass="math inline">\(P\{X=k\}=e^{-\lambda}\dfrac{\lambda^k}{k!},k=0,1,2...\)</span>其中 <span class="math inline">\(\lambda&gt;0\)</span>，记作 <spanclass="math inline">\(X\sim\Pi(\lambda)\)</span></p><p>重要公式：<spanclass="math inline">\(e^x=\sum\limits_{k=0}^{+\infty}\dfrac{x^k}{k!}\)</span></p><h4 id="几何分布">几何分布</h4><p>n次伯努利实验中，实验k次才成功一次的概率</p><p><span class="math inline">\(P\{x=k\}=(1-p)^{k-1}p,k=1,2,...\)</span>，记为 <span class="math inline">\(X\sim GE(p)\)</span></p><h4 id="超几何分布">超几何分布</h4><p>书上定义：</p><p>M件正品，N件次品，从中任意取n件，取到的次品数X。</p><p><spanclass="math inline">\(P\{X=k\}=\dfrac{C_N^kC_M^{n-k}}{C_{M+N}^n},k=0,1,2...l,l=\min\{n,N\}\)</span></p><p>讲义、高中、百度百科定义：</p><p>N件产品，M件次品，从中任意取n件，取到的次品数X。</p><p><spanclass="math inline">\(P\{X=k\}=\dfrac{C_M^kC_{N-M}^{n-k}}{C_N^n},k=0,1,2...l,l=\min\{n,M\}\)</span>，记为 <span class="math inline">\(X\sim H(n,M,N)\)</span></p><p>N、M较大时，可用二项分布逼近，<spanclass="math inline">\(p=\dfrac{M}{N}\)</span></p><h4 id="二项分布">二项分布</h4><p><span class="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)</span>，记作 <span class="math inline">\(X\sim B(n,p)\)</span></p><p>当n很大、p较小时，二项分布近似于泊松分布，且有 <spanclass="math inline">\(C_n^kp^k(1-p)^{n-k}\approx\dfrac{e^{-\lambda}\lambda^k}{k!}\)</span>，其中<span class="math inline">\(\lambda=np\)</span></p><h4 id="均匀分布">均匀分布</h4><h4 id="指数分布">指数分布</h4><p><span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambdax}&amp;x\geqslant0\\0&amp;x&lt;0\end{cases}\)</span> ，其中 <spanclass="math inline">\(\lambda&gt;0\)</span> 为常数，称服从参数为 <spanclass="math inline">\(\lambda\)</span> 的指数分布</p><p>指数分布具有无后效性</p><h4 id="正态分布">正态分布</h4><p><spanclass="math inline">\(f(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{-\tfrac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty\)</span>，记作 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span></p><p>重要公式：<spanclass="math inline">\(\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}\)</span></p><p><spanclass="math inline">\(F(x)=\Phi(\frac{x-\mu}{\sigma})\)</span></p><p><spanclass="math inline">\(\Gamma(x)=\int_0^{+\infty}t^{x-1}e^{-t}dt\)</span>，<span class="math inline">\(\Gamma(x+1)=x\Gamma(x)\)</span> ，<spanclass="math inline">\(\Gamma(n)=(n-1)!\)</span> ，<spanclass="math inline">\(\Gamma(\frac{1}{2})=\sqrt{\pi}\)</span></p><h3 id="二维随机变量">二维随机变量</h3><p>二维正态分布：</p><p><spanclass="math inline">\(f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\tfrac{1}{2(1-\rho^2)}[(\tfrac{x-\mu_1}{\sigma_1})^2-2\rho\tfrac{x-\mu_1}{\sigma_1}\tfrac{y-\mu_2}{\sigma_2}+(\tfrac{y-\mu_2}{\sigma_2})^2]}\)</span>，<span class="math inline">\((X,Y)\simN(\mu_1,\sigma_1^2;\mu_2,\sigma_2^2;\rho)\)</span></p><p>条件分布：<spanclass="math inline">\(F_{X|Y}(x)=\int_{-\infty}^{x}\dfrac{f(u,y)}{f_Y(y)}du,f_{X|Y}(x)=\dfrac{f(x,y)}{f_Y(y)}\)</span></p><p>X、Y独立：<spanclass="math inline">\(F(x,y)=F_X(x)F_Y(y),f(x,y)=f_X(x)f_Y(y)\)</span>，并且任意<span class="math inline">\(U=g(X),V=f(Y)\)</span>，U,V相互独立</p><h3 id="复合随机变量">复合随机变量</h3><h4 id="一般方法">一般方法</h4><ul><li>一维：记 <span class="math inline">\(Y=g(X),D_y=\{x|g(x)\leqslanty\}=g^{-1}\{(-\infty,y]\}\)</span>，则有</li></ul><p><span class="math display">\[\begin{aligned}F_Y(y)&amp;=p\{Y\leqslant y\}=P\{g(X)\leqslant y\}\\&amp;=P\{X\in D_y\}=\int_{D_y}f(x)dx\\f_Y(y)&amp;=F_Y(y)&#39;\end{aligned}\]</span></p><ul><li>二维：记 <spanclass="math inline">\(Z=g(X,Y),D_z=\{(x,y)|g(x,y\leqslantz)\}\)</span>，则有</li></ul><p><span class="math display">\[\begin{aligned}F_Z(z)&amp;=p\{Z\leqslant z\}=P\{g(X,Y)\leqslant z\}\\&amp;=P\{(X,Y)\in D_z\}=\iint\limits_{D_y}f(x,y)dxdy\\f_Z(z)&amp;=F_Z(z)&#39;\end{aligned}\]</span></p><h4 id="特殊方法">特殊方法</h4><ul><li><p>一维概率密度，<span class="math inline">\(Y=g(X)\)</span>且g严格单调，有 <spanclass="math inline">\(f_Y(y)=f(g^{-1}(y))\cdot|(g^{-1}(y))&#39;|\)</span></p></li><li><p><span class="math inline">\(Z=X+Y\)</span></p></li></ul><p><span class="math display">\[\begin{aligned}F_Z(z)&amp;=P\{Z\leqslant z\}=P\{X+Y\leqslant z\}\\&amp;=\iint\limits_{D_z}f(x,y)dxdy\\&amp;=\int_{-\infty}^{+\infty}[\int_{-\infty}^{z-x}f(x,y)dy]dx\\&amp;=\int_{-\infty}^{+\infty}[\int_{-\infty}^{z}f(x,t-x)dt]dx\\&amp;=\int_{-\infty}^{z}[\int_{-\infty}^{+\infty}f(x,t-x)dx]dt\\f_Z(z)&amp;=\int_{-\infty}^{+\infty}f(x,z-x)dx\end{aligned}\]</span></p><ul><li><span class="math inline">\(Z=\max\{X,Y\}\)</span></li></ul><p><span class="math display">\[\begin{aligned}F_{\max}(z)&amp;=P\{Z\leqslant z\}=P\{\max\{X,Y\}\leqslant z\}\\&amp;=P\{X\leqslant z,Y\leqslant z\}=F(z,z)\\&amp;=\int_{-\infty}^z\int_{-\infty}^zf(x,y)dxdy\\&amp;=F_X(z)\cdot F_Y(z)（X与Y独立）\end{aligned}\]</span></p><ul><li><span class="math inline">\(Z=\min\{X,Y\}\)</span></li></ul><p>法一：</p>$$<span class="math display">\[\begin{aligned}F_{\min}(z)&amp;=P\{Z\leqslant z\}=P\{\min\{X,Y\}\leqslant z\}\\&amp;=P(\{X\leqslant z\}+\{Y\leqslant z\})\\&amp;=P\{X\leqslant z\}+P\{Y\leqslant z\}-P\{X\leqslant z,Y\leqslantz\}\\&amp;=F_X(z)+F_Y(z)-F(z,z)\end{aligned}\]</span><p>$$</p><p>法二：</p>$$<span class="math display">\[\begin{aligned}F_{\min}(z)&amp;=P\{Z\leqslant z\}=P\{\min\{X,Y\}\leqslant z\}\\&amp;=1-P\{\min\{X,Y\}&gt;z\}=1-P\{X&gt;z,Y&gt;z\}\\&amp;=1-\iint\limits_{x&gt;z\atop y&gt;z}f(x,y)dxdy\\&amp;=1-[1-F_X(z)]\cdot[1-F_Y(z)] （X，Y独立）\end{aligned}\]</span><p>$$</p><h4 id="特殊分布">特殊分布</h4><p>若 <span class="math inline">\(X_i\simN(\mu_i,\sigma_i^2)\)</span>，且<strong>相互独立</strong>，则有 <spanclass="math inline">\(Z=\sum\limits_{i=1}^nk_iX_i+b\simN(\sum\limits_{i=1}^nk_i\mu_i,\sum\limits_{i=1}^nk_i^2\sigma_i^2)\)</span></p><p>若 <span class="math inline">\(X\sim\Pi(\lambda_1),Y\sim\Pi(\lambda_2)\)</span>，且<strong>相互独立</strong>，则有<spanclass="math inline">\(Z=X+Y\sim\Pi(\lambda_1+\lambda_2)\)</span></p><h2 id="随机变量的数字特征">随机变量的数字特征</h2><h3 id="期望">期望</h3><h4 id="基本定义">基本定义</h4><p>离散：<spanclass="math inline">\(E(X)=EX=\sum\limits_{k=1}^{+\infty}x_kp_k\)</span></p><p>连续：<spanclass="math inline">\(EX=\int_{-\infty}^{+\infty}xf(x)dx\)</span></p><p>二维：<spanclass="math inline">\(E(XY)=\sum\limits_i\sum\limits_jx_iy_jp_{ij}=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xyf(x,y)dxdy\)</span></p><h4 id="性质">性质</h4><ul><li><p><spanclass="math inline">\(Y=g(X),则EY=\int_{-\infty}^{+\infty}g(X)f(x)dx\)</span>*要求积分绝对收敛</p></li><li><p><span class="math inline">\(C\)</span> 为常数，则 <spanclass="math inline">\(E(C)=C\)</span></p></li><li><p><span class="math inline">\(E(CX)=CE(X)\)</span> <spanclass="math inline">\(E(X+Y)=EX+EY\)</span></p></li><li><p>若X,Y<strong>独立</strong>，则 <spanclass="math inline">\(E(XY)=EX\cdot EY\)</span></p></li></ul><h3 id="方差">方差</h3><h4 id="基本定义-1">基本定义</h4><p><span class="math inline">\(DX=D(X)=E(X-EX)^2\)</span> ，<spanclass="math inline">\(\sqrt{DX}\)</span> 称标准差（均方差）</p><h4 id="性质-1">性质</h4><ul><li><p><span class="math inline">\(DX=EX^2-(EX)^2\)</span>非常重要，经常使用！！！</p></li><li><p><span class="math inline">\(C\)</span> 为常数，<spanclass="math inline">\(D(C)=0\)</span></p></li><li><p><span class="math inline">\(D(CX)=C^2DX\)</span></p></li><li><p>X,Y<strong>独立</strong>，则 <spanclass="math inline">\(D(aX+bY+c)=a^2DX+b^2DY\)</span></p></li><li><p>若 <span class="math inline">\(EX^2\)</span> 存在，则 <spanclass="math inline">\(k=EX\)</span> 时，有 <spanclass="math inline">\(\min\{E(X-k)^2\}=DX\)</span></p></li></ul><h3 id="其他特征">其他特征</h3><h4 id="协方差">协方差</h4><p><span class="math inline">\(cov(X,Y)=E(X-EX)(Y-EY)\)</span> ，可记为<span class="math inline">\(\sigma_{XY}\)</span></p><ul><li><p>计算：<spanclass="math inline">\(cov(X,Y)=E(XY)-EXEY\)</span></p></li><li><p>对称性：<span class="math inline">\(cov(X,Y)=cov(Y,X)\)</span>，且 <span class="math inline">\(cov(X,X)=DX\)</span></p></li><li><p>线性：<spanclass="math inline">\(cov(aX,bY)=abcov(X,Y)\)</span></p></li><li><p>求和：<span class="math inline">\(cov(\sum X_i,\sumY_j)=\sum_i\sum_jcov(X_i,Y_j)\)</span></p></li><li><p><span class="math inline">\(D(\sum X_i)=\sumD(X_i)+\sum\sum_{i\ne j}cov(X_i,Y_j)\)</span></p></li></ul><h4 id="相关系数">相关系数</h4><p><spanclass="math inline">\(\rho(X,Y)=\dfrac{cov(X,Y)}{\sqrt{DXDY}}\)</span>，记为 <span class="math inline">\(\rho_{XY}\)</span></p><ul><li><p>独立一定不相关，不相关不一定独立</p></li><li><p>二维正态分布下，不相关=独立</p></li></ul><h3 id="矩矩母函数协方差矩阵">*矩、矩母函数、协方差矩阵</h3><p><spanclass="math inline">\(EX^n=\int_{-\infty}^{+\infty}x^nf(x)dx\)</span>为X的n阶矩，<span class="math inline">\(E(X-EX)^n\)</span>称X的n阶中心矩</p><p>X的期望存在，则X的矩母函数定义为 <spanclass="math inline">\(M_X(s)=E(e^{sX})\)</span> ，记为 <spanclass="math inline">\(M(s)\)</span></p><p><spanclass="math inline">\(EX^n=\dfrac{d^nM(s)}{ds^n}|_{s=0}\)</span></p><p>正态分布 <span class="math inline">\(X\sim N(0,\sigma^2)\)</span>，则有</p><p><spanclass="math inline">\(EX^k=\dfrac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^{+\infty}x^ke^{-\tfrac{x^2}{2\sigma^2}}dx=\sqrt{\frac{2}{\pi}}\sigma^k2^{\frac{(k-1)}{2}}\Gamma(\frac{k+1}{2})=\sigma^k(k-1)(k-3)...1\)</span></p><p>对n维随机向量 <span class="math inline">\((X_1,X_2,...,X_n)\)</span>，若 <spanclass="math inline">\(C_{ij}=Cov(X_i,X_j)=E[(X_i-EX_i)(X_j-EX_j)]\)</span>存在，则矩阵 <span class="math inline">\(C=(C_{ij})_{n\times n}\)</span>称n维随机向量的协方差矩阵</p><p>设 <spanclass="math inline">\(X=(x_1,x_2,...,x_n)^T,U=(\mu_1,\mu_2,...,\mu_n)^T,C\)</span>，且n维随机变量 <span class="math inline">\((X_1,X_2,...,X_n)\)</span>概率密度满足 <spanclass="math inline">\(f(x_1,x_2,...,x_n)=\dfrac{1}{(2\pi)^{\tfrac{n}{2}}(\detC)^{\tfrac{1}{2}}}\exp[-\dfrac{1}{2}(X-U)^TC^{-1}(X-U)]\)</span>，则称n维正态随机变量</p><h3 id="常见分布的数字特征">常见分布的数字特征</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">形式</th><th style="text-align: center;">分布律/概率密度</th><th style="text-align: center;">EX</th><th style="text-align: center;">DX</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">两点分布</td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(P(x=0)=1-p,P(x=1)=p\)</span></td><td style="text-align: center;">p</td><td style="text-align: center;">p(1-p)</td></tr><tr class="even"><td style="text-align: center;">二项分布</td><td style="text-align: center;"><span class="math inline">\(X\simB(n,p)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P(x=k)=C_n^kp^n(1-p)^{n-k}\)</span></td><td style="text-align: center;">np</td><td style="text-align: center;">np(1-p)</td></tr><tr class="odd"><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><span class="math inline">\(X\sim\Pi(\lambda)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{X=k\}=e^{-\lambda}\frac{\lambda^k}{k!}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\lambda\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\lambda\)</span></td></tr><tr class="even"><td style="text-align: center;">几何分布</td><td style="text-align: center;"><span class="math inline">\(X\simGE(p)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{x=k\}=(1-p)^{k-1}p\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{p}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1-p}{p^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;">超几何分布</td><td style="text-align: center;"><span class="math inline">\(X\simH(n,M,N)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{X=k\}=\dfrac{C_M^kC_{N-M}^{n-k}}{C_N^n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{nM}{N}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{nM}{N}(1-\dfrac{M}{N})\dfrac{N-n}{N-1}\)</span></td></tr><tr class="even"><td style="text-align: center;">均匀分布</td><td style="text-align: center;"><span class="math inline">\(X\simU(a,b)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{b-a}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{a+b}{2}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{(b-a)^2}{12}\)</span></td></tr><tr class="odd"><td style="text-align: center;">指数分布</td><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\(f(x)=\lambdae^{-\lambda x},x\geqslant0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{\lambda}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{\lambda^2}\)</span></td></tr><tr class="even"><td style="text-align: center;">正态分布</td><td style="text-align: center;"><span class="math inline">\(X\simN(\mu,\sigma^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{-\tfrac{(x-\mu)^2}{2\sigma^2}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\mu\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sigma^2\)</span></td></tr><tr class="odd"><td style="text-align: center;">卡方分布</td><td style="text-align: center;"><span class="math inline">\(X\sim\chi(n)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\tfrac{n}{2}-1}e^{-\tfrac{x}{2}}\)</span></td><td style="text-align: center;">n</td><td style="text-align: center;">2n</td></tr><tr class="even"><td style="text-align: center;">t分布</td><td style="text-align: center;"><span class="math inline">\(X\simt(n)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(t)=\dfrac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\dfrac{t^2}{n})^{-\tfrac{n+1}{2}}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{n}{n-2}\)</span></td></tr></tbody></table><h2 id="不等式与大数定律">不等式与大数定律</h2><h3 id="概率不等式">概率不等式</h3><p>柯西-许瓦茨不等式：<spanclass="math inline">\(EX^2EY^2\geqslant(EXY)^2\)</span></p><p><spanclass="math inline">\((E|X+Y|^2)^{\frac{1}{2}}\leqslant(EX^2)^{\frac{1}{2}}+(EY^2)^{\frac{1}{2}}\)</span></p><p>琴生不等式：若 <span class="math inline">\(g(x)\)</span> 是凸函数，则<span class="math inline">\(Eg(X)\geqslant g(EX)\)</span></p><p>马尔可夫不等式：设随机变量X非负，则任意a&gt;0，k&gt;0，<spanclass="math inline">\(P(X&gt;a)\leqslant\dfrac{EX^k}{a^k}\)</span></p><p>切比雪夫不等式：设随机变量均值 <spanclass="math inline">\(\mu\)</span>，方差 <spanclass="math inline">\(\sigma^2\)</span>，则任意a&gt;0，<spanclass="math inline">\(P(|X-\mu|\geqslantk)\leqslant\dfrac{\sigma^2}{k^2}\)</span></p><p>弱大数定律：设 <span class="math inline">\(X_i\)</span>是独立同分布的随机变量列，期望方差存在，则对任意 <spanclass="math inline">\(\epsilon&gt;0\)</span>， <spanclass="math inline">\(\lim\limits_{n\to\infty}P(|\overline{X_n}-\mu|\geqslant\epsilon)=0\)</span>。其中，<spanclass="math inline">\(\overline{X_n}=\dfrac{1}{n}\sum\limits_{i=1}^{i=n}X_i\)</span></p><p>强大数定律：有限四阶矩存在，<spanclass="math inline">\(P(\lim\limits_{n\to\infty}\overline{X_n}=\mu)=1\)</span></p><h3 id="随机变量的极限">*随机变量的极限</h3><p>依概率收敛：<spanclass="math inline">\(P(|X_n-X|\geqslant\varepsilon)\to0\)</span>，记为<span class="math inline">\(X_n\xrightarrow{P}X\)</span></p><p>以概率1收敛：<span class="math inline">\(P(\lim X_n=X)=1\)</span>，记为 <span class="math inline">\(X_n\xrightarrow{as}X\)</span></p><p>依分布收敛：<span class="math inline">\(\lim P(X_n\leqslantx)=F_X(x),\lim F_{X_{n}}(x)=F_X(x)\)</span> ，记为 <spanclass="math inline">\(X_n\xrightarrow{d}X\)</span></p><h3 id="中心极限定理">中心极限定理</h3><p>独立同分布随机变量序列 <span class="math inline">\(X_n\)</span>，期望方差存在，定义 <spanclass="math inline">\(S_n=\sum\limits_{i=1}^{i=n}X_i,\xi_n=\dfrac{S_n-n\mu}{\sqrt{n\sigma^2}}\)</span>，则<span class="math inline">\(\xi_n\xrightarrow{d}N(0,1)\)</span></p><p>即对充分大的n，可用 <span class="math inline">\(S_n\simN(n\mu,n\sigma^2)\)</span> 逼近</p><h2 id="统计总体与样本">统计总体与样本</h2><h3 id="样本矩与统计量">样本矩与统计量</h3><p>简单随机样本：样本之间相互独立，且与总体同分布</p><p>设 <span class="math inline">\(X_1,X_2,...X_n\)</span>为来自于总体X的一个样本</p><p>样本均值：<spanclass="math inline">\(\overline{X}=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i\)</span></p><p>样本方差：<spanclass="math inline">\(S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^n(X_i-\overline{X})^2\)</span></p><p>样本k阶矩（原点矩）：<spanclass="math inline">\(A_k=\dfrac{1}{n}\sum\limits_{i=1}^nX_i^k\)</span></p><p>样本k阶中心矩：<spanclass="math inline">\(B_k=\dfrac{1}{n}\sum\limits_{i=1}^n(X_i-\overline{X})^k\)</span></p><p>以上四个都是随机变量，若用观察值代替，则分别是对应随机变量的观察值</p><p>总体矩：<spanclass="math inline">\(\mu=EX,\mu_k=EX^k,\nu_k=EX^k\)</span> ，且有 <spanclass="math inline">\(A_k\xrightarrow{P}\mu_k\)</span></p><h3 id="常用统计量的分布">常用统计量的分布</h3><h4 id="正态分布-1">正态分布</h4><p>总体 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span></p><p><span class="math inline">\(\overline{X}\simN(\mu,\dfrac{\sigma^2}{n})\)</span></p><p><spanclass="math inline">\(\dfrac{(n-1)}{\sigma^2}S^2\sim\chi^2(n-1)\)</span>，且样本均值与样本方差相互独立</p><p><spanclass="math inline">\(\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\simt(n-1)\)</span></p><h4 id="卡方分布">卡方分布</h4><p>设 <span class="math inline">\(X_1,X_2,...X_n\)</span>相互独立且都服从标准正态分布，则 <spanclass="math inline">\(Y=\chi^2=\sum\limits_{i=1}^nX_i^2\sim\chi^2(n)\)</span></p><p>概率密度为 <spanclass="math inline">\(f(y)=\dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}y^{\tfrac{n}{2}-1}e^{-\tfrac{y}{2}},(y&gt;0);EY=n,DY=2n\)</span></p><p>若 <spanclass="math inline">\(X_1\sim\chi^2(n_1),X_2\sim\chi^2(n_2)\)</span> 且<span class="math inline">\(X_1\)</span> 与 <spanclass="math inline">\(X_2\)</span> 相互独立，则 <spanclass="math inline">\(X_1+X_2\sim\chi^2(n_1+n_2)\)</span></p><h4 id="t分布">t分布</h4><p><span class="math inline">\(X\sim N(0,1),Y\sim\chi^2(n)\)</span>，且X、Y相互独立，则 <spanclass="math inline">\(T=\dfrac{X}{\sqrt{\frac{Y}{n}}}\sim t(n)\)</span>，n为自由度</p><p>概率密度为 <spanclass="math inline">\(f(t)=\dfrac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\dfrac{t^2}{n})^{-\tfrac{n+1}{2}}\)</span></p><p>满足 <span class="math inline">\(F(t_{\alpha}(n))=\alpha\)</span>的点 <span class="math inline">\(t_{\alpha}(n)\)</span> 称t分布的 <spanclass="math inline">\(\alpha\)</span> 分位点，<spanclass="math inline">\(t_{1-\alpha}(n)=-t_{\alpha}(n)\)</span></p><p>当n很大时，t分布接近于标准正态分布</p><h4 id="f分布">F分布</h4><p><spanclass="math inline">\(X\sim\chi^2(n_1),Y\sim\chi^2(n_2)\)</span>且相互独立，则 <spanclass="math inline">\(F=\dfrac{\frac{X}{n_1}}{\frac{Y}{n_2}}\simF(n_1,n_2)\)</span></p><p>概率分布为 <spanclass="math inline">\(f(u)=\dfrac{\Gamma(\frac{n_1+n_2}{2})}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})}(\frac{n_1}{n_2})(\frac{n_1}{n_2}u)^{\tfrac{n_1}{2}-1}(1+\frac{n_1}{n_2}u)^{-\tfrac{n_1+n_2}{2}},u&gt;0\)</span></p><p><spanclass="math inline">\(F_{1-\alpha}(n_1,n_2)=\dfrac{1}{F_\alpha(n_2,n_1)}\)</span>（分位点，非概率）</p><h2 id="经典统计推断">经典统计推断</h2><h3 id="参数点估计">参数点估计</h3><h4 id="矩估计">矩估计</h4><p>用样本矩估计总体矩，即有</p><p>$$ =_{i=1}^nX_i=\</p><p>=_{i=1}<sup>n(X_i-)</sup>2=S^2 $$</p><p>方法：先求对应的矩，然后用样本均值等矩估计随机变量表示参数，最后把样本值代入即可得到估计值</p><h4 id="极大似然法mle">极大似然法（MLE）</h4><p>对于连续型总体，记 <spanclass="math inline">\(L(\theta)=L(x_1,x_2,...,x_n;\theta)=\prod\limits_{i=1}^nf(x_i;\theta)\)</span>为似然函数，选取使 <spanclass="math inline">\(L(\hat{\theta})=\max\limits_{\theta\in\Theta}L(\theta)\)</span>成立的 <span class="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的极大似然估计</p><p>方法：求 <spanclass="math inline">\(\dfrac{d}{d\theta}L(\theta)=0\)</span> 或 <spanclass="math inline">\(\dfrac{d}{d\theta}\ln L(\theta)=0\)</span></p><h4 id="常见分布的估计值">常见分布的估计值</h4><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">矩估计</th><th style="text-align: center;">极大似然估计</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">二项分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{p}=\dfrac{\bar{x_n}}{N}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{p}=\dfrac{\bar{x_n}}{N}\)</span></td></tr><tr class="even"><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\bar{x_n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\bar{x_n}\)</span></td></tr><tr class="odd"><td style="text-align: center;">均匀分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{b}=2\bar{x}_n\)</span></td><td style="text-align: center;"><span class="math inline">\(\hat{b}=\maxx_i\)</span></td></tr><tr class="even"><td style="text-align: center;">指数分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\dfrac{1}{\bar{x_n}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\dfrac{1}{\bar{x_n}}\)</span></td></tr><tr class="odd"><td style="text-align: center;">正态分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\mu}=\bar{x_n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\sigma^2}=\dfrac{1}{n}\sum(x_i-\hat{\mu})^2\)</span></td></tr></tbody></table><p>*除均匀分布外，表中估计值二者都一样</p><h3 id="点估计的评价">点估计的评价</h3><h4 id="无偏估计">无偏估计</h4><p>设 <span class="math inline">\(\hat{\theta}(x_1,x_2,...,x_n)\)</span>是未知参数 <span class="math inline">\(\theta\)</span> 的估计量，若<span class="math inline">\(E(\hat{\theta})=\theta\)</span> ，则称 <spanclass="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的无偏估计</p><p>样本均值和样本方差是总体均值、方差的无偏估计。但方差的矩估计、MLE估计<spanclass="math inline">\(\dfrac{1}{n}\sum(X_i-\overline{X_n})^2\)</span>不是无偏估计。均匀分布下MLE的估计不是无偏估计</p><h4 id="最小方差无偏估计">最小方差无偏估计</h4><p>设 <span class="math inline">\(\hat{\theta_1}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的一个无偏估计，若对 <spanclass="math inline">\(\theta\)</span> 的任一无偏估计 <spanclass="math inline">\(\hat{\theta_2}\)</span> ， <spanclass="math inline">\(D(\hat{\theta_1})\leqslantD(\hat{\theta_2})\)</span> 成立，则称 <spanclass="math inline">\(\hat{\theta_1}\)</span> 是 <spanclass="math inline">\(\theta\)</span> 的最小方差无偏估计</p><p>正态总体下，<span class="math inline">\(\mu\)</span>的最小方差线性无偏估计为样本均值</p><p>均匀分布的MLE估计比矩估计更有效</p><h4 id="一致估计">一致估计</h4><p>设 <span class="math inline">\(\hat{\theta}(X_1,X_2,...,X_n)\)</span>是未知参数 <span class="math inline">\(\theta\)</span> 的估计量，若<span class="math inline">\(\hat{\theta_n}\xrightarrow{P}\theta\)</span>，则称 <span class="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的一致性估计（相合估计）</p><p>所有矩估计均为相合估计（事实上以概率1收敛，也称强相合估计），样本方差是相合估计</p><h3 id="区间估计与置信区间">区间估计与置信区间</h3><p>设总体分布有一未知参数 <span class="math inline">\(\theta\)</span>，且 <span class="math inline">\(x_1,x_2,..x_n\)</span>为来自总体的样本，若对给定的 <spanclass="math inline">\(\alpha(0&lt;\alpha&lt;1)\)</span> ，统计量 <spanclass="math inline">\(\theta_1(x_1,...,x_n)\)</span> 和 <spanclass="math inline">\(\theta_2(x_1,...,x_n)\)</span> 满足 <spanclass="math inline">\(P\{\theta_1\leqslant\theta\leqslant\theta_2\}=1-\alpha\)</span>，则称区间 <span class="math inline">\([\theta_1,\theta_2]\)</span> 是<span class="math inline">\(\theta\)</span> 置信度为 <spanclass="math inline">\(1-\alpha\)</span> 的置信区间，<spanclass="math inline">\(\theta_1\)</span> 和 <spanclass="math inline">\(\theta_1\)</span> 分别为置信上限和置信下限，<spanclass="math inline">\(1-\alpha\)</span> 称置信度</p><p>方法：求参数的估计，找到服从的分布，根据置信度确定上下限，代入具体样本值进行计算。具体类型如下</p><h4 id="正态总体均值和方差的区间估计">正态总体均值和方差的区间估计</h4><p>设总体 <span class="math inline">\(X\simN(\mu,\sigma^2)\)</span>，<spanclass="math inline">\(x_1,x_2,...,x_n\)</span> 为来自于总体的样本</p><p>方差DX已知，对EX进行区间估计：</p><p>统计量 <spanclass="math inline">\(\dfrac{\bar{x}-\mu}{\frac{\sigma}{\sqrt{n}}}\simN(0,1)\)</span> ，则置信区间为 <spanclass="math inline">\([\bar{x}-z_{1-\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\bar{x}+z_{1-\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}]\)</span></p><p>方差DX未知，对EX进行区间估计：</p><p>用样本方差代替总体方差，则有 <spanclass="math inline">\(\dfrac{\bar{x}-\mu}{\frac{s}{\sqrt{n}}}\simt(n-1)\)</span> ，置信区间为 <spanclass="math inline">\([\bar{x}-t_{1-\tfrac{\alpha}{2}}(n-1)\dfrac{s}{\sqrt{n}},\bar{x}+t_{1-\tfrac{\alpha}{2}}(n-1)\dfrac{s}{\sqrt{n}}]\)</span></p><p>方差DX的区间估计：</p><p><spanclass="math inline">\(\dfrac{(n-1)s^2}{\sigma^2}\sim\chi^2(n-1)\)</span>，置信区间 <spanclass="math inline">\([\dfrac{(n-1)s^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)},\dfrac{(n-1)s^2}{\chi^2_{\frac{\alpha}{2}}(n-1)}]\)</span></p><h4 id="假设检验">假设检验</h4><p>第一类错误：原假设正确，但抽样得到的结论否定原假设</p><p>第二类错误：原假设错误，抽样得到的结论不拒绝原假设</p><p>记第一类错误的概率为 <span class="math inline">\(\alpha\)</span>（显著性水平），第二类错误的概率为 <spanclass="math inline">\(\beta\)</span> ，</p><p>方差已知，正态总体均值的假设检验</p><p><span class="math inline">\(H_0:\mu=\mu_0;\ H_1:\mu\ne\mu_0\)</span>检验用的统计量 <spanclass="math inline">\(U=\dfrac{\bar{x}-\mu_0}{\frac{\sigma}{\sqrt{n}}}\simN(0,1)\)</span> ，设检验水平 <span class="math inline">\(\alpha\)</span>，则有 <spanclass="math inline">\(P\{|\dfrac{\bar{x}-\mu_0}{\frac{\sigma}{\sqrt{n}}}|&gt;z_{1-\frac{\alpha}{2}}\}=\alpha\)</span>，因而拒绝域为 <spanclass="math inline">\(D=(-\infty,-z_{1-\tfrac{\alpha}{2}}]\cup[z_{1-\tfrac{\alpha}{2}},+\infty)\)</span></p><p>方差未知，均值检验</p><p><spanclass="math inline">\(U=\dfrac{\bar{x}-\mu_0}{\frac{s}{\sqrt{n}}}\simt(n-1)\)</span></p><p>方差的假设检验</p><p><spanclass="math inline">\(W=\dfrac{(n-1)s^2}{\sigma_0^2}\sim\chi^2(n-1)\)</span>，拒绝域为 <spanclass="math inline">\(D=(0,\chi_{1-\tfrac{\alpha}{2}}^2(n-1)][\chi_{\tfrac{\alpha}{2}}^2(n-1),+\infty)\)</span></p><h2 id="随机过程">随机过程</h2><h3 id="基本概念">基本概念</h3><p>给定参数集 <spanclass="math inline">\(T\subset(-\infty,+\infty)\)</span> ，如果对于每个<span class="math inline">\(t\in T\)</span> ，对应有随机变量 <spanclass="math inline">\(X(t)=X(e,t)\)</span> ，则称随机变量族 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 为随机过程</p><p>对于参数集中任意n个元素，过程的n个状态为 <spanclass="math inline">\(X(t_1)=X(e,t_1),X(t_2)=X(e,t_2)...\)</span>，这n个随机变量的联合分布函数 <spanclass="math inline">\(F(x_1,...,x_n;t_1,...,t_n)=P\{X(t_1)\leqslantx_1,...,X(t_n)\leqslant x_n\}\)</span> 称随机过程 <spanclass="math inline">\(X(t)\)</span> 的n维分布函数，<spanclass="math inline">\(n=1,2,3...\)</span></p><p>类似有n维概率密度</p><p>若对于任何正整数n，随机过程的任意n个状态都是相互独立的，称此过程为独立过程，<spanclass="math inline">\(F(x_1,x_2,...,x_n;t_1,t_2,...,t_n)=\prod\limits_{i=1}^nF(x_i;t_i),n=1,2,3,...\)</span></p><h3 id="数字特征">数字特征</h3><p>均值（函数） <spanclass="math inline">\(\mu_x(t)=E[X(t)]\)</span></p><p>均方值（函数） <spanclass="math inline">\(\Psi_X^2(t)=E[X^2(t)]\)</span></p><p>均方差 <spanclass="math inline">\(\sigma_{X}^2(t)=D[X(t)]=E[X(t)-EX(t)]^2=E[X(t)-\mu_X(t)]^2=E[X^2(t)]-\mu_X^2(t)\)</span></p><p>（自）相关函数 <spanclass="math inline">\(R_X(t_1,t_2)=E[X(t_1)X(t_2)]\)</span></p><p>（自）协方差函数 <spanclass="math inline">\(C_X(t_1,t_2)=E\{[X(t_1)-EX(t_1)][X(t_2)-EX(t_2)]\}\)</span></p><p>其中，数字特征间的关系有：</p><p><span class="math inline">\(\Psi_X^2(t)=R_X(t,t)\)</span></p><p><spanclass="math inline">\(C_X(t_1,t_2)=R_X(t_1,t_2)-\mu_X(t_1)\mu_X(t_2)\)</span></p><p><spanclass="math inline">\(\sigma_X^2(t)=\Psi_X^2(t)-\mu_X^2(t)\)</span></p><p>两个随机过程的互相关函数 <spanclass="math inline">\(R_{XY}(t_1,t_2)=E[X(t_1)Y(t_2)]\)</span></p><h3 id="平稳过程">平稳过程</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\in T\}\)</span>，如果对任意 <span class="math inline">\(t_1,t_2,...,t_n\in T\)</span>和任意实数 <span class="math inline">\(\varepsilon\)</span> ，有 <spanclass="math inline">\(t_1+\varepsilon,t_2+\varepsilon,...,t_n+\varepsilon\inT\)</span> ， <spanclass="math inline">\(F(x_1,x_2,...,x_n;t_1,t_2,...,t_n)=F(x_1,x_2,...,x_n;t_1+\varepsilon,t_2+\varepsilon,...,t_n+\varepsilon)\)</span>对任意n维分布函数都成立，则称 <span class="math inline">\(X(t)\)</span>为严平稳过程</p><p><strong>伯努利序列</strong>：独立重复进行某项试验，每次成功概率为p，失败为1-p，以<span class="math inline">\(X_n\)</span> 表示第n次试验成功的次数，则<span class="math inline">\(\{X_n,\ n=1,2,3\}\)</span>是严平稳过程。（样本空间 <span class="math inline">\(S=\{0,1\}\)</span>）</p><p>平稳过程（广义平稳过程）：</p><ol type="1"><li><span class="math inline">\(E[X^2(t)]\)</span> 存在且有限</li><li><span class="math inline">\(E[X(t)]=\mu_X\)</span> 是常数</li><li>任意 <span class="math inline">\(t+\tau\inT,E[X(t)X(t+\tau)]=R_X(\tau)\)</span> 仅依赖于 <spanclass="math inline">\(\tau\)</span> ，而与t无关</li></ol><p>正态过程：任意n，<spanclass="math inline">\((X(t_1),X(t_2),...,X(t_n))\)</span>均服从正态分布</p><p>存在二阶矩的严平稳过程必为广义平稳过程，正态平稳过程是严平稳过程</p><h3 id="遍历过程">遍历过程</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\inT=(-\infty,+\infty)\}\)</span></p><p>时间均值： <spanclass="math inline">\(\overline{X(t)}=\lim\limits_{l\to+\infty}\dfrac{1}{2l}\int_{-l}^lX(e,t)dt\)</span></p><p>时间相关函数： <spanclass="math inline">\(\overline{X(t)X(t+\tau)}=\lim\limits_{l\to+\infty}\dfrac{1}{2l}\int_{-l}^lX(e,t)X(e,t+\tau)dt\)</span></p><p>若 <spanclass="math inline">\(P\{\overline{X(t)}=E[X(t)]=\mu_X\}=1\)</span>，则称过程 <span class="math inline">\(X(t)\)</span>的均值具有各态遍历性。若 <spanclass="math inline">\(P\{\overline{X(t)X(t+\tau)}=E[X(t)X(t+\tau)]=R_X(\tau)\}=1\)</span>，则称过程 <span class="math inline">\(X(t)\)</span>的自相关函数具有各态遍历性。均值和自相关函数都具有各态遍历性的平稳过程称遍历过程</p><p>设随机过程均方值存在且有限，则称二阶矩过程。设 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 为二阶矩过程</p><ol type="1"><li>对 <span class="math inline">\(t_0\in T\)</span> ，若 <spanclass="math inline">\(\lim\limits_{t\to t_0}E|X(t)-X(t_0)|^2=0\)</span>，则称 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t_0\in T\)</span> 处均方连续</li><li>若 <span class="math inline">\(X(t)\)</span> 在每一个 <spanclass="math inline">\(t_0\in T\)</span> 处都均方连续，则称 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 是均方连续的</li></ol><p>设 <span class="math inline">\(\{X(t),t\inT=(-\infty,+\infty)\}\)</span>是一均方连续的平稳过程，则时间均值具有各态遍历性的条件是 <spanclass="math inline">\(\lim\limits_{t\to+\infty}\dfrac{1}{l}\int_0^{2l}(1-\dfrac{\tau}{2l})[R_X(\tau)-\mu_X^2]d\tau=0\)</span></p><h3 id="马尔可夫链">马尔可夫链</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\in T\}\)</span>的状态空间S为有限集或可列集，若对任意正整数n，T内任意n+1个参数 <spanclass="math inline">\(t_1&lt;t_2&lt;...&lt;t_n&lt;t_{n+1}\)</span>和S内任意n+1个状态 <spanclass="math inline">\(j_1,j_2,...,j_n,j_{n+1}\)</span> ，条件概率 <spanclass="math inline">\(P\{X(t_{n+1})=j_{n+1}|X(t_1)=j_1,X(t_2)=j_2,...,X(t_n)=j_n\}=P\{X(t_{n+1})=j_{n+1}|X(t_n)=j_n\}\)</span>恒成立，则称此过程为马尔可夫链，反映出的性质为无后效性。</p><p>状态空间符合要求的独立过程是马尔可夫链</p><p><spanclass="math inline">\(P\{X(t_{m+1})=j|X(t_m)=i\}=p_{ij}(t_m)\)</span> 称<span class="math inline">\(X(t)\)</span> 在时刻 <spanclass="math inline">\(t_m\)</span>时由状态i一步转移到状态j的（一步）转移概率。n步为 <spanclass="math inline">\(P\{X(t_{m+n})=j|X(t_m)=i\}=p_{ij}^{(n)}(t_m)\)</span></p><h4 id="齐次马尔可夫链">齐次马尔可夫链</h4><p>若一步转移概率不依赖于参数，即任意两个不相等的参数 <spanclass="math inline">\(t_m,t_k\)</span> ，有 <spanclass="math inline">\(P\{X(t_{m+1})=j|X(t_m)=i\}=p_{ij}(t_m)=P\{X(t_{k+1})=j|X(t_k)=i\}\)</span>，称齐次马尔可夫链</p><p>对于参数离散的齐次马尔可夫链，由转移概率 <spanclass="math inline">\(p_{ij}\)</span> 排序得转移概率矩阵（行和为1）<span class="math display">\[P=\begin{pmatrix}p_{00}&amp;p_{01}&amp;\cdots&amp;p_{0j}&amp;\cdots\\p_{10}&amp;p_{11}&amp;\cdots&amp;p_{1j}&amp;\cdots\\\vdots&amp;\vdots&amp;\ &amp;\vdots\\p_{i0}&amp;p_{i1}&amp;\cdots&amp;p_{ij}&amp;\cdots\\\vdots&amp;\vdots&amp;\ &amp;\vdots\end{pmatrix}\]</span> 马尔可夫链的多步转移公式： <spanclass="math inline">\(P_{ij}^{(n+l)}(t_m)=\sum\limits_kp_{ik}^{(n)}(t_m)p_{kj}^{(l)}(t_{m+n})\)</span></p><p>齐次情况下， <span class="math inline">\(P^{(n)}=P^n\)</span></p><h4 id="平稳分布">平稳分布</h4><p>对齐次马尔科夫链，若存在概率分布 <spanclass="math inline">\(\pi=(\pi_0,\pi_1,...,\pi_j,...)\)</span> 满足<spanclass="math inline">\(\pi_j\geqslant0,\sum\limits_{j=0}^{+\infty}\pi_j=1\)</span>和 <spanclass="math inline">\(\pi_j=\sum\limits_{i=0}^{+\infty}\pi_{ij}p_{ij},\j=0,1,2,...\)</span> 则称 <span class="math inline">\(\pi\)</span>为平稳分布， <span class="math inline">\(X(t)\)</span>是平稳齐次马尔可夫链</p>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
