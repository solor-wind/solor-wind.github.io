<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS理论笔记</title>
    <link href="/2024/07/02/OS%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/02/OS%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h2 id="引论">引论</h2><h3 id="操作系统的作用">操作系统的作用</h3><ol type="1"><li>用户与计算机硬件系统的接口（API/GUI）</li><li>系统资源的管理<ul><li>分配、控制处理机</li><li>内存的分配与回收</li><li>I/O设备的分配与操纵</li><li>文件的存取、共享和保护</li></ul></li><li>实现对计算机资源的抽象</li></ol><p>UI：User Interface，用户界面</p><p>API：Application ProgrammingInterface，应用程序编程接口。API相同，同一源码重新编译后即可运行</p><p>ABI：Application BinaryInterface，应用程序二进制接口。ABI相同，同一源码无须重新编译即可运行</p><p>ISA：Instruction Set Architecture，指令集架构。</p><h3 id="操作系统的进化">操作系统的进化</h3><h4 id="批处理">批处理</h4><p>把用户提交的作业成批送入计算机，由作业调度程序自动选择作业运行。</p><ul><li>无须人工参与，节省排队时间</li><li>同一时刻仅一个软件（作业）独占所有资源</li><li>CPU等待IO完成，浪费时间</li></ul><p>联机批处理：主机高速CPU运行监督程序，负责IO</p><p>脱机批处理：增加一台不与主机直接相连而专门用于与输入/输出设备打交道的卫星机</p><h4 id="多道程序设计">多道程序设计</h4><p>允许多个程序同时进入内存并运行。使CPU得到充分利用，同时也改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（即单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p><ul><li>系统吞吐量大</li><li>资源利用率高</li><li>平均周转时间长</li><li>无法提供交互能力</li></ul><h3 id="分时系统">分时系统</h3><p>多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源。</p><ul><li>支持多用户、多程序同时运行</li></ul><p>分时技术：把处理机的运行时间分成很短的时间片，时间片轮流把处理机分配给各联机作业使用</p><h3 id="其他">其他</h3><figure><img src="/img/OS异常-陷阱与中断.png" alt="异常-陷阱与中断" /><figcaption aria-hidden="true">异常-陷阱与中断</figcaption></figure><p>微内核：内核中只包括中断处理、进程通信（IPC）、基本调度等。文件系统、网络功能、内存管理、设备管理等作为服务在微内核上运行。</p><ul><li>易于实现、可靠性高、可移植性好、配置灵活、适应分布式环境</li><li>速度较慢</li></ul><h2 id="系统引导">系统引导</h2><h3 id="bootloader">Bootloader</h3><p>引导加载程序是系统加电后运行的第一段软件代码，称为Bootloader，是在操作系统内核运行之前运行的一段小程序</p><ul><li>Booter:初始化系统硬件使之运行起来，至少是部分运行起来</li><li>Loader:将操作系统映像加载到内存中，并跳转到操作系统的代码运行</li></ul><p>Bootloader的实现严重依赖于具体硬件，难以用一个Bootloader支持所有CPU和系统</p><p>U-Boot等Bootloader大多分为stage1和stage2两大阶段</p><ul><li>stage1：依赖于CPU体系结构的代码（如设备初始化），可用汇编语言实现</li><li>stage2：通常C语言实现，可读性、移植性更好</li></ul><h3 id="mips">MIPS</h3><p>32位下，共有4G程序地址空间</p><ul><li>kuseg(0x0000_0000-0x7FFF_FFFF)：用户可用的地址，需经过MMU转换</li><li>kseg0(0x8000_0000-0x9FFF_FFFF)：清零最高位即可映射到物理地址，需通过cache</li><li>kseg1(0xA000_0000-0xBFFF_FFFF)：清零高三位即可映射到物理地址，无须cache</li><li>kseg2(0xC000_0000-0xFFFF_FFFF)：核心态可用，需经过MMU转换</li></ul><figure><img src="/img/OS/MIPS启动stage1.png" alt="MIPS启动stage1" /><figcaption aria-hidden="true">MIPS启动stage1</figcaption></figure><figure><img src="/img/OS/MIPS启动stage2.png" alt="MIPS启动stage2" /><figcaption aria-hidden="true">MIPS启动stage2</figcaption></figure><h2 id="内存管理">内存管理</h2><p>地址空间：程序使用的逻辑地址的集合</p><p>存储空间：存储信息的物理地址的集合</p><p>单道程序环境下，可进行静态地址翻译（程序运行之前确定所有物理地址），且地址独立、地址保护</p><h3 id="多道程序的存储管理">多道程序的存储管理</h3><p>内碎片：指分配给作业的存储空间中未被利用的部分</p><p>外碎片：指系统中无法利用的小的空闲分区</p><p>跟踪内存：</p><ul><li>位图表示法，每个分配单元赋予一个字位，记录该分配单元是否闲置</li><li>链表表示法，将空闲单元用链表连接起来</li></ul><h4 id="固定式分区">固定式分区</h4><p>把内存划分为若干个固定大小的连续分区。</p><ul><li>易于实现，开销小。</li><li>内碎片造成浪费，分区总数固定，限制了并发执行的程序数目。</li></ul><h4 id="可变式分区">可变式分区</h4><p>分区的边界可以移动，即分区的大小可变。</p><ul><li>无内碎片</li><li>有外碎片</li></ul><h4 id="分配算法">分配算法</h4><ol type="1"><li>首次适应算法（FirstFit）：从空白区域链的<strong>始端</strong>开始查找，选择第一个足以满足请求的空白块。——低地址留下很多难以利用的小的空闲分区</li><li>下次适应算法（NextFit）：从上次查找结束的地方开始，只要找到一个足够大的空白区。——缺乏大的空闲分区</li><li>最佳适应算法（BestFit）：寻找大小最接近于作业所要求的存储区域——剩下的空闲区太小</li><li>最坏适应算法（WorstFit）：总是寻找最大的空白区——需要大空间的作业得不到满足</li><li>快速适应算法：把空闲分区按容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。——查找效率高，不会对任何分区分割；算法复杂，系统开销大</li><li>伙伴系统：在分配存储块时将一个大的存储块分裂成两个大小相等的小块，这两个小块就称为“伙伴”。具体实现如下</li></ol><h3 id="程序的存储分配">程序的存储分配</h3><h4 id="分配方式">分配方式</h4><ol type="1"><li>直接指定。程序员在编写程序时指定</li><li>静态分配。程序员编程时,或由编译程序产生的目的程序,均可从其地址空间的零地址开始；当装配程序对其进行链接装入时才确定它们在主存中的地址。</li><li>动态分配。作业在存储空间中的位置,在其装入时确定,在其执行过程中可根据需要申请附加的存储空间,而且一个作业已占用的部分区域不再需要时,可以要求归还给系统。</li></ol><h4 id="由源码到可执行">由源码到可执行</h4><ol type="1"><li>编译：用户源程序-&gt;若干个目标模块</li><li>链接：目标模块+库函数-&gt;可装载模块（通常是单一可执行文件）<ul><li>静态链接：用户一个工程中所需的多个程序采用静态链接的方式链接在一起。当我们希望共享库的函数代码直接链接入程序代码中，也采用静态链接方式</li><li>动态链接：用于链接共享库代码。当程序运行中需要某些目标模块时，才对它们进行链接，具有高效且节省内存空间的优点。但相比静态链接，使用动态链接库的程序相对慢。</li></ul></li><li>装入：可装载模块-&gt;装入内存<ul><li>一般采用动态运行时装入方式</li></ul></li></ol><p>为了保证程序在内存中的位置可以改变。装入程序把装入模块装入内存后，并不立即把装入模块中相对地址转换为绝对地址，而是在程序运行时才进行</p><h4 id="程序段">程序段</h4><p>一个程序主要由bss段、data段、text段三个组成的。在C语言之类的程序编译完成之后，已初始化的全局变量保存在data段中，未初始化的全局变量保存在bss 段中。</p><ul><li>bss段（bsssegment）：用来存放程序中未初始化的全局变量的一块内存区域。属于静态内存分配。</li><li>data段（datasegment）：用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li><li>text段（code segment/textsegment）：用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)</li></ul><p>text和data段在链接后的可执行文件中</p><p>gcc:</p><ul><li>cc1：预处理器和编译器</li><li>as：汇编器</li><li>collect2：链接器</li></ul><h3 id="程序运行">程序运行</h3><h4 id="栈帧与调用规范">栈帧与调用规范</h4><p>当前函数A调用子函数B，会将子函数B的参数压到自己的栈帧里，并且先压最后一个参数。</p><h4 id="装载">装载</h4><p>一个segment在文件中的大小小于等于其在内存中的大小</p><h4 id="作业进程和程序">作业、进程和程序</h4><p>一个作业通常包括程序、数据和操作说明书3部分。每一个进程由进程控制块PCB、程序和数据集合组成。这说明程序是进程的一部分，是进程的实体。因此，一个作业可划分为若干个进程来完成，而每一个进程由其实体——程序和数据集合。一个程序可以作为多个进程的运行程序；一个进程也可以运行多个程序</p><h3 id="页式存储">页式存储</h3><h4 id="机制">机制</h4><p>以32位逻辑地址、二级页表、每级页表大小4KB为例</p><figure><img src="/img/OS/二级页表.png" alt="二级页表" /><figcaption aria-hidden="true">二级页表</figcaption></figure><p>虚拟地址分为3部分，31-22位这10位代表一级页表的第几项，21-12位这10位代表二级页表的第几项，页内偏移量则是对应的物理页中的偏移。</p><p>设虚拟地址为 <code>va</code> ，一级页表基地址为 <code>pgdir</code> ，<code>PDX(va)</code> 代表高10位，<code>PTX(va)</code> 代表中间10位。</p><p>存取过程先拿到一级页表基地址和虚拟地址高10位，从而找到对应的一级页表表项。即<code>pgdir+PDX(va)</code>为对应表项的物理地址，<code>*(pgdir+PDX(va))</code>为一级页表表项的内容，记为 <code>pde=*(pgdir+PDX(va))</code></p><p>然后，<code>pde</code> 是二级页表的基地址，从而通过<code>pde+PTX(va)</code>拿到对应的二级页表表项的物理地址，<code>*(pde+PTX(va))</code>为二级页表表项的内容，记为 <code>pte</code></p><p><code>pte</code> 就是虚拟地址对应的物理页的地址，此时只需将<code>pte</code> 低12位换成 <code>va</code> 的低12位就拿到<code>va</code> 对应的物理地址了。</p><ul><li>使得逻辑地址可以大于物理地址大小</li><li>多级页表可解决一级页表占用存储空间较大的问题</li><li>MMU可解决内存访问效率下降的问题（不分页访存1次，二级页表访存3次）</li></ul><h4 id="页目录自映射">页目录自映射</h4><p>仍然以32位逻辑地址、二级页表、每级页表大小4KB为例</p><p>32位逻辑地址-&gt;2<sup>20个页表-&gt;每个页表项4字节-&gt;4MB-&gt;2</sup>10个一级页表-&gt;4KB</p><p>其中，一级页表称页目录，所有页目录项共占用4KB空间，刚好和页表大小一致。因此，可以将页目录项作为特殊的页表，放入二级页表项中</p><p>设所有页表（二级页表）的基地址为 <code>PTbase</code>，共2^20个页表项，总共占用4MB空间。其中有一个页表大小（4KB）放的是页目录，它的基地址设为<code>PDbase</code>，是页表基地址在整个逻辑地址中的相对位置映射到4MB中的位置，即<code>PDbase=(PTbase&gt;&gt;22)&lt;&lt;12+PTbase</code>。右移22，得到页表基地址是逻辑空间中的第几页，左移12，乘以每页的大小。自映射目录表项<code>PDE=(PDbase&gt;&gt;22)&lt;&lt;12+PDbase</code></p><h4 id="缺页错误处理过程">缺页错误处理过程</h4><p>当进程执行过程中需访问的页面不在物理存储器（内存）中时，会引发发生缺页中断，进行所需页面换入，步骤如下：</p><ol type="1"><li><p>陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护）</p></li><li><p>查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位）</p></li><li><p>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查）缺页错误处理过程</p></li><li><p>查找一个空闲的页框(物理内存中的页面)，如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框。</p></li><li><p>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回）</p></li><li><p>页框“干净”后，操作系统将保存在磁盘上的页面内容复制到该页框中。</p></li><li><p>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</p></li><li><p>恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场）</p></li><li><p>程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）</p></li></ol><h4 id="页面置换算法">页面置换算法</h4><p>先进先出（First-in, First-out）：先调入内存的页面先被置换出去</p><p>改进的FIFO：A是FIFO队列中最旧的页面，且其放入队列后没有被再次访问，则A被立刻淘汰；否则如果放入队列后被访问过，则将A移到FIFO队列头，并且将访问标志位清除。</p><p>改进的FIFO之Clock：环形队列，产生缺页错误时，当前指针指向C，如果C被访问过，则清除C的访问标志，并将指针指向下一位；如果C没有被访问过，则将新页面放入到C的位置,置访问标志，并将指针指向下一位。</p><p>最近最少使用（LRU）：设置一个特殊的栈，保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最久未使用页面的页面号</p><p>老化算法（AGING）：为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入</p><h3 id="段式存储">段式存储</h3><p>每个作业的地址空间是由一些分段构成的，每段都有自己的名字（通常是段号），且都是一段连续的地址空间。逻辑地址结构为段号+位移量（加起来不一定是32位）</p><h5 id="段表">段表</h5><p>• 段表记录了段与内存位置的对应关系。</p><p>• 段表保存在内存中。</p><p>• 段表的基址及长度由段表寄存器给出。</p><p>• 访问一个字节的数据/指令需访问内存两次 (段表一次，内存一次)</p><h5 id="地址变换过程">地址变换过程</h5><ol type="1"><li>系统将逻辑地址中的段号 S 与段表长度 TL 进行比较。<ul><li>若 S&gt;TL，表示段号太大，是访问越界，于是产生越界中断信号。</li><li>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的始址。</li></ul></li><li>再检查段内地址 d，是否超过该段的段长 SL。<ul><li>若超过，即 d &gt;SL，同样发出越界中断信号。</li><li>若未越界，则将该段的基址与段内地址 d相加，即可得到要访问的内存物理地址</li></ul></li></ol><h5 id="优缺点">优缺点</h5><ul><li>分段系统易于实现段的共享，对段的保护也十分简单。</li><li>处理机要为地址变换花费时间；要为表格提供附加的存储空间。</li><li>为满足分段的动态增长和减少外碎片，要采用拼接手段。</li><li>在辅存中管理不定长度的分段困难较多。</li><li>分段的最大尺寸受到主存可用空间的限制。</li></ul><h4 id="段页式">段页式</h4><p>将用户程序分成若干个段（段式），并为每一个段赋一个段名，再把每个段分成若干个页（页式）。地址结构由段号、段内页号、及页内位移三部分所组成</p><h2 id="进程与并发程序设计">进程与并发程序设计</h2><h3 id="一些概念">一些概念</h3><p>并发：两个活动在某一指定时间下，无论在同一处理机还是不同处理机，都在各自的起点和终点之间的某一处</p><p>并行：两个程序在同一时间度量下同时运行在不同的处理机上</p><p>进程特征：</p><ul><li>并发</li><li>共享</li><li>不确定性</li></ul><p><strong>并发条件</strong>——Bernstein条件：</p><p>定义 <span class="math inline">\(R(S_i)\)</span> 为进程 <spanclass="math inline">\(S_i\)</span> 的读子集，<spanclass="math inline">\(W(S_i)\)</span> 为 <spanclass="math inline">\(S_i\)</span>的写子集，则当一下条件同时成立时，进程 <spanclass="math inline">\(S_1\)</span> 和 <spanclass="math inline">\(S_2\)</span> 可并发</p><ul><li><span class="math inline">\(R(S_1)\capW(S_2)=\emptyset\)</span></li><li><span class="math inline">\(W(S_1)\capR(S_2)=\emptyset\)</span></li><li><span class="math inline">\(W(S_1)\capW(S_2)=\emptyset\)</span></li></ul><p><strong>原语</strong>：由若干条指令所组成的指令序列，来实现某个特定的操作功能。</p><ul><li>连续不可分割</li><li>操作系统核心组成部分</li><li>内核态下执行，且常驻内存</li></ul><p>竞争：两个或多个进程对同一共享数据同时进行访问，而最后的结果是不可预测的，它取决于各个进程对共享数据访问的相对次序。这种情形叫做竞争。</p><p>竞争条件：多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关</p><p>临界资源：我们将一次仅允许一个进程访问的资源称为临界资源</p><p>临界区：每个进程中访问临界资源的那段代码称为临界区。</p><p><strong>互斥</strong>：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但无法限制访问者对资源的访问顺序</p><p><strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。</p><p>互斥机制设计上的原则：</p><ul><li>空闲让进：临界资源处于空闲状态，允许进入临界区</li><li>忙则等待：临界区有正在执行的进程，所有其他进程不可进入临界区</li><li>有限等待：对要求访问临界区的进程应在保证在有限时间内进入自己的临界区，避免死等</li><li>让权等待：当进程（长时间）不能进入自己的临界区时，应立即释放处理机，尽量避免忙等。</li></ul><h3 id="线程">线程</h3><p>进程是资源分配的基本单位，线程是处理机调度的基本单位</p><p>每个线程由自己的堆栈</p><p>线程安全!=可重入</p><p>用户级线程：线程在用户空间，通过Library模拟，不需要或仅需极少的内核支持</p><ul><li>优点：<ul><li>线程切换与内核无关</li><li>线程调度由应用决定，易优化</li><li>可运行在任何操作系统上</li></ul></li><li>缺点：<ul><li>系统调用时阻塞所有属于此进程的线程</li><li>线程间无法并行</li></ul></li></ul><p>内核级线程：</p><ul><li>优点：<ul><li>可并行</li><li>内核中的一些处理可以通过多线程实现</li><li>涉及两种模式的切换</li></ul></li></ul><h3 id="互斥的实现">互斥的实现</h3><h4 id="忙等">忙等</h4><h5 id="dekker">Dekker</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//进程P</span><br>pturn=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(qturn)&#123;<br>    <span class="hljs-keyword">if</span>(turn==<span class="hljs-number">1</span>)&#123;<br>pturn=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(turn==<span class="hljs-number">1</span>);<br>        pturn=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*临界区*/</span><br>turn=<span class="hljs-number">1</span>;<br>pturn=<span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//进程Q</span><br>qturn=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(pturn)&#123;<br>    <span class="hljs-keyword">if</span>(turn==<span class="hljs-number">0</span>)&#123;<br>qturn=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(turn==<span class="hljs-number">0</span>);<br>        qturn=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*临界区*/</span><br>turn=<span class="hljs-number">0</span>;<br>qturn=<span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="信号量">信号量</h4><p>使用一种新的变量类型（semaphore）作为信号量。信号量使用前必须初始化，初始化后只能通过PV操作访问，PV操作不受进程调度的打断。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pascal"><span class="hljs-keyword">Type</span> semaphore = <span class="hljs-keyword">record</span><br>value : integer;<br>L : list <span class="hljs-keyword">of</span> process;<br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">Procedure</span> <span class="hljs-title">P</span><span class="hljs-params">(S)</span></span><br><span class="hljs-function"><span class="hljs-title">var</span> <span class="hljs-title">S</span> :</span> semaphore;<br><span class="hljs-keyword">begin</span> <br>S.value := S.value -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> S.value&lt;<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> block(S.L);<br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">V</span><span class="hljs-params">(S)</span></span><br><span class="hljs-function"><span class="hljs-title">var</span> <span class="hljs-title">S</span> :</span> semaphore;<br><span class="hljs-keyword">begin</span><br>S.value := S.value + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> S.value&lt;=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> wakeup(S.L)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>P操作分配资源，V操作释放资源。</p><h3 id="经典进程同步问题">经典进程同步问题</h3><h4 id="生产者-消费者">生产者-消费者</h4><p>问题描述：若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//互斥</span><br>semaphore empty=N;<span class="hljs-comment">//空闲数量</span><br>semaphore full=<span class="hljs-number">0</span>;<span class="hljs-comment">//产品数量</span><br>ItemType buffer[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>, out =<span class="hljs-number">0</span>;<br>producer() &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>生产产品nextp;<br>P(empty);<br>P(mutex);<br>buffer[in] = nextp;<br>in = (in + <span class="hljs-number">1</span>) MOD n;<br>V(mutex);<br>V(full);<br>&#125;<br>&#125;<br>consumer() &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>P(full);<br>P(mutex);<br>nextc = buffer[out];<br>out = (out + <span class="hljs-number">1</span>) MOD n;<br>V(mutex);<br>V(empty);<br>消费nextc中的产品<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读者-写者问题">读者-写者问题</h4><p>问题描述：对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个，即“读－写”互斥，“写－写”互斥，“读－读”允许</p><h5 id="读者优先">读者优先</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore wmutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//允许写</span><br><span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;<span class="hljs-comment">//正在读的数量</span><br>semaphore mutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//对readcount的互斥</span><br><br><span class="hljs-comment">//Writer</span><br>P(wmutex);<br>write;<br>V(wmutex);<br><br><span class="hljs-comment">//Reader</span><br>P(mutex);<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then P(wmutex);<br>readcount := readcount +<span class="hljs-number">1</span>;<br>V(mutex);<br>read<br><span class="hljs-title function_">P</span><span class="hljs-params">(mutex)</span><br>readcount := readcount <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then V(wmutex);<br>V(mutex)<br></code></pre></td></tr></table></figure><h5 id="读写公平">读写公平</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore wmutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//允许写</span><br><span class="hljs-type">int</span> readcount=<span class="hljs-number">0</span>;<span class="hljs-comment">//正在读的数量</span><br>semaphore mutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//对readcount的互斥</span><br>semaphore rwmutex =<span class="hljs-number">1</span>;<span class="hljs-comment">//对readcount的互斥</span><br><br><span class="hljs-comment">//Writer</span><br>P(rwmutex);<br>P(wmutex);<br>write;<br>V(wmutex);<br>V(rwmutex);<br><br><span class="hljs-comment">//Reader</span><br>P(rwmutex);<br>P(mutex);<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then P(wmutex);<br>readcount := readcount +<span class="hljs-number">1</span>;<br>V(mutex);<br>V(rwmutex);<br>read<br><span class="hljs-title function_">P</span><span class="hljs-params">(mutex)</span><br>readcount := readcount <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then V(wmutex);<br>V(mutex)<br></code></pre></td></tr></table></figure><h5 id="写者优先">写者优先</h5><h4 id="哲学家进餐问题">哲学家进餐问题</h4><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。</p><p>如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐；不出现有人永远拿不到筷子</p><p>思路：</p><ul><li><p>至多只允许四个哲学家同时（尝试）进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。设置信号量room=4。（破除<strong>资源互斥</strong>）</p></li><li><p>对筷子进行编号，奇数号先拿左，再拿右；偶数号相反。（破除<strong>循环等待</strong>）</p></li><li><p>同时拿起两根筷子，否则不拿起。（破除<strong>保持等待</strong>）</p></li></ul><h4 id="理发师问题">理发师问题</h4><p>理发店里有1位理发师、1把理发椅和n把供等候理发的顾客坐的椅子；如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师；如果理发师正在理发时，又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> waiting = <span class="hljs-number">0</span>;<br>semaphore mutex=<span class="hljs-number">1</span>;<br>semaphore custormers=<span class="hljs-number">0</span>;<br>semaphore barber=<span class="hljs-number">0</span>;<br><br>Barber:<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>P(custormers);<br>P(mutex);<br>waiting --;<br>V(mutex);<br>V(barber);<br>CutHair();<br>&#125;<br><br>Custom_i:<br>P(mutex);<br><span class="hljs-keyword">if</span> (waiting &lt; N) &#123;<br>waiting ++;<br>V(mutex);<br>V(custormers);<br>P(barber);<br>GetCutHair();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>V(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进程调度">进程调度</h3><p>进程切换步骤：</p><ol type="1"><li>保存处理器的上下文，包括程序计数器和其它寄存器</li><li>用新状态和其它相关信息更新正在运行进程的PCB</li><li>把进程移至合适的队列：就绪、阻塞</li><li>选择另一个要执行的进程更新被选中进程的PCB（新状态等）</li><li>从被选中进程中重装入CPU 上下文</li></ol><h4 id="评价指标">评价指标</h4><p>周转时间：作业从提交到完成所经历的时间，包括执行、等待时间</p><p>平均周转时间：所有作业周转时间的平均值</p><p>带权周转时间：周转时间/服务时间</p><p>响应时间：用户输入一个请求，系统首次给出响应的时间</p><p>吞吐量：单位时间内所完成的作业数（不等于平均周转时间的倒数）</p><p>处理机利用率：忙碌时间/总时间</p><h4 id="调度细节">调度细节</h4><p>进程优先级：</p><ul><li>静态优先级：运行过程中不再改变</li><li>动态优先级：运行过程中可以动态变化</li></ul><p>进程就绪队列：</p><ul><li>按优先级排队，CPU调度优先级较高的进程执行</li><li>创建时都进入第一级，随进程运行，可能降低某些进程的优先级</li></ul><p>占用CPU的方式：</p><ul><li><p>不可抢占式：一旦处理器被分配给一个进程，就死赖着不走，直到进程调度</p></li><li><p>抢占式：就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，让位</p></li></ul><p>进程分类：</p><p>CPU密集/IO密集</p><p>批处理/交互式进程/实时进程</p><h4 id="批处理调度算法">批处理调度算法</h4><p>特点：不要求交互、实时性不强</p><h5 id="先来先服务fcfs">先来先服务FCFS</h5><p>字面意思</p><h5 id="短作业优先sjf">短作业优先SJF</h5><p>对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业</p><p>优点：</p><ul><li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li><li>提高系统吞吐量</li></ul><p>缺点：</p><ul><li>对长作业非常不利，可能长时间得不到执行；</li><li>未能依据作业的紧迫程度来划分执行的优先级</li><li>难以准确估计作业（进程）的执行时间，从而影响调度性能。</li></ul><h5 id="最短剩余时间srtf">最短剩余时间SRTF</h5><p>将SJF改为抢占式</p><p>缺点：源源不断的短任务到来，可能使长的任务长时间得不到运行，导致产生“饥饿”现象</p><h5 id="最高响应比优先hrrf">最高响应比优先HRRF</h5><p>在每次选择作业投入运行时，先计算后备作业队列中每个作业的响应比RP(响应优先级)，然后选择其值最大的作业投入运行。</p><p><spanclass="math inline">\(\text{RR}=\dfrac{\text{已等待时间+要求运行时间}}{要求运行时间}\)</span>​</p><p>短作业容易得到较高的响应比，长作业等待时间足够长后，也将获得足够高的响应比。饥饿现象不会发生</p><p>缺点：每次计算各道作业的响应比会有一定的时间开销，性能比SJF略差。</p><h4 id="交互式系统的调度算法">交互式系统的调度算法</h4><h5 id="时间片轮转round-robin算法">时间片轮转(Round Robin)算法</h5><p>【排队】将系统中所有的就绪进程按照FCFS原则，排成一个队列。</p><p>【轮转】每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。</p><p>【中断】在一个时间片结束时，发生时钟中断。</p><p>【抢占】调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。</p><p>【出让】进程可以未使用完一个时间片，就出让CPU（如阻塞）。</p><h5 id="多级队列算法">多级队列算法</h5><p>引入多个就绪队列，每个队列固定归入一个队列，不同队列可有不同的优先级、时间片长度、调度策略等。</p><h5 id="多级反馈队列算法">多级反馈队列算法</h5><p>设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍</p><p>新进程进入内存后，先投入队列1的末尾，按“时间片轮转”算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按“时间片轮转”算法调度；如此下去，降低到最后的队列，则按“FCFS”算法调度直到完成。</p><p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</p><p>问题：优先级倒置（高优先级进程被低优先级进程阻塞）。解决：优先级置顶、优先级继承（同一临界资源）</p><h4 id="实时系统的调度算法">实时系统的调度算法</h4><p>特点：实时性强</p><h5 id="静态表调度">静态表调度</h5><p>事先确定固定的调度方案</p><h5 id="单调速率调度">单调速率调度</h5><p>优先级静态固定分配：优先级与周期成反比，周期越短优先级越高。优先级高的任务先被调度。如果两个任务的优先级一样，当调度它们时，RM算法将随机选择一个调度</p><p>任务在周期起点释放，高优先级任务可抢占低优先级任务的执行</p><h5 id="最早截止时间优先算法">最早截止时间优先算法</h5><p>任务的绝对截止时间越早，其优先级越高，优先级最高的任务最先被调度（动态优先级）</p><p>如果两个任务的优先级一样，当调度它们时，EDF算法将随机选择一个调度</p><h5 id="最低松弛度优先算法llf">最低松弛度优先算法LLF</h5><p>根据任务紧急（或松弛）的程度，来确定任务的优先级。任务的紧急度越高，其优先级越高，并使之优先执行。</p><p>松弛度=进程截止时间-本身剩余运行时间-当前时间</p><p>=进程最晚开始时间-当前时间</p><h4 id="多处理机调度">多处理机调度</h4><p>（对称式多处理系统SMP）</p><p>集中控制：静态、动态分配。分散控制：自调度</p><ul><li><p>静态分配：每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个CPU上。</p><ul><li>优点：调度算法开销小。</li><li>缺点：容易出现忙闲不均</li></ul></li><li><p>动态分配：所有CPU采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。</p></li><li><p>自调度：整个系统采用一个公共就绪队列，每个处理机都可以从队列中选择适当进程来执行。可采用单处理机的（成熟）调度技术，是最常用的算法，实现时易于移植。</p><ul><li>优点：不需要专门的处理机从事任务分派工作。</li><li>缺点：队列同步开销：各处理机共享就绪队列；缓存更新开销：被阻塞的进程重新运行时不一定仍在阻塞前的处理机上运行，那么高速缓存中的内容需要重置；线程协作开销：由于合作中的几个线程没有同时运行而受阻，进而被切换下来</li></ul></li><li><p>成组调度：将一个进程中的一组线程，每次分派时同时到一组处理机上执行，在剥夺处理机时也同时对这一组线程进行</p><ul><li>优点：通常这样的一组线程在应用逻辑上相互合作，成组调度提高了这些线程的执行并行度，有利于减少阻塞和加快推进速度，最终提高系统吞吐量。每次调度可以完成多个线程的分派，在系统内线程总数相同时能够减少调度次数，从而减少调度算法的开销</li></ul></li><li><p>专用处理机调度：为进程中的每个线程都固定分配一个CPU，直到该线程执行完成（多用于CPU数量众多的高度并行系统）</p><ul><li>优点：线程执行时不需切换，相应的开销可以大大减小，推进速度更快。</li><li>缺点：线程阻塞时，造成CPU的闲置。</li></ul></li></ul><h3 id="死锁">死锁</h3><p>定义：一组进程中，每个进程都无限等待被该组进程中其它进程所占有的资源，在无外力介入的条件下，将因永远分配不到资源而无法运行的现象。</p><p>发生原因： 资源竞争、并发执行的顺序不当</p><p>发生的必要条件</p><ul><li>互斥条件：指进程对所分配到的资源进行<strong>排它性使用</strong>，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求且占有条件：指进程已经占有至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己<strong>已获得的其它资源保持不放</strong>。</li><li>不可剥夺条件：指进程已获得的资源，在未使用完之前，<strong>不能被剥夺</strong>，只能在使用完时由自己释放。</li><li>环路等待条件：</li><li>指在发生死锁时，<strong>必然存在一个进程——资源的环形链</strong>，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><p>活锁：任务一直尝试、失败、尝试、失败，但没有被阻塞</p><p>饥饿：资源分配不公导致长时间等待</p><figure><img src="/img/OS/死锁.png" alt="死锁" /><figcaption aria-hidden="true">死锁</figcaption></figure><h4 id="死锁预防">死锁预防</h4><p>破坏死锁的产生条件</p><p>某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m+n，试讨论，该系统可能发生死锁吗?并简述理由。</p><p>答：不可能。最坏情况下，n个进程同时申请了m+n-1台打印机，但每个进程都1差台才能完成，则实际已经分配了m-1台，还剩一台打印机可分配给任意进程解除等待状态，因此不会死锁</p><h4 id="死锁避免">死锁避免</h4><p>在资源分配之前进行判断</p><p>安全序列：一个进程序列&lt;P1，P2，...，Pn&gt;是安全的，是指若对于每一个进程Pi，它需要的附加资源可以被系统中当前可用资源加上所有进程Pj（j&lt;i）当前占有资源之和所满足，则&lt;P1，P2，...，Pn&gt;为一个安全序列</p><p>安全状态：系统存在一个安全序列。否则为不安全状态（但不一定死锁，但死锁必不安全）。</p><p>银行家算法：假定顾客借款分成若干次进行；并在第一次借款时，能说明他的最大借款额。具体算法：顾客的借款操作依次顺序进行，直到全部操作完成；银行家对当前顾客的借款操作进行判断，以确定其安全性（能否支持顾客借款，直到全部归还）；安全时，贷款；否则，暂不贷款</p><h4 id="死锁检测">死锁检测</h4><figure><img src="/img/OS/资源分配图1.png" alt="资源分配图1" /><figcaption aria-hidden="true">资源分配图1</figcaption></figure><figure><img src="/img/OS/资源分配图2.png" alt="资源分配图2" /><figcaption aria-hidden="true">资源分配图2</figcaption></figure><h4 id="死锁解除">死锁解除</h4><ul><li>撤销进程：使全部死锁的进程夭折掉；按照某种顺序逐个地撤消（回退）进程，直至有足够的资源可用，死锁状态消除为止。</li><li>剥夺资源：使用挂起/激活挂起一些进程，剥夺它们的资源以解除死锁，待条件满足时，再激活进程</li></ul><h2 id="io">IO</h2><p>IO设备分为块设备和字符设备</p><figure><img src="/img/OS/IO层次关系.png" alt="IO层次关系" /><figcaption aria-hidden="true">IO层次关系</figcaption></figure><h3 id="io控制技术">IO控制技术</h3><h4 id="程序控制">程序控制</h4><p>称轮询或查询方式I/O，它由CPU代表进程向I/O模块发出指令，然后进入忙等状态， 直到操作完成之后进程才能够继续执行。</p><figure><img src="/img/OS/轮询IO.png" alt="轮询IO" /><figcaption aria-hidden="true">轮询IO</figcaption></figure><h4 id="中断驱动">中断驱动</h4><p>当I/O操作结束后由设备控制器主动地来通知设备驱动程序说这次结束，而不是设备驱动程序不断地去轮询看看设备的状态。</p><ul><li>优点：CPU不必忙等，提高CPU利用率，可以处理不确定事件</li><li>缺点：每次输入、输出一个数据都要中断CPU，多次中断浪费CPU时间</li></ul><figure><img src="/img/OS/中断IO.png" alt="中断IO" /><figcaption aria-hidden="true">中断IO</figcaption></figure><h4 id="dma">DMA</h4><p>直接存储器访问方式，是由一个专门的控制器来完成数据从内存到设备或者是从设备到内存的传输工作。</p><ul><li>优点：CPU只需干预I/O操作的开始和结束，而其中的一批数据读写无需CPU控制，适于高速设备。</li><li>缺点：数据传送的方向、存放数据的内存地址及传送数据的长度等都由CPU控制，占用了CPU时间。而且每个设备占用一个DMA控制器，当设备增加时，需要增加新的DMA控制器</li></ul><p>与中断区别：</p><ul><li>中断控制方式在每个数据传送完成后中断CPU；DMA控制方式是在要求传送的一批数据完成之后中断CPU。</li><li>中断控制方式的数据传送是在中断处理时由CPU控制完成的，由于程序陷入内核，需要保护和恢复现场。DMA方式下是由DMA控制器控制完成的，在传输过程中不需要CPU干预，DMA控制器直接在主存和I/O设备之间传送数据，只有开始和结束才需要CPU干预。</li><li>程序中断方式具有对异常事件的处理能力，而DMA控制方式适用于数据块的传输。</li></ul><h4 id="通道">通道</h4><p>与DMA的原理几乎是一样的，通道是一个特殊功能的处理器，它有自己的指令和程序专门负责数据输入输出的传输控制。CPU将“传输控制”的功能下放给通道后只负责“数据处理”功能。这样，通道与CPU分时使用内存，实现了CPU内部运算与I/O设备的并行工作。</p><ul><li>DMA方式的发展，进一步减少CPU干预。把对一个数据块的读写干预，减少为对一组数据块读写的干预。</li><li>I/O通道是专门负责输入输出的处理器，独立于CPU，有自己的指令体系。可执行由通道指令组成的通道程序，因此可以进行较为复杂的I/O控制。通道程序通常由操作系统所构造，放在内存里。</li><li>优点：执行一个通道程序可以完成几组I/O操作，与DMA相比，减少了CPU干预。</li><li>缺点：费用较高。</li></ul><p>与DMA区别：</p><ul><li>DMA方式下，数据的传送方向、存放数据的内存起始地址和数据块长度都由CPU控制；而通道是一个特殊的处理器，有自己的指令和程序，通过执行通道程序实现对数据传输的控制，所以通道具有更强的独立处理I/O的功能。</li><li>DMA控制器通常只能控制一台或者少数几台同类设备；而一个通道可同时控制多种设备</li></ul><h3 id="缓冲">缓冲</h3><ul><li>匹配CPU与外设的不同处理速度</li><li>减少对CPU的中断次数。</li><li>提高CPU和I/O设备之间的并行性。</li></ul><p>种类：单缓冲、双缓冲、环形缓冲、缓冲池</p><h3 id="设备分配">设备分配</h3><ul><li><p>DCT：设备控制表，每个设备一张，描述设备的特性和状态</p></li><li><p>COCT：控制器控制表（如DMA控制器，描述DMA占用的中断号……）。</p></li><li><p>CHCT：通道控制表，描述通道工作状态</p></li><li><p>SDT：系统设备表，系统内一张，记录所有设备相关信息。包括DCT指针等</p></li></ul><p>分配过程：</p><ol type="1"><li>根据物理设备名查SDT，找到对应的DCT，若设备忙则等待，否则计算是否死锁然后进行分配</li><li>将设备分配给进程后，找到DCT所属的COCT，空闲则分配，否则等待</li><li>找到COCT所属CHCT，空闲则分配，否则等待</li></ol><h3 id="假脱机技术">假脱机技术</h3><p>把独享设备转变成具有共享特征的虚拟设备，从而提高设备利用率。</p><p>应用程序进行I/O操作时，只是和SPOOLing程序交换数据，可以称为虚拟I/O</p><p>特点：</p><ul><li>高速。应用程序的虚拟I/O比实际I/O速度提高</li><li>独享设备的共享。由SPOOLing程序提供虚拟设备，可以对独享设备依次共享使用</li></ul><h2 id="磁盘存储管理">磁盘存储管理</h2><h3 id="基本概念">基本概念</h3><figure><img src="/img/OS/磁盘概念.png" alt="磁盘概念" /><figcaption aria-hidden="true">磁盘概念</figcaption></figure><p>磁盘访问时间=寻道时间+旋转延迟时间+传输时间</p><h4 id="寻道时间">寻道时间</h4><p>把磁头从当前位置移动到指定磁道上所经历的时间。该时间是启动磁盘的时间s与磁头移动n条磁道所花费的时间之和</p><p><span class="math inline">\(T_s=m\times n+s\)</span></p><h4 id="旋转延迟时间">旋转延迟时间</h4><p>3600RPM即每分钟3600转——每秒60转——每转16.7ms——平均旋转延迟时间 <spanclass="math inline">\(T_r\)</span> 为8.3ms</p><h4 id="传输时间">传输时间</h4><p>指把数据从磁盘读出，或向磁盘写入数据所经历的时间，与每次所读／写的字节数b，旋转速度r以及磁道上的字节数N有关</p><p><span class="math inline">\(T_t=\dfrac{b}{rN}\)</span></p><h3 id="磁盘调度算法">磁盘调度算法</h3><h4 id="先来先服务fcfs-1">先来先服务（FCFS）</h4><p>按访问请求到达的先后次序服务</p><h4 id="最短寻道时间优先算法sstf">最短寻道时间优先算法（SSTF）</h4><p>优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。</p><ul><li>优点：改善了磁盘平均服务时间</li><li>缺点：可能产生“饥饿” 现象，造成某些访问请求长期等待得不到服务。</li></ul><h4 id="扫描算法scan">扫描算法（SCAN）</h4><p>类似电梯调度中的LOOK算法，但是要到边界才返回</p><p>当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。</p><ul><li>优点：既考虑了距离，又考虑了方向</li><li>缺点：摆动式扫描，两侧磁道访问概率仍低于中间磁道</li></ul><h4 id="循环扫描算法cscan">循环扫描算法（CSCAN）</h4><p>按照所要访问的柱面位置的次序去选择访问者。移动臂到达最后一个柱面后，立即带动读写磁头快速返回到0号柱面。返回时不为任何的等待访问者服务。返回后可再次进行扫描。</p><h4 id="look">LOOK</h4><p>把到边界才返回的scan类算法改成到离边界最近的请求处返回，就产生了LOOK、C-LOOK算法</p><h4 id="n-step-scan">N-Step-SCAN</h4><p>将请求队列分成分成长度为N的子队列，队列之间采用FCFS，队列内部采用SCAN</p><ul><li>可以解决“磁壁粘着”问题：一个或几个进程对某个磁道有较高的访问频率，从而垄断了整个磁盘设备</li></ul><p>N=2时成为FSCAN</p><h3 id="raid">RAID</h3><p>一种把多块独立的硬盘（物理硬盘）按照不同方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据冗余的技术。</p><ul><li>成本低、功耗小、传输速率高、可提供容错功能</li></ul><figure><img src="/img/OS/RAID说明.png" alt="RAID说明" /><figcaption aria-hidden="true">RAID说明</figcaption></figure><h4 id="raid0">RAID0</h4><p>仅提供了并行交叉存取，提高IO速度，但无冗余功能</p><h4 id="raid1">RAID1</h4><p>镜像磁盘冗余阵列，将每一数据块重复存入镜像磁盘</p><ul><li>读性能好，写性能由最差磁盘决定</li><li>有效容量减半</li></ul><h4 id="raid-01">RAID 01</h4><p>综合RAID0和RAID1的特点</p><p>其中RAID0+1指先分块后镜像，物理磁盘与镜像磁盘间无明显一一对应关系</p><p>RAID 1+0指先镜像后分块，物理磁盘与镜像磁盘间一一对应关系</p><h4 id="raid2">RAID2</h4><p>采用海明码纠错的磁盘阵列，将数据位交叉写入几个磁盘中。按位条带化。</p><ul><li><p>并行存取，各个驱动器同步工作。</p></li><li><p>使用海明编码来进行错误检测和纠正，数据传输率高。</p></li><li><p>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。</p></li></ul><h4 id="raid3">RAID3</h4><p>将磁盘分组，采用字节级别的条带，读写要访问组中所有盘，每组中有一个盘作为校验盘。校验盘一般采用奇偶校验</p><ul><li>恢复时间较长</li><li>读写性能的水桶效应瓶颈</li></ul><h4 id="raid4">RAID4</h4><p>并行处理磁盘阵列：一种独立传送磁盘阵列，采用数据块交叉，用一个校验盘。将数据按块交叉存储在多个磁盘上</p><figure><img src="/img/OS/RAID4.png" alt="RAID4" /><figcaption aria-hidden="true">RAID4</figcaption></figure><ul><li><p>冗余代价与RAID3相同</p></li><li><p>访问数据的方法与RAID3不同。在RAID3中，一次磁盘访问将对磁盘阵列中的所有磁盘进行（同步）操作。</p></li><li><p>RAID4出现的原因：希望使用较少的磁盘参与操作，以使磁盘阵列可以并行进行多个数据的磁盘操作。</p></li><li><p>随机读快，随机写慢（竞争同一个校验盘）</p></li></ul><h4 id="raid5">RAID5</h4><p>一种独立传送磁盘阵列，采用数据块交叉和分布的冗余校验，将数据和校验都分布在各个磁盘中，没有专门的奇偶校验驱动器</p><figure><img src="/img/OS/RAID5.png" alt="RAID5" /><figcaption aria-hidden="true">RAID5</figcaption></figure><h4 id="raid6">RAID6</h4><p>双维校验独立存取盘阵列，数据以块（块大小可变）交叉方式存于各盘，检、纠错信息均匀分布在所有磁盘上。</p><figure><img src="/img/OS/RAID6.png" alt="RAID6" /><figcaption aria-hidden="true">RAID6</figcaption></figure><ul><li><p>写入数据要访问1个数据盘和2个冗余盘；</p></li><li><p>可容忍双盘出错；</p></li><li><p>存储开销是RAID5的两倍（多一个冗余盘）。</p></li></ul><h3 id="提高io速度">提高IO速度</h3><ul><li>选择性能好的磁盘</li><li>并行化</li><li>采用适当的调度算法</li><li>设置磁盘高速缓冲区</li></ul><h2 id="文件管理">文件管理</h2><h3 id="基本概念-1">基本概念</h3><p>需求：存储<strong>大量</strong>数据、<strong>长期</strong>保存、可<strong>共享</strong></p><p>文件：一种抽象机制，可以视为一个单独的连续的逻辑地址空间，其大小即为文件的大小，与进程的地址空间无关。或：信息项的序列（信息项是构成文件的基本单位，由单个字节或多个字节构成）</p><p>文件系统：本质为操作系统中统一管理信息资源的一个软件</p><p>Unix将文件分为普通文件、目录文件、特殊文件</p><ul><li>普通文件：用户自己建立的文件</li><li>目录文件：管理文件系统的系统文件</li><li>特殊文件：字符设备文件（和输入输出有关，如中断、打印机等）、块设备文件（磁带、磁盘等）</li></ul><p>文件系统模型的三个层次分别为文件系统接口、对象操作管理的软件集合、对象及其属性</p><p>提高文件系统性能：磁盘碎片整理、块高速缓存、RAID</p><h3 id="文件结构">文件结构</h3><p>逻辑结构上，有字节序列、记录序列、树等</p><ul><li>流式文件：基本单位为字符，有逻辑意义无结构</li><li>记录式文件：由若干条记录组成，可以按记录进行读写、查找等操作。每条记录有其内部结构</li></ul><h4 id="目录">目录</h4><p>文件目录是由文件说明索引组成的用于文件检索的特殊文件。文件目录的内容一般不包括文件内容，主要是文件访问和控制信息</p><ul><li>单级文件目录</li><li>二级文件目录（根目录+用户目录）</li><li>多级文件目录（内容文下一级目录名+指向下一级目录的指针+指向文件物理地址的指针）。层次清楚、可解决重名问题、查找速度快，但目录级数过多会增加路径检索时间</li></ul><p>文件目录有两种实现方法：</p><ul><li>直接法：目录项=文件名+FCB（如MS-DS/Windows）</li><li>间接法：目录项=文件名+FCB的地址（如Unix采用inode）</li></ul><h4 id="文件控制块fcb">文件控制块（FCB）</h4><ul><li>基本信息：文件名、物理位置、文件逻辑结构、物理结构等</li><li>访问控制信息：文件所有者、访问权限等</li><li>使用信息：创建时间、上一次修改时间等</li></ul><h4 id="文件物理结构">文件物理结构</h4><p>文件在存储介质上的存放方式</p><h5 id="连续结构">连续结构</h5><figure><img src="/img/OS/文件连续存储.png" alt="文件连续存储" /><figcaption aria-hidden="true">文件连续存储</figcaption></figure><ul><li>优点：<ul><li>结构简单、实现容易、没有额外开销</li><li>支持顺序存取、随机存取</li></ul></li><li>缺点：<ul><li>文件长度不易改变</li><li>不利于文件的动态增加和修改</li></ul></li></ul><p>适用于变化不大的顺序访问的文件</p><h5 id="串联链接文件结构">串联/链接文件结构</h5><figure><img src="/img/OS/链接存储结构.png" alt="链接存储结构" /><figcaption aria-hidden="true">链接存储结构</figcaption></figure><ul><li>优点：<ul><li>空间利用率高；能较好的利用辅存空间</li><li>文件动态扩充和修改容易</li><li>顺序存取效率高</li></ul></li><li>缺点：<ul><li>随机存取效率太低</li><li>可靠性问题，如指针出错</li><li>链接指针占用一定的空间</li></ul></li></ul><h5 id="索引结构">索引结构</h5><p>索引文件在存储区中占两个区：索引区和数据区。索引区存放索引表，数据区存放数据文件本身。</p><p>访问索引文件需要两步操作：查文件索引号，由逻辑块号查得物理块号；由此磁盘物理块号而获得所要求的信息</p><ul><li>优点：<ul><li>既能顺序存取，又能随机存取</li><li>满足了文件动态增长、插入删除的要求</li><li>能充分利用外存空间</li></ul></li><li>缺点：索引表本身带来了系统开销</li></ul><figure><img src="/img/OS/索引存储结构.png" alt="索引存储结构" /><figcaption aria-hidden="true">索引存储结构</figcaption></figure><h3 id="磁盘空间的管理">磁盘空间的管理</h3><h4 id="空闲表">空闲表</h4><table><thead><tr class="header"><th style="text-align: center;">序号</th><th style="text-align: center;">第一块空闲盘块号</th><th style="text-align: center;">空闲盘块数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">9</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">15</td><td style="text-align: center;">5</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td></tr></tbody></table><h4 id="空闲链表">空闲链表</h4><p>将所有的空闲盘区连成一条空闲链，可有两种方式：空闲盘块链（可能很长）、空闲盘区链（不会很长，但回收复杂）。</p><h4 id="位图">位图</h4><figure><img src="/img/OS/位图法.png" alt="位图法" /><figcaption aria-hidden="true">位图法</figcaption></figure><h4 id="成组链接">成组链接</h4><figure><img src="/img/OS/成组链接法.png" alt="成组链接法" /><figcaption aria-hidden="true">成组链接法</figcaption></figure><h3 id="文件保护">文件保护</h3><p>方法：</p><ul><li>建立副本</li><li>定时转储(Unix)</li><li>规定文件的权限</li></ul><p>文件一致性检查：</p><ul><li><p>磁盘块的一致性：每个磁盘块设置两个计数器，一个记录在文件中出现的次数，另一个记录在空闲块中出现的次数，最终检查两个计数器是否存在不一致问题。</p></li><li><p>文件的一致性：每个文件设置两个计数器，一个记录其i节点被引用的次数，另一个记录文件目录中引用它的次数，最终检查两个计数器是否存在不一致问题</p></li></ul><h3 id="文件系统实例">文件系统实例</h3><h4 id="fat文件系统ms-dos">FAT文件系统（MS DOS）</h4><p>主引导记录(MBR)+分区表+分区</p><p>分区中，引导区（文件系统数据）+文件分配表FAT（描述簇的分配状态、下一簇簇号等等）</p><figure><img src="/img/OS/FAT-DOS.png" alt="FAT-DOS" /><figcaption aria-hidden="true">FAT-DOS</figcaption></figure><p>目录项大小为32字节，包括文件名、子目录、文件长度、第一簇的编号。文件名不区分大小写</p><figure><img src="/img/OS/FAT2.png" alt="FAT2" /><figcaption aria-hidden="true">FAT2</figcaption></figure><h3 id="ext2文件系统">ext2文件系统</h3><p>利用索引节点(inode)来描述，每个文件对应一个inode，inode对应一个标识符，inode保存在索引节点表中。</p><p>目录也有索引节点，索引节点指向目录项</p><figure><img src="/img/OS/EXT2.png" alt="EXT2" /><figcaption aria-hidden="true">EXT2</figcaption></figure><p>文件系统的超块包含文件系统基本形式</p><p>组描述符</p><figure><img src="/img/OS/索引节点inode.png" alt="索引节点inode" /><figcaption aria-hidden="true">索引节点inode</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS挑战性任务设计文档</title>
    <link href="/2024/07/02/shell-challenge%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/07/02/shell-challenge%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><p>OS仓库链接：</p><p><a href="/files/guide-book.pdf">指导书</a></p><p><ahref="/files/vscode连接远程跳板机.pdf">使用vscode连接远程服务器</a></p><h3 id="实现不带-.b-后缀指令">实现不带 <code>.b</code> 后缀指令</h3><p>在 <code>user/lib/spawn.c</code> 中修改 <code>spawn</code>函数，当直接执行失败时，再原参数后面加上".b"重新执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd;<br><span class="hljs-keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(prog);<br><span class="hljs-type">char</span> myprog[len+<span class="hljs-number">2</span>];<br><span class="hljs-built_in">strcpy</span>(myprog,prog);<br>myprog[len]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>myprog[len+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;b&#x27;</span>;<br>myprog[len+<span class="hljs-number">2</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">if</span> ((fd = open(myprog, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> fd;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现指令条件执行">实现指令条件执行</h3><p>在进程控制块中增加 <code>env_return_value</code>，存储返回值，并编写相应系统调用来修改返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_env_set_return_value</span><span class="hljs-params">(u_int envid,<span class="hljs-type">int</span> value,<span class="hljs-type">int</span> isreceived)</span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span>* <span class="hljs-title">e</span>;</span><br>try(envid2env(envid, &amp;e, <span class="hljs-number">0</span>));<br>e-&gt;env_return_value=value;<br>e-&gt;env_isreceived=isreceived;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>user/lib/libos.c</code>中，将main函数返回值存储并送至父进程（spawn）的父进程（fork）处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> r=main(argc, argv);<br>r=syscall_env_set_return_value(envs[ENVX(env-&gt;env_parent_id)].env_parent_id,r,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>最后修改sh.c中的解析过程（以 <code>&amp;&amp;</code>为例），当前面指令执行为非0时，跳过后面的指令直至遇到<code>||</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">ch=gettoken(<span class="hljs-number">0</span>, &amp;t);<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&amp;&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span>(dupflag)&#123;<br>dup(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>dup(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>&#125;<br>r=fork();<br>*rightpipe=r;<br><span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> argc;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>wait(r);<br><span class="hljs-type">int</span> value=env-&gt;env_return_value;<br><span class="hljs-keyword">if</span>(!value)<br><span class="hljs-keyword">return</span> parsecmd(argv, rightpipe,post);<br><span class="hljs-keyword">else</span><br>&#123;<br>close_all();<br><span class="hljs-built_in">exit</span>();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，对于管道指令，判断之后先存储argv[0]=t，并通过post表示递归调用argc时的初始值为1</p><h3 id="实现更多指令">实现更多指令</h3><p>总体上，新建相应 <code>.c</code> 文件，而后在 <code>user</code>目录下的 <code>include.mk</code> 中加上相应的 <code>.b</code>文件即可，如下所示</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">USERAPPS     := num.b  \<br>touch.b \<br>mkdir.b \<br>rm.b \<br></code></pre></td></tr></table></figure><h4 id="touch">touch</h4><p>直接调用 <code>open</code> 函数即可，对返回值进行判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">f=open(argv[<span class="hljs-number">1</span>],O_CREAT);<br><span class="hljs-keyword">if</span>(f&lt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mkdir">mkdir</h4><p>类似touch，调用 <code>open</code> 函数，但需要在<code>fs/serv.c</code> 中修改 <code>serve_open</code> 函数，当请求模式为<code>O_MKDIR</code> 时，将文件的类型标记为目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((rq-&gt;req_omode &amp; O_MKDIR) &amp;&amp; (r = file_create(rq-&gt;req_path, &amp;f)) &lt; <span class="hljs-number">0</span> &amp;&amp;<br>    r != -E_FILE_EXISTS) &#123;<br>ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(rq-&gt;req_omode &amp; O_MKDIR)&#123;<br>f-&gt;f_type=FTYPE_DIR;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在mkdir中调用即可</p><h4 id="rm">rm</h4><p>同样类似touch，但需要新增请求模式。</p><p>首先在 <code>user/include/lib.h</code> 中新增<code>#define O_TYPE 0x1000</code> ，表示对文件类型的查询。</p><p>其次在 <code>user/lib/file.c</code> 的 <code>open</code>函数中新增对模式的判断，如果是查询文件类型，则在ipc调用之后立刻返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">r=fsipc_open(path,mode,fd);<br><span class="hljs-keyword">if</span>(mode&amp;O_TYPE)&#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，也要在 <code>fs/serv.c</code> 中修改 <code>serve_open</code>函数，当请求模式为 <code>O_TYPE</code>时，找到文件后直接返回文件类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((rq-&gt;req_omode &amp; O_TYPE) &amp;&amp; (r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="hljs-number">0</span> &amp;&amp;<br>    r != -E_FILE_EXISTS) &#123;<br>ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(rq-&gt;req_omode &amp; O_TYPE)&#123;<br>ipc_send(envid, f-&gt;f_type, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现注释">实现注释</h3><p>修改 <code>user/sh.c</code> 中的 <code>main</code> 函数，当<code>buf</code> 中首次出现 <code>#</code> 时，相应位置赋值为为<code>'\0'</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;buf[i];i++)<br>&#123;<br><span class="hljs-keyword">if</span>(buf[i]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>buf[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>runcmd(buf);<br><span class="hljs-built_in">exit</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>wait(r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现历史指令">实现历史指令</h3><h4 id="历史指令的存储">历史指令的存储</h4><p>分为两部分，一部分为全局变量，另一部分保存在<code>.mosh_history</code>中，两部分的内容一样，但全局变量更容易存取。其中histcmd相当于循环链表，hist表示下一条指令应当写入到哪里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> HISTFILESIZE 20</span><br><span class="hljs-type">int</span> hist;<span class="hljs-comment">//该写哪条指令了</span><br><span class="hljs-type">char</span> histcmd[HISTFILESIZE][<span class="hljs-number">1024</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">wirte_history</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> tmpflag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;buf[i];i++)&#123;<br><span class="hljs-keyword">if</span>(buf[i]!=<span class="hljs-string">&#x27;\t&#x27;</span>||buf[i]!=<span class="hljs-string">&#x27;\r&#x27;</span>||buf[i]!=<span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>tmpflag=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!tmpflag)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_RDONLY);<br><span class="hljs-keyword">if</span>(f&lt;<span class="hljs-number">0</span>)&#123;<br>f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_CREAT);<br>&#125;<br>close(f);<br><br><span class="hljs-keyword">if</span>(hist&lt;HISTFILESIZE&amp;&amp;histcmd[hist][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<span class="hljs-comment">//还没满</span><br>f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_RWR|O_WRONLY);<br><span class="hljs-built_in">strcpy</span>(histcmd[hist],buf);<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(buf);<br>histcmd[hist][len]=<span class="hljs-string">&#x27;\n&#x27;</span>;<br>histcmd[hist][len+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>write(f,histcmd[hist],<span class="hljs-built_in">strlen</span>(histcmd[hist]));<br>close(f);<br>hist++;<br>        <span class="hljs-keyword">if</span>(hist==HISTFILESIZE)&#123;<br>hist=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">strcpy</span>(histcmd[hist],buf);<br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(buf);<br>histcmd[hist][len]=<span class="hljs-string">&#x27;\n&#x27;</span>;<br>histcmd[hist][len+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_WRONLY|O_TRUNC);<br>hist++;<br><span class="hljs-keyword">if</span>(hist==HISTFILESIZE)&#123;<br>hist=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> flag=hist;<br>write(f,histcmd[hist],<span class="hljs-built_in">strlen</span>(histcmd[hist]));<br>close(f);<br>f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_RWR|O_WRONLY);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>hist++;<br><span class="hljs-keyword">if</span>(hist==HISTFILESIZE)&#123;<br>hist=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(hist==flag)&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>write(f,histcmd[hist],<span class="hljs-built_in">strlen</span>(histcmd[hist]));<br>&#125;<br>&#125;<br>lasthist=<span class="hljs-number">-1</span>;<br>lastcmd[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现up和down">实现up和down</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>&amp;&amp;buf[i<span class="hljs-number">-2</span>]==<span class="hljs-number">27</span>&amp;&amp;buf[i<span class="hljs-number">-1</span>]==<span class="hljs-number">91</span>&amp;&amp;buf[i]==<span class="hljs-number">65</span>)&#123;<br>i-=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c%c%c&quot;</span>,<span class="hljs-number">27</span>,<span class="hljs-number">91</span>,<span class="hljs-number">66</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\b \b&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(lasthist==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">strcpy</span>(lastcmd,buf);<br>lastcmd[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(lasthist==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">if</span>(hist==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(histcmd[HISTFILESIZE<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>lasthist=HISTFILESIZE<span class="hljs-number">-1</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>lasthist=<span class="hljs-number">0</span>;<span class="hljs-comment">//已经是最前面的指令</span><br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>lasthist=hist<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(lasthist==<span class="hljs-number">0</span>&amp;&amp;histcmd[HISTFILESIZE<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>;<span class="hljs-comment">//已经是最前面的指令</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(lasthist==hist)&#123;<br>;<span class="hljs-comment">//已经是最前面的指令</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>lasthist--;<br><span class="hljs-keyword">if</span>(lasthist&lt;<span class="hljs-number">0</span>)&#123;<br>lasthist=HISTFILESIZE<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">strcpy</span>(buf,histcmd[lasthist]);<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>i=<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>&amp;&amp;buf[i<span class="hljs-number">-2</span>]==<span class="hljs-number">27</span>&amp;&amp;buf[i<span class="hljs-number">-1</span>]==<span class="hljs-number">91</span>&amp;&amp;buf[i]==<span class="hljs-number">66</span>)&#123;<br>i-=<span class="hljs-number">2</span>;<br><span class="hljs-comment">//printf(&quot;%c%c%c&quot;,27,91,65);</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\b \b&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(lasthist==<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">strcpy</span>(lastcmd,buf);<br>lastcmd[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(lasthist==<span class="hljs-number">-1</span>)&#123;<br>lasthist==<span class="hljs-number">-2</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>((hist==<span class="hljs-number">0</span>&amp;&amp;lasthist==HISTFILESIZE<span class="hljs-number">-1</span>)||(hist&amp;&amp;lasthist==hist<span class="hljs-number">-1</span>))&#123;<br>lasthist=<span class="hljs-number">-2</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>lasthist++;<br><span class="hljs-keyword">if</span>(lasthist&gt;=HISTFILESIZE)&#123;<br>lasthist=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(histcmd[lasthist][<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>lasthist=<span class="hljs-number">-2</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(lasthist&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">strcpy</span>(buf,lastcmd);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">strcpy</span>(buf,histcmd[lasthist]);<br>&#125;<br><span class="hljs-keyword">if</span>(buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>i=<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现history">实现history</h4><p>在 <code>runcmd</code> 函数中进行判断即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;history&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> f=open(<span class="hljs-string">&quot;.mosh_history&quot;</span>,O_RDONLY);<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">10240</span>];<br>readn(f,tmp,<span class="hljs-number">10240</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,tmp);<br><span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现一行多指令">实现一行多指令</h3><p>修改 <code>user/sh.c</code> 中的 <code>parsecmd</code> 函数即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>:<br>r=fork();<br>*rightpipe=r;<br><span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> argc;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>wait(r);<br><span class="hljs-keyword">return</span> parsecmd(argv, rightpipe);<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h3 id="实现反引号">实现反引号</h3><p>在 <code>sh.c</code> 的 <code>_gettoken</code>函数中，首先创建管道，然后fork，让子进程执行反引号中的内容，并在父进程中通过管道读取结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*s==<span class="hljs-string">&#x27;`&#x27;</span>)&#123;<br><span class="hljs-type">char</span> cmd[<span class="hljs-number">1024</span>];<br><span class="hljs-type">char</span> cmdans[<span class="hljs-number">1024</span>];<br><span class="hljs-type">char</span> after[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;s[i];i++)&#123;<br><span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;`&#x27;</span>)&#123;<br>cmd[i<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">strcpy</span>(after,s+i+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cmd[i<span class="hljs-number">-1</span>]=s[i];<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>pipe(p);<br><span class="hljs-type">int</span> r=fork();<br><span class="hljs-keyword">if</span>(r==<span class="hljs-number">0</span>)<br>&#123;<br>dup(p[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<br>close(p[<span class="hljs-number">0</span>]);<br>close(p[<span class="hljs-number">1</span>]);<br>runcmd(cmd);<br><span class="hljs-built_in">exit</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>close(p[<span class="hljs-number">1</span>]);<br><span class="hljs-type">int</span> len,pos=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>((len=read(p[<span class="hljs-number">0</span>],tmp,<span class="hljs-number">1024</span>))&gt;<span class="hljs-number">0</span>)&#123;<br>tmp[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">strcpy</span>(cmdans+pos,tmp);<br>pos+=len;<br>&#125;<br>close(p[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-built_in">strcpy</span>(s,cmdans);<br><span class="hljs-built_in">strcpy</span>(s+<span class="hljs-built_in">strlen</span>(cmdans),after);<br>s+=<span class="hljs-built_in">strlen</span>(cmdans)<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现重定向">实现重定向</h3><p>首先在 <code>user/include/lib.h</code> 中新增<code>#define O_RWR 0x2000</code> ，表示重定向写入。</p><p>其次在 <code>fs/serv.c</code> 的 <code>serv_open</code>函数中新增对模式的判断，如果是重定向写入，则修改offset。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(rq-&gt;req_omode &amp; O_RWR)&#123;<br>ff-&gt;f_fd.fd_offset =ff-&gt;f_file.f_size;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在 <code>sh.c</code> 的 <code>parsecmd</code> 中修改对<code>&gt;</code> 的处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;&gt;&#x27;</span>)&#123;<br>ch=gettoken(<span class="hljs-number">0</span>, &amp;t);<br><span class="hljs-keyword">if</span> (ch != <span class="hljs-string">&#x27;w&#x27;</span>) &#123;<br>debugf(<span class="hljs-string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);<br><span class="hljs-built_in">exit</span>();<br>&#125;<br>fd=open(t,O_RWR|O_WRONLY|O_CREAT);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>fd=open(t,O_WRONLY|O_TRUNC|O_CREAT);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现引号支持">实现引号支持</h3><p>在 <code>sh.c</code> 的 <code>_gettoken</code>函数中的第一个取空白代码段后面添加关于字符串的处理即可，即遇到引号则读到下一个引号为止，并返回<code>w</code> 的token</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(*s==<span class="hljs-string">&#x27;\&quot;&#x27;</span>)&#123;<br>*s++=<span class="hljs-number">0</span>;<br>*p1 = s;<br><span class="hljs-keyword">while</span> (*s &amp;&amp; *s!=<span class="hljs-string">&#x27;\&quot;&#x27;</span>) &#123;<br><span class="hljs-comment">//printf(&quot;%c&quot;,*s);</span><br>s++;<br>&#125;<br>*s++=<span class="hljs-number">0</span>;<br>*p2 = s;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;w&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(*s==<span class="hljs-string">&#x27;\&quot;&#x27;</span>)&#123;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">1024</span>];<br><span class="hljs-built_in">strcpy</span>(tmp,s+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(;tmp[j];j++)&#123;<br><span class="hljs-keyword">if</span>(tmp[j]==<span class="hljs-string">&#x27;\&quot;&#x27;</span>&amp;&amp;!flag)&#123;<br>flag=j;<br><span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>s[i++]=tmp[j];<br>&#125;<br>&#125;<br>s[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>s+=flag<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现前后台任务管理">实现前后台任务管理</h3><p><code>env.h</code> 文件中，新增宏定义、结构体定义、系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJOB 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Running 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Done 1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Job</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> job_id;<br><span class="hljs-type">int</span> status;<br><span class="hljs-type">int</span> env_id;<br><span class="hljs-type">char</span> cmd[<span class="hljs-number">1025</span>];<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add_job</span><span class="hljs-params">(<span class="hljs-type">int</span> envid,<span class="hljs-type">char</span> cmd[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">set_job_status</span><span class="hljs-params">(<span class="hljs-type">int</span> job_id,<span class="hljs-type">int</span> status)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_job</span><span class="hljs-params">(<span class="hljs-type">int</span> envid)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_job_envid</span><span class="hljs-params">(<span class="hljs-type">int</span> job_id)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">get_jobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Job usrjobs[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">print_jobs</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><code>env.h</code> 文件中，新增任务结构体、与系统调用实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Job</span> <span class="hljs-title">jobs</span>[<span class="hljs-title">MAXJOB</span>+1];</span><br><span class="hljs-type">int</span> job_cnt=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add_job</span><span class="hljs-params">(<span class="hljs-type">int</span> envid,<span class="hljs-type">char</span> cmd[])</span>&#123;<br><span class="hljs-keyword">if</span>(job_cnt&gt;=MAXJOB)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>job_cnt++;<br>jobs[job_cnt].job_id=job_cnt;<br>jobs[job_cnt].env_id=envid;<br>jobs[job_cnt].status=Running;<br><span class="hljs-built_in">strcpy</span>(jobs[job_cnt].cmd,cmd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">set_job_status</span><span class="hljs-params">(<span class="hljs-type">int</span> job_id,<span class="hljs-type">int</span> status)</span>&#123;<br><span class="hljs-keyword">if</span>(job_id&gt;<span class="hljs-number">0</span>&amp;&amp;job_id&lt;=job_cnt)&#123;<br>jobs[job_id].status=status;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_job</span><span class="hljs-params">(<span class="hljs-type">int</span> envid)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=job_cnt;i++)&#123;<br><span class="hljs-keyword">if</span>(jobs[i].env_id==envid)&#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_job_envid</span><span class="hljs-params">(<span class="hljs-type">int</span> job_id)</span>&#123;<br><span class="hljs-keyword">if</span>(job_id&gt;<span class="hljs-number">0</span>&amp;&amp;job_id&lt;=job_cnt)&#123;<br><span class="hljs-keyword">return</span> jobs[job_id].env_id;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_jobs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Job usrjobs[])</span>&#123;<br><br><span class="hljs-built_in">memcpy</span>(usrjobs,jobs,<span class="hljs-keyword">sizeof</span>(jobs));<br><br><span class="hljs-keyword">return</span> job_cnt;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">print_jobs</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=job_cnt;i++)&#123;<br><span class="hljs-keyword">if</span>(jobs[i].status==Running)<br>printk(<span class="hljs-string">&quot;[%d] %-10s 0x%08x %s\n&quot;</span>, jobs[i].job_id, <span class="hljs-string">&quot;Running&quot;</span>, jobs[i].env_id, jobs[i].cmd);<br><span class="hljs-keyword">else</span><br>printk(<span class="hljs-string">&quot;[%d] %-10s 0x%08x %s\n&quot;</span>, jobs[i].job_id, <span class="hljs-string">&quot;Done&quot;</span>, jobs[i].env_id, jobs[i].cmd);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>syscall.h  syscall_all.c  syscall_lib.c  lib.h</code>文件中，新增系统调用相关</p><p>kill的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_mykill</span><span class="hljs-params">(u_int envid)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>try(envid2env(envid, &amp;e, <span class="hljs-number">0</span>));<span class="hljs-comment">//不同</span><br><br>printk(<span class="hljs-string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);<br>env_destroy(e);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//return mykill(envid);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>add_job与标记完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//sh.c,runcmd</span><br><span class="hljs-keyword">if</span>(child&gt;<span class="hljs-number">0</span>&amp;&amp;*post)&#123;<br><span class="hljs-type">char</span> tmp[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;argc;i++)&#123;<br><span class="hljs-built_in">strcpy</span>(tmp+len,argv[i]);<br>len+=<span class="hljs-built_in">strlen</span>(argv[i]);<br>tmp[len++]=<span class="hljs-string">&#x27; &#x27;</span>;<br>tmp[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br>syscall_add_job(child,tmp);<br>&#125;<br><br><span class="hljs-comment">//libos.c</span><br><span class="hljs-type">int</span> job_id=syscall_get_job(env-&gt;env_id);<br><span class="hljs-keyword">if</span>(job_id&gt;<span class="hljs-number">0</span>)&#123;<br>syscall_set_job_status(job_id,Done);<br>&#125;<br></code></pre></td></tr></table></figure><p>jobs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;jobs&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>syscall_print_jobs();<br>close_all();<br><span class="hljs-built_in">exit</span>();<br>&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;fg&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> job_id=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;argv[<span class="hljs-number">1</span>][i];i++)&#123;<br><span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;argv[<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>job_id*=<span class="hljs-number">10</span>;<br>job_id+=argv[<span class="hljs-number">1</span>][i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> envid=syscall_get_job_envid(job_id);<br><span class="hljs-keyword">if</span>(envid!=<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">if</span>(syscall_get_job_status(job_id)!=Running)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fg: (0x%08x) not running\n&quot;</span>, envid);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>wait(envid);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fg: job (%d) do not exist\n&quot;</span>, job_id);<br>&#125;<br>close_all();<br><span class="hljs-built_in">exit</span>();<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>],<span class="hljs-string">&quot;kill&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> job_id=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;argv[<span class="hljs-number">1</span>][i];i++)&#123;<br><span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>][i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;argv[<span class="hljs-number">1</span>][i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>job_id*=<span class="hljs-number">10</span>;<br>job_id+=argv[<span class="hljs-number">1</span>][i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> envid=syscall_get_job_envid(job_id);<br><span class="hljs-keyword">if</span>(envid!=<span class="hljs-number">-1</span>)&#123;<br><span class="hljs-keyword">if</span>(syscall_get_job_status(job_id)!=Running)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fg: (0x%08x) not running\n&quot;</span>, envid);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>syscall_set_job_status(job_id,Done);<br>syscall_mykill(envid);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fg: job (%d) do not exist\n&quot;</span>, job_id);<br>&#125;<br>close_all();<br><span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="其他">其他</h3><p>syscall_all.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_cgetc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-type">int</span> ch;<br><span class="hljs-keyword">while</span> ((ch = scancharc()) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//新增，取消等待指令时的忙等</span><br>&#125;<br><span class="hljs-keyword">return</span> ch;<br>&#125;<br></code></pre></td></tr></table></figure><p>runcmd用int* post,表示是否为后台指令</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>离散3笔记</title>
    <link href="/2024/07/01/%E7%A6%BB%E6%95%A33%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/01/%E7%A6%BB%E6%95%A33%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h2 id="第二章-排列与组合">第二章 排列与组合</h2><h3 id="计数原理">计数原理</h3><p>加法原理：</p><p>乘法原理</p><p>减法原理：<span class="math inline">\(|A|=|U|-|\bar{A}|\)</span>​​</p><p>除法原理</p><h3 id="排列">排列</h3><p>与顺序有关的摆放/选择，默认线性排列</p><p>集合的一个排列即以某种顺序列出集合的所有元素（全排列）</p><p>排列数 <spanclass="math inline">\(P(n,k)=\dfrac{n!}{(n-k)!}=nP(n-1,k-1)=P(n-1,k)+kP(n-1,k-1)\)</span>​相当于n个元素选k个全排列，集合的k排列（有k个元素的排列）</p><p>循环排列：除法原理，每种循环排列对应n种线性排列，即 <spanclass="math inline">\((n-1)!\)</span>​</p><blockquote><p>项链题目下，翻转后相同，即对应2n种线性排列</p></blockquote><p>例外：n男n女相间坐在圆桌旁，则先排男，后排女，共 <spanclass="math inline">\((n-1)!n!\)</span> 种方法</p><h3 id="组合">组合</h3><p>与顺序无关的摆放/选择</p><p>组合数 <spanclass="math inline">\(\dbinom{n}{k}=\dfrac{n!}{k!(n-k)!}\)</span>​表示n个集合元素的k子集（有k个元素的子集）</p><p>帕斯卡公式：<spanclass="math inline">\(\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\)</span></p><h3 id="多重集">多重集</h3><h4 id="多重集的排列">多重集的排列</h4><p>允许元素重复的特殊“集合”，如 <spanclass="math inline">\(M=\{a,a,b,b,b\}\)</span> ，可写作 <spanclass="math inline">\(M=\{2\cdot a,3\cdot b\}\)</span> ，其中23称M的重数</p><p>无限重复数，k种不同元素，则S的r排列个数为 <spanclass="math inline">\(k^r\)</span></p><p>有限重复数全排列：设S是多重集，k种不同元素，每种重复数为 <spanclass="math inline">\(n_1\cdot a_1,n_2\cdot a_2,...,n_3\cdota_3\)</span> ，则所有元素的排列种数为 <spanclass="math inline">\(\dfrac{n!}{n_1!\cdot n_2!...n_k!}\)</span></p><p>也可解释为将n个元素的集合划分成k个有标签的盒子 <spanclass="math inline">\(B_1,B_2,...B_k\)</span> ，其中 <spanclass="math inline">\(B_i\)</span> 含有 <spanclass="math inline">\(n_i\)</span> 个元素，则划分方法数为 <spanclass="math inline">\(\dfrac{n!}{n_1!\cdot n_2!...n_k!}\)</span>。盒子无标号且 <span class="math inline">\(n_1=n_2=..=n_k\)</span> 则<span class="math inline">\(\dfrac{n!}{k!\cdot n_1!\cdotn_2!...n_k!}\)</span></p><blockquote><p>例题，车的排列</p></blockquote><h4 id="多重集的组合">多重集的组合</h4><p>多重集S的一个r组合是S的一个子多重集，可表示为方程 <spanclass="math inline">\(x_1+x_2+...+x_k=r\)</span>的非负整数解的个数，其中 <span class="math inline">\(0\leqslantx_i\leqslant\min(n_i,r)\)</span> ，或多重集 <spanclass="math inline">\(T=\{r\cdot 1,(k-1)\cdot *\}\)</span> 的r排列数</p><p>无限重复数下，r组合方法数为 <spanclass="math inline">\(\dbinom{r+k-1}{r}\)</span> （k个元素）</p><blockquote><p>证明：设有k=4个数字，每个数字可用无数次，问r=5组合是多少</p><p>以 <span class="math inline">\(\{2,3,3,3,4\}\)</span>为例，将其按大小顺序排好后 <spanclass="math inline">\(\{2,3,3,3,4\}\Leftrightarrow\{2+0,3+1,3+2,3+3,4+4\}=\{2,4,5,6,8\}\)</span></p><p>类似的，<spanclass="math inline">\(\{\infty\cdot1,\infty\cdot2,\infty\cdot3，\infty\cdot4\}\)</span>的5组合等价于 <span class="math inline">\(\{1,2,...,8\}\)</span>的5组合，从而得证</p></blockquote><blockquote><p>例题：取自 <span class="math inline">\(1,2,...k\)</span>的长为r的非递减序列个数为 <spanclass="math inline">\(\dbinom{r+k-1}{r}\)</span>​</p><p>例题2：从 <span class="math inline">\(1,2,...n\)</span> 中取出 <spanclass="math inline">\(r\)</span> 个不相邻的数的方法有 <spanclass="math inline">\(\dbinom{n-r+1}{r}\)</span>，可视为将取出的r个数插入剩下的n-r个数中</p></blockquote><p>技巧：灵活转化集合计数与方程解的个数问题，后者可用变量代换转化成新的问题。当有上界约束时，可枚举有上界的变量</p><table><thead><tr class="header"><th style="text-align: center;">n个元素</th><th style="text-align: center;">r排列</th><th style="text-align: center;">r组合</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">无重复</td><td style="text-align: center;"><spanclass="math inline">\(P(n,r)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dbinom{n}{r}\)</span></td></tr><tr class="even"><td style="text-align: center;">无限重复</td><td style="text-align: center;"><spanclass="math inline">\(n^r\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dbinom{n+r-1}{r}\)</span></td></tr><tr class="odd"><td style="text-align: center;">有限重复</td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{n!}{n_1!\cdot n_2!...n_k!}\)</span>（全排列）</td><td style="text-align: center;">容斥原理</td></tr></tbody></table><h2 id="鸽巢原理">鸽巢原理</h2><h3 id="简单形式">简单形式</h3><p>定义：如果把 <span class="math inline">\(n+1\)</span> 个物体放进<span class="math inline">\(n\)</span>​个盒子，那么至少有一个盒子包含两个或更多的物体</p><h4 id="划分类问题">划分类问题</h4><p>如果有n+1个整数，且整数小于等于2n，是否一定会有一对数互质？</p><p>答：存在。划分成n组相邻的数，必有相差1的一组数被同时取出。</p><h4 id="前缀和整除类">前缀和、整除类</h4><p>求证：在m个数正整数 <spanclass="math inline">\(a_1,a_2,...,a_m\)</span> 中，存在 <spanclass="math inline">\(0\leqslant k&lt;l&lt;m\)</span> ，使得 <spanclass="math inline">\(a_{k+1}+a_{k+2}+...+a_{l}\)</span> 能够被m整除</p><p>答：考虑前缀和，共m个，总有一个被m整除、或者除m的余数相同</p><h4 id="连续时间类">连续时间类</h4><p>某厂在五年期间的每一个月里至少试制一种新产品，每年最多试制19种新产品，试证明：一定存在连续几个月，恰好试制24种新产品</p><figure><img src="/img/离散3/连续时间类鸽巢原理.png" alt="连续时间类鸽巢原理" /><figcaption aria-hidden="true">连续时间类鸽巢原理</figcaption></figure><h4 id="中国剩余定理">中国剩余定理</h4><p>设<span class="math inline">\(m,n\)</span> 是互质的正整数， <spanclass="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 分别是小于 <spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(n\)</span> 的非负整数，则存在正整数 <spanclass="math inline">\(x\)</span> ，满足 <spanclass="math inline">\(x\equiv a\pmod{m},x\equiv b\pmod{n}\)</span></p><figure><img src="/img/离散3/年龄分组鸽巢.png" alt="年龄分组鸽巢" /><figcaption aria-hidden="true">年龄分组鸽巢</figcaption></figure><h3 id="加强形式">加强形式</h3><p>定义：令 <span class="math inline">\(q_1,q_2,...,q_n\)</span>为正整数，如果将 <spanclass="math inline">\(q_1+q_2+...+q_n-n+1\)</span> 个物体放进 <spanclass="math inline">\(n\)</span> 个盒子里，则：</p><ul><li>或者第1个盒子里至少含有 <span class="math inline">\(q_1\)</span>个物体，</li><li>或者第2个盒子里至少含有 <span class="math inline">\(q_2\)</span>个物体，</li><li>或者第 <span class="math inline">\(n\)</span> 个盒子里至少含有 <spanclass="math inline">\(q_n\)</span> 个物体。</li></ul><p>推论：设 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(r\)</span> 都是正整数，若 <spanclass="math inline">\(n(r-1)+1\)</span> 个物体放入 <spanclass="math inline">\(n\)</span> 个盒子，则至少有一个盒子含有至少 <spanclass="math inline">\(r\)</span> 个物体</p><h4 id="例题1">例题1：</h4><p>证明：从任意给出的5个正整数中必能选出3个数，它们的和能被3整除。</p><p>答：任意正整数除以3的余数只能为0，1或2。设A为任意给出的5个正整数的集合。设<span class="math inline">\(t_0,t_1,t_2\)</span>为A中除以3余数分别为0,1,2的数的个数。</p><ul><li><p>若 <span class="math inline">\(t_0,t_1,t_2\)</span> 均不为0，则一定有三个数除以3的余数分别为0,1,2，则这三个数的和能被3整除。</p></li><li><p>若 <span class="math inline">\(t_0,t_1,t_2\)</span>中至少有一个为0，不妨设 <span class="math inline">\(t_0=0\)</span> 则<span class="math inline">\(t_1+t_2=5\)</span></p></li></ul><p>由平均原理知，至少有 <spanclass="math inline">\(\lceil5/2\rceil=3\)</span>​个数除以3的余数相同（全为1或全为2），则这三个数的和能被3整除</p><blockquote><p>例题1.5：转盘问题，见PPT</p></blockquote><h4 id="例题2">例题2：</h4><p>证明由 <span class="math inline">\(n^2+1\)</span> 个实数构成的序列<span class="math inline">\(a_1,a_2,...,a_{n^2+1}\)</span>或者含有长度为n+1的递增子序列，或者含有长度为n+1的递减子序列</p><p>答：假设不存在长度为n+1的递增子序列，只需构造长度为n+1的递减子序列。</p><p>设 <span class="math inline">\(l_k\)</span> 是以 <spanclass="math inline">\(a_k\)</span> 为起始的最长递增子序列长度，<spanclass="math inline">\(k=1,2,...n^2+1\)</span> ，则对 <spanclass="math inline">\(\forall k\)</span> 有 <spanclass="math inline">\(1\leqslant l_k\leqslant n\)</span> 。对序列 <spanclass="math inline">\(l_1,l_2,...,l_{n^2+1}\)</span> ，一定存在 <spanclass="math inline">\(\lceil(n^2+1)/n\rceil=n+1\)</span> 个 <spanclass="math inline">\(l_i\)</span> 相等，设 <spanclass="math inline">\(l_{k_1}=l_{k_2}=...=l_{k_{n+1}}\)</span> ，其中<span class="math inline">\(1\leqslantk_1&lt;k_2&lt;...&lt;k_{n+1}\leqslant n^2+1\)</span> ，下证 <spanclass="math inline">\(a_{k_1},a_{k_2},...,a_{k_{n+1}}\)</span>是长度为n+1的递减序列</p><p>如果存在 <span class="math inline">\(k_i,k_{i+1}\)</span> ，使得<span class="math inline">\(a_{k_i}&lt;a_{k_{i+1}}\)</span> ，则可以把<span class="math inline">\(a_{k_i}\)</span> 加到以 <spanclass="math inline">\(a_{k_{i+1}}\)</span>开始的最长递增子序列的开头，则有 <spanclass="math inline">\(l_{k_i}&gt;l_{k_{i+1}}\)</span> ，矛盾。因此 <spanclass="math inline">\(a_{k_1},a_{k_2},...,a_{k_{n+1}}\)</span>为递减序列</p><h3 id="ramsey定理">Ramsey定理</h3><p>简单形式：6个人中或者有3个人彼此认识，或者有三个人彼此互不认识</p><p>定理：如果 <spanclass="math inline">\(m\geqslant2,n\geqslant2\)</span>，则一定存在正整数 <span class="math inline">\(p\)</span> 使得 <spanclass="math inline">\(K_p\rightarrow K_m,K_n\)</span> 。（当把 <spanclass="math inline">\(K_p\)</span>(有p个节点的完全图)的边着成红色或蓝色时，或者存在一个红色 <spanclass="math inline">\(K_m\)</span> ，或者存在一个蓝色 <spanclass="math inline">\(K_n\)</span> ）</p><p>定义：Ramsey数是使得 <span class="math inline">\(K_p\rightarrowK_m,K_n\)</span> 成立的最小整数p，记为 <spanclass="math inline">\(r(m,n)\)</span></p><ul><li><span class="math inline">\(r(m,n)=r(n,m)\)</span></li><li><span class="math inline">\(r(2,n)=n,r(m,2)=m\)</span></li><li><span class="math inline">\(r(m,n)\leqslantr(m-1,n)+r(m,n-1),m,n\geqslant3\)</span></li></ul><p>推广形式：多个颜色，即 <span class="math inline">\(K_p\rightarrowK_{n_1},K_{n_2},...,K_{n_l}\)</span> ，此时Ramsey数形式为 <spanclass="math inline">\(r(n_1,n_2,...,n_l)\)</span></p><h2 id="生成排列和组合">生成排列和组合</h2><h3 id="排列生成算法">排列生成算法</h3><h4 id="递归生成">递归生成</h4><h4 id="邻位对换">邻位对换</h4><p>对任一给定的正整数k，加上一个箭头使之成为 <spanclass="math inline">\(\overrightarrow{k}\)</span> 或 <spanclass="math inline">\(\overleftarrow{k}\)</span>。如果整数k的箭头指向与其相邻但比它小的整数，则称k是可移动的。</p><p>初始状态：<spanclass="math inline">\(\overleftarrow{1}\overleftarrow{2}...\overleftarrow{n}\)</span></p><p>若还存在活动整数，则</p><ul><li>求出最大的活动整数 <span class="math inline">\(m\)</span></li><li>交换m和其箭头指向的相邻整数的位置</li><li>改变所有满足 <span class="math inline">\(p&gt;m\)</span> 的整数<span class="math inline">\(p\)</span> 的箭头方向</li></ul><p>不存在活动整数时，算法结束</p><h3 id="排列的逆序">排列的逆序</h3><p>定义：设 <span class="math inline">\(i_1,i_2,...,i_n\)</span> 是集合<span class="math inline">\(\{1,2,...,n\}\)</span> 的一个排列，如果<span class="math inline">\(0\leqslant k&lt;l\leqslant n\)</span> ，且<span class="math inline">\(i_k&gt;i_l\)</span> ，称数对 <spanclass="math inline">\((i_k.i_l)\)</span>是排列的一个<strong>逆序</strong>。记 <spanclass="math inline">\(a_j\)</span> 是排列中先于整数 <spanclass="math inline">\(j\)</span> 并大于 <spanclass="math inline">\(j\)</span> 的个数，用于度量 <spanclass="math inline">\(j\)</span> 的反序程度，称为 <spanclass="math inline">\(j\)</span> 的<strong>逆序数</strong>，同时称排列<span class="math inline">\(a_1,a_2,...,a_n\)</span> 为排列 <spanclass="math inline">\(i_1,i_2,...,i_n\)</span>的<strong>逆序列</strong></p><p>排列和其逆序列一一对应，从逆序列求排列只需从最大数/最小数开始排即可</p><p>逆序个数为奇数称奇排列，反之称偶排列</p><h3 id="组合生成算法">组合生成算法</h3><p>n元集合 <spanclass="math inline">\(S=\{x_0,x_1,...,x_{n-1}\}\)</span>的所有组合与长度为n的二进制数一一对应</p><p>n阶Gray反射码：</p><ul><li>1阶反射码是0,1</li><li>设 <span class="math inline">\(n&gt;1\)</span>且n-1阶反射Gray码已经构造，则n阶反射Gray码如下<ul><li>以n-1阶的顺序列出，将0添加到开头</li><li>再反序将n-1列出，将1添加到开头</li></ul></li></ul><p>逐次法生成Gray码：</p><ol type="1"><li>初始 <spanclass="math inline">\(a_{n-1}...a_1a_0=0...00\)</span></li><li>当 <span class="math inline">\(a_{n-1}...a_1a_0\ne10...0\)</span>时，进行以下操作：<ul><li>计算 <spanclass="math inline">\(\sigma(a_{n-1}...a_1a_0)=a_{n-1}+...+a_1+a_0\)</span></li><li>如果 <span class="math inline">\(\sigma(a_{n-1}...a_1a_0)\)</span>是偶数，则改变 <span class="math inline">\(a_0\)</span>，否则确定j，使得 <span class="math inline">\(a_j=1\)</span> 且对于所有<span class="math inline">\(i&lt;j,a_i=0\)</span> ，改变 <spanclass="math inline">\(a_{j+1}\)</span></li></ul></li></ol><p>设 <span class="math inline">\(a_{n-1},...,a_1,a_0\)</span> ，定义<spanclass="math inline">\(b_i=\begin{cases}0,\sum\limits_i^{n-1}a_j是偶数\\1,\sum\limits_i^{n-1}a_j是奇数\end{cases}\)</span>，则 <span class="math inline">\(a_{n-1}...a_1a_0\)</span>在Gray码序表的位置是 <spanclass="math inline">\(b_{n-1}\times2^{n-1}+...+b_1\times2+b_0\)</span></p><h3 id="生成r子集">生成r子集</h3><p>子集的“先于”和“后继”：子集内部从小到大排列后，按字典序来。如 <spanclass="math inline">\(\{1,2,3\}\)</span> 先于 <spanclass="math inline">\(\{2,3,4\}\)</span></p><p><span class="math inline">\(\{1,2,...,n\}\)</span>的字典序r子集的生成算法：从12..r开始，逐个列出直接后继直至得到(n-r+1)(n-r+2)...n</p><h2 id="二项式系数">二项式系数</h2><h3 id="二项式">二项式</h3><p>帕斯卡公式：<spanclass="math inline">\(\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\)</span>​</p><p>二项式定理：<spanclass="math inline">\((x+y)^n=\sum\limits_{k=0}^n\dbinom{n}{k}x^{n-k}y^k\)</span></p><p>例：证明 <spanclass="math inline">\(\sum\limits_{k=0}^n\dbinom{n}{k}^2=\dbinom{2n}{n},n\geqslant0\)</span></p><p>答：右侧为从2n个集合中选n个元素，等号左侧即从2个n组元素中总共取n个元素的方法数</p><blockquote><p>证明方法：帕斯卡公式、求导积分、组合证明</p></blockquote><h3 id="链">链</h3><p>链：设S是n个元素的集合，S上的一条链是S的子集的集合C，其中对于C中的每一对子集，总有一个包含在另一个之中</p><p>最大链：n个元素的集合S，S上最大链 <spanclass="math inline">\(C=\{A_0,A_1,...,A_n\}\)</span> 满足 <spanclass="math inline">\(A_0=\phi\subset A_1...\subset A_n\)</span> ，且<span class="math inline">\(|A_i|=i(i=1,...,n)\)</span>。最大链的构造与排列类似，数目为 <spanclass="math inline">\(n!\)</span></p><p>反链：即没有子集包含在另一子集中</p><p>构造反链的方法之一：取集合S的所有k子集的集合。S上的一条反链最多包含<span class="math inline">\(\dbinom{n}{\lfloor n/2\rfloor}\)</span>个子集</p><p>链其实相当于有限偏序集的可比关系，反链即不可比</p><p>令 <span class="math inline">\((X,\leqslant)\)</span>是一个有限偏序集，令r是最大链的大小，则X可以被划分成r个反链，但不能被划分为少于r个反链</p><p>令 <span class="math inline">\((X,\leqslant)\)</span>是一个有限偏序集，令m是最大反链的大小，则X可以被划分成m个链，但不能被划分为少于m个链</p><p>对称链划分：设 <span class="math inline">\(S=\{1,2,...,n\}\)</span>，如果S的幂集 <span class="math inline">\(\mathcal{P}(S)\)</span>的一个链划分满足</p><ul><li>链中每一个子集比它前面的子集的元素个数多1</li><li>链中第一个子集与最后一个子集的大小和等于n</li></ul><blockquote><p>如 <span class="math inline">\(S=\{1,2,3\}\)</span> ，<spanclass="math inline">\(C_1:\phi\subset\{1\}\subset\{1,2\}\subset\{1,2,3\}\)</span>，<span class="math inline">\(C_2:\{2\}\subset\{2,3\}\)</span> ，<spanclass="math inline">\(C_3:\{3\}\subset\{1,3\}\)</span></p></blockquote><p>构造方法：</p><figure><img src="/img/离散3/对称链划分.png" alt="对称链划分" /><figcaption aria-hidden="true">对称链划分</figcaption></figure><h3 id="多项式定理">多项式定理</h3><p><spanclass="math inline">\((x_1+x_2+...+x_t)^n=\sum\limits_{n_1+n_2+...+n_t=n}\dbinom{n}{n_1n_2...n_t}x_1^{n_1}x_2^{n_2}...x_t^{n_t}\)</span></p><p>其中 <spanclass="math inline">\(\dbinom{n}{n_1n_2...n_t}=\dfrac{n!}{n_1!n_2!...n_t!}\)</span>为多项式系数</p><p>多项式的帕斯卡公式：<spanclass="math inline">\(\dbinom{n}{n_1n_2...n_t}=\dbinom{n-1}{(n_1-1)n_2...n_t}+\dbinom{n-1}{n_1(n_2-1)...n_t}+...\dbinom{n-1}{n_1n_2...(n_t-1)}\)</span></p><h3 id="牛顿二项式定理">牛顿二项式定理</h3><p>令 <span class="math inline">\(\alpha\)</span>是一个实数，对于所有满足 <spanclass="math inline">\(0\leqslant|x|&lt;|y|\)</span> 的变量x,y，有 <spanclass="math inline">\((x+y)^{\alpha}=\sum\limits_{k=0}^{\infty}\dbinom{\alpha}{k}x^ky^{\alpha-k}\)</span>，其中 <spanclass="math inline">\(\dbinom{\alpha}{k}=\dfrac{\alpha(\alpha-1)...(\alpha-k+1)}{k!}\)</span></p><p>应用：<spanclass="math inline">\((1+z)^{\alpha}=\sum\limits_{k=0}^{\infty}\dbinom{\alpha}{k}z^k\)</span>（ <span class="math inline">\(|z|&lt;1\)</span> ）</p><h2 id="容斥原理">容斥原理</h2><p>集合S不具有性质 <span class="math inline">\(P_1,P_2,...,P_m\)</span>的元素的个数为 <spanclass="math inline">\(|\overline{A_1}\cap...\cap\overline{A_m}|=|S|-\sum|A_i|+\sum|A_i\capA_j|-\sum|A_i\cap A_j\cap A_k|+...+(-1)^m|A_1\cap A_2\cap...\capA_m|\)</span></p><p>集合S至少具有性质 <spanclass="math inline">\(P_1,P_2,...,P_m\)</span> 之一的元素的个数为 <spanclass="math inline">\(|A_1\cup...\cup A_m|=\sum|A_i|-\sum|A_i\capA_j|+\sum|A_i\cap A_j\cap A_k|+...+(-1)^{m+1}|A_1\cap A_2\cap...\capA_m|\)</span></p><blockquote><p>一道有坑点的例题：求1-1000中不能被5、6、8整除的数</p><p>设 <span class="math inline">\(A_1,A_2,A_3\)</span>分别为能被5、6、8整除的数的集合，则 <span class="math inline">\(|A_2\capA_3|=\lfloor1000/24\rfloor\ne\lfloor1000/(6*8)\rfloor\)</span>​</p><p>最终答案为600</p></blockquote><h3 id="在多重集组合的应用">在多重集组合的应用</h3><p>例1:确定多重集 <span class="math inline">\(T=\{3·a,4·b,5·c\}\)</span>的10子集的个数 解: 令多重集 <spanclass="math inline">\(T^*=\{∞·a,∞·b,∞·g\}\)</span> 的所有10子集的集合为S， <span class="math inline">\(A_1\)</span> 是S中包含多于 3个a的10子集的集合, <span class="math inline">\(A_2\)</span> 是S中包含多于4个6 的10子集的集合, <span class="math inline">\(A_3\)</span>是S中包含多于 5个c的10子集的集合, 那么，T的10-组合数等于 <spanclass="math inline">\(|\bar{A_1}\cap \bar{A_2}\cap\bar{A_3}|\)</span></p><h3 id="错位排列">错位排列</h3><p><spanclass="math inline">\(D_n=n!(1-\dfrac{1}{1!}+\dfrac{1}{2!}-\dfrac{1}{3!}+...+(-1)^n\dfrac{1}{n!})\)</span></p><p><spanclass="math inline">\(D_n=(n-1)(D_{n-1}+D_{n-2})=nD_{n-1}+(-1)^n\)</span></p><p>禁止位置的排列：令 <spanclass="math inline">\(X_1,X_2,...,X_n\)</span> 是 <spanclass="math inline">\(\{1,2,...,n\}\)</span> 的子集，用 <spanclass="math inline">\(P(X_1,X_2,...,X_n)\)</span> 表示 <spanclass="math inline">\(\{1,2,...,n\}\)</span> 的排列 <spanclass="math inline">\(i_1i_2...i_n\)</span> 的集合，使得 <spanclass="math inline">\(i_1\notin X_1,i_2\notin X_2,...,且i_n\notinX_n\)</span> 。记 <spanclass="math inline">\(p(X_1,X_2,...,X_n)=|P(X_1,X_2,...,X_n)|\)</span>表示 <span class="math inline">\(P(X_1,X_2,...,X_n)\)</span>中排列的个数</p><blockquote><p>即对于P中的任意排列，位置i不能出现集合 <spanclass="math inline">\(X_i\)</span> 中的元素</p></blockquote><p>解决方法：容斥原理</p><p>应用：带禁止位置的“非攻击车”</p><figure><img src="/img/离散3/离散3_非攻击车.png" alt="离散3_非攻击车.png" /><figcaption aria-hidden="true">离散3_非攻击车.png</figcaption></figure><h3 id="相对禁止问题">相对禁止问题</h3><p>旋转木马</p><p><span class="math inline">\(Q_n=D_n+D_{n-1}\)</span></p><h2 id="生成函数与递推关系">生成函数与递推关系</h2><h3 id="常用展开式">常用展开式</h3><p><span class="math display">\[e^x=\sum\limits_{n=0}^\infty\dfrac{x^n}{n!}=1+x+\dfrac{x^2}{2!}+...+\dfrac{x^n}{n!}+...\\e^{-x}=\sum\limits_{n=0}^\infty(-1)^n\dfrac{x^n}{n!}=1-x+\dfrac{x^2}{2!}+...+(-1)^n\dfrac{x^n}{n!}+...\\\dfrac{1}{2}(e^x+e^{-x})=1+\dfrac{x^2}{2!}+\dfrac{4^2}{4!}+...+\dfrac{x^{2n}}{2n!}+...\\\dfrac{1}{2}(e^x-e^{-x})=x+\dfrac{x^3}{3!}+\dfrac{5^2}{5!}+...+\dfrac{x^{2n+1}}{(2n+1)!}+...\]</span></p><h3 id="生成函数">生成函数</h3><p>令 <span class="math inline">\(h_0,h_1,...,h_n,...\)</span>为一无穷数列，其生成函数 <span class="math inline">\(g(x)\)</span>定义为 <span class="math inline">\(g(x)=h_0+h_1 x+...+h_nx^n+...\)</span></p><h4 id="与多重集组合的关系">与多重集组合的关系</h4><p>设 <span class="math inline">\(h_n\)</span> 是多重集 <spanclass="math inline">\(S=\{\infty\cdot a_1,\infty\cdota_2\,...,\infty\cdot a_k\}\)</span> 的n组合的个数，求数列 <spanclass="math inline">\(h_0,h_1,...,h_n\)</span> 的生成函数 <spanclass="math inline">\(g(x)\)</span></p><p>因 <span class="math inline">\(h_n=\dbinom{n+k-1}{n}\)</span> ，所以<spanclass="math inline">\(g(x)=\sum\limits_{n=0}^\infty\dbinom{n+k-1}{n}x^n=\dfrac{1}{(1-x)^k}(|x|&lt;1)\)</span><span class="math display">\[\begin{aligned}g(x)&amp;=\dfrac{1}{(1-x)^k}=\dfrac{1}{1-x}\times\dfrac{1}{1-x}\times...\times\dfrac{1}{1-x}\\&amp;=(\sum\limits_{e_1=0}^\infty x^e_1)(\sum\limits_{e_2=0}^\inftyx^e_2)...(\sum\limits_{e_k=0}^\infty x^e_k)\\&amp;=(1+x+...+x^{e_1}+...)(1+x+...+x^{e_2}+...)...(1+x+...+x^{e_k}+...)\\&amp;=\sum\limits_{e_1+...+e_k=n=0}^\infty x^{e_1}x^{e_2}...x^{e_k}\end{aligned}\]</span> 其中，项 <spanclass="math inline">\(x^n=x^{e_1}x^{e_2}...x^{e_k}\)</span> 满足 <spanclass="math inline">\(e_1+e_2+...+e_k=n\)</span> ，因此项 <spanclass="math inline">\(x^n\)</span> 的系数 <spanclass="math inline">\(h_n\)</span> 是方程 <spanclass="math inline">\(e_1+e_2+...+e_k=n\)</span>的非负整数解的个数，也即n组合的个数</p><figure><img src="/img/离散3/生成函数.png" alt="生成函数" /><figcaption aria-hidden="true">生成函数</figcaption></figure><h4 id="与排列逆序数的关系">与排列逆序数的关系</h4><p>设 <span class="math inline">\(h(n,t)\)</span> 表示 <spanclass="math inline">\(\{1,2,...,n\}\)</span>的排列中有t个逆序的排列的数目，则数列 <spanclass="math inline">\(h(n,0),h(n,1),...,h(n,n(n-1)/2)\)</span>的生成函数为 <spanclass="math inline">\(g(x)=1(1+x)...(1+x+...+x^{n-1})\)</span></p><p>证明：展开 <span class="math inline">\(g(x)\)</span> 后，每一项形如<span class="math inline">\(x^{a_1}x^{a_2}...x^{a_n}\)</span> ，且 <spanclass="math inline">\(0\leqslant a_i\leqslant i-1\)</span>，与排列中每个元素的逆序数一一对应，且和为逆序数。</p><h3 id="指数生成函数">指数生成函数</h3><p><span class="math inline">\(g^{(e)}(x)=h_0+h_1x+h_2\dfrac{x^2}{2!}+...+h_n\dfrac{x^n}{n!}+...\)</span></p><h4 id="与多重集排列的关系">与多重集排列的关系</h4><p>设n是正整数， <spanclass="math inline">\(P(n,k)=\dfrac{n!}{(n-k)!}\)</span>表示n元素集合的k排列的数目，则数列 <spanclass="math inline">\(P(n,0),P(n,1),...,P(n,n)\)</span> 的指数生成函数为<span class="math display">\[\begin{aligned}g^{(e)}(x)&amp;=P(n,0)+P(n,1)x+P(n,2)\dfrac{x^2}{2!}...+P(n,n)\dfrac{x^n}{n!}\\&amp;=1+nx+\dfrac{n!}{2!(n-2)!}x^2+...+\dfrac{n!}{k!(n-k)!}x^k+...+\dfrac{n!}{n!0!}x^n\\&amp;=(1+x)^n\end{aligned}\]</span> 数列 <span class="math inline">\(1,1,1,...,1,...\)</span>的指数生成函数为 <spanclass="math inline">\(g^{(e)}(x)=\sum\limits_{n=0}^\infty\dfrac{x^n}{n!}=e^x\)</span>​</p><p>设多重集 <span class="math inline">\(S=\{n_1\cdot a_1,n_2\cdota_2,...,n_k\cdot a_k\}\)</span> ，设 <spanclass="math inline">\(h_n\)</span> 是S的n排列数，则数列 <spanclass="math inline">\(h_1,h_2,...,h_k,...\)</span> 的指数生成函数为<spanclass="math inline">\(g^{(e)}(x)=f_{n_1}(x)f_{n_2}(x)...f_{n_k}(x)\)</span>，其中 <spanclass="math inline">\(f_{n_i}(x)=1+x+\dfrac{x^2}{2!}+...+\dfrac{x^{n_i}}{n_i!}\)</span></p><p>对 <span class="math inline">\(a_i\)</span> 的约束将反映到 <spanclass="math inline">\(f_{n_i}(x)\)</span> 上</p><figure><img src="/img/离散3/指数生成函数.png" alt="指数生成函数" /><figcaption aria-hidden="true">指数生成函数</figcaption></figure><h3 id="递推关系">递推关系</h3><p>设数列为 <span class="math inline">\(h_0,h_1,h_2,...h_n,..\)</span>，若存在量 <span class="math inline">\(a_1,a_2,..,a_k(a_k\ne0)\)</span>和量 <span class="math inline">\(b_n\)</span>（每个量是常数或依赖于n的数）使得 <spanclass="math inline">\(h_n=a_1h_{n-1}+a_2h_{n-2}+...+a_{k-1}h_{n-k+1}+a_kh_{n-k}+b_n\)</span>，则称该数列满足<strong>k阶线性递推关系</strong>。若 <spanclass="math inline">\(b_n=0\)</span>，则称该数列是<strong>k阶线性齐次递推关系</strong>。若 <spanclass="math inline">\(a_i\)</span>均为常数，则称该数列是<strong>k阶常系数线性递推关系</strong></p><h4 id="常系数线性齐次递推关系">常系数线性齐次递推关系</h4><p>对于 <spanclass="math inline">\(h_n=a_1h_{n-1}+a_2h_{n-2}+...+a_kh_{n-k}(a_k\ne0,n\geqslantk)\)</span></p><p>特征方程法：</p><ul><li>解方程 <spanclass="math inline">\(x^k-a_1x^{k-1}-...-a_{k-1}x-a_k=0\)</span>，得到方程的根</li><li>若根 <span class="math inline">\(q_i\)</span>不重复（不是重根），则对应于 <span class="math inline">\(q_i\)</span>的部分为 <span class="math inline">\(H_n^{(i)}=c_iq_i^n\)</span></li><li>若根 <span class="math inline">\(q_i\)</span> 是 <spanclass="math inline">\(s_i\)</span> 重根，则对应于 <spanclass="math inline">\(q_i\)</span> 的部分为 <spanclass="math inline">\(H_n^{(i)}=(c_1+c_2n+...+c_{s_i}n^{s_i-1})q_i^n\)</span></li><li>递推关系的通解即为 <spanclass="math inline">\(h_n=H_n^{(1)}+H_n^{(2)}+...+H_n^{(t)}\)</span>​</li><li>最终带入k个初始值求解常数 <span class="math inline">\(c_i\)</span>即可</li></ul><p>生成函数法：</p><figure><img src="/img/离散3/求解递推关系.png" alt="求解递推关系" /><figcaption aria-hidden="true">求解递推关系</figcaption></figure><h4 id="常系数线性非齐次递推关系">常系数线性非齐次递推关系</h4><p><spanclass="math inline">\(h_n=a_1h_{n-1}+a_2h_{n-2}+...+a_kh_{n-k}+b_n(a_k\ne0,b_n\geqslant0,n\geqslantk)\)</span></p><p>求解步骤：</p><ol type="1"><li>求齐次的通解</li><li>求非齐次的特解</li><li>组合通解和特解，并利用初始项求常系数c</li></ol><blockquote><p>类似常系数线性非齐次微分方程的求法</p></blockquote><p>尝试特解时，可根据 <span class="math inline">\(b_n\)</span>特征来试探</p><ul><li>若 <span class="math inline">\(b_n\)</span> 是n的k次多项式，则尝试<span class="math inline">\(h_n\)</span> 也是n的k次多项式</li><li>若 <span class="math inline">\(b_n\)</span> 是指数形式，则尝试 <spanclass="math inline">\(h_n\)</span> 也是指数形式</li></ul><p>注意：若通解的指数和特解的指数相同，则特解应设为 <spanclass="math inline">\(d^n*(多项式)\)</span>，多项式最高次项的次数为重数。（类比微分方程的特解求法）</p><h2 id="特殊计数序列">特殊计数序列</h2><h3 id="catalan数">Catalan数</h3><p>Catalan数列为 <spanclass="math inline">\(C_0,C_1,...,C_n,...\)</span> ，其中 <spanclass="math inline">\(C_n=\dfrac{1}{n+1}\dbinom{2n}{n},n=0,1,2,...\)</span>是第n个Catalan数。其几何意义是凸n+1边形被在其内部不相交的对角线划分成三角形区域的方法数<span class="math inline">\(h_n=C_{n-1}\)</span> 。</p><p>满足递推式 <spanclass="math inline">\(C_n=C_0C_{n-1}+C_1C_{n-2}+...+C_{n-1}C_0\)</span></p><p>具体应用：</p><ul><li>括号化问题。对于n个矩阵连乘，有多少种方法加括号。<spanclass="math inline">\(h_n=C_{n-1}\)</span></li><li>出栈次序问题。一个栈的进栈序列为 <spanclass="math inline">\(1,2,...,n\)</span> ，则有 <spanclass="math inline">\(C_n\)</span> 种出栈序列</li><li>二叉树问题。共n个节点，则 <span class="math inline">\(C_n\)</span>种</li></ul><p>考虑n个+1和n个-1构成的2n项序列 <spanclass="math inline">\(a_1,a_2,...,a_{2n}\)</span> ，其部分和总满足 <spanclass="math inline">\(a_1+a_2+...+a_k\geqslant0(k=12,...,2n)\)</span>​的序列的个数等于第n个Catalan数</p><p>设 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span> 是正整数且 <spanclass="math inline">\(p\geqslant q\)</span> ，则从 <spanclass="math inline">\((0,0)\)</span> 到 <spanclass="math inline">\((p,q)\)</span> 且不穿过 <spanclass="math inline">\(y=x\)</span> 的方法数为 <spanclass="math inline">\(\dfrac{p-q+1}{p+1}\dbinom{p+q}{q}\)</span></p><h3 id="差分序列和stirling数">差分序列和Stirling数</h3><h4 id="差分">差分</h4><p>0阶差分序列：<spanclass="math inline">\(h_0,h_1,h_2,...,h_n,...\)</span></p><p>1阶差分序列：<spanclass="math inline">\(\Delta^1h_n=h_{n+1}-h_n\)</span></p><p>k阶差分序列：<spanclass="math inline">\(\Delta^kh_n=\Delta(\Delta^{k-1}h_n)=\Delta^{k-1}h_{n+1}-\Delta^{k-1}h_n\)</span>​</p><blockquote><p>类似微分、求导，其实就是整数化了（</p></blockquote><p>差分表</p><p>其中，第0行元素为 <spanclass="math inline">\(1,6,15,28,...\)</span></p><p>第0条对角线为 <span class="math inline">\(1,5,4,0,0,...\)</span></p><figure><img src="/img/离散3/差分表.png" alt="差分表" /><figcaption aria-hidden="true">差分表</figcaption></figure><p>若差分表的第0条对角线为 <spanclass="math inline">\(c_0,c_1,...,c_p,0,0,...(c_p\ne0)\)</span>，则数列的通项满足</p><p><spanclass="math inline">\(h_n=c_0\dbinom{n}{0}+c_1\dbinom{n}{1}+...+c_p\dbinom{n}{p}\)</span></p><p><spanclass="math inline">\(\sum\limits_{k=0}^nh_k=c_0\dbinom{n+1}{1}+c_1\dbinom{n+1}{2}+...+c_p\dbinom{n+1}{p+1}\)</span></p><p>设数列 <span class="math inline">\(h_n=n^p\)</span>的第0条对角线的第k个元素为 <span class="math inline">\(c(p,k)\)</span>，则有 <span class="math inline">\(c(p,0)=\begin{cases}1,p=0\\0,p\geqslant1\end{cases}\)</span> ，以及 <spanclass="math inline">\(c(p,p)=p!\)</span> ，上式也可化为</p><p><spanclass="math inline">\(h_n=n^p=c(p,0)\dbinom{n}{0}+c(p,1)\dbinom{n}{1}+...+c(p,p)\dbinom{n}{p}\)</span></p><h4 id="第二类stirling数">第二类stirling数</h4><p>设 <span class="math inline">\([n]_k=P(n,k)\)</span>是从n个元素中取k个元素的排列数，由于 <spanclass="math inline">\(\dbinom{n}{k}=\dfrac{n(n-1)...(b-k+1)}{k!}=\dfrac{[n]_k}{k!}\)</span>，从而 <spanclass="math inline">\(h_n=\sum\limits_{k=0}^p\dfrac{c(p,k)}{k!}[n]_k\)</span></p><p>令 <span class="math inline">\(S(p,k)=\dfrac{c(p,k)}{k!}(0\leqslantk\leqslant p)\)</span>称为第二类Stirling数，组合意义是把p个元素划分到k个<strong>不可区分的盒子</strong>且<strong>没有空盒</strong>的划分的个数</p><p><span class="math inline">\(S(p,0)=c(p,0),S(p,p)=1\)</span>，且满足递推公式 <spanclass="math inline">\(S(p,k)=kS(p-1,k)+S(p-1,k-1),(1\leqslant k\leqslantp-1)\)</span></p><blockquote><p>类比组合数的公式</p></blockquote><p>当<strong>盒子有区别</strong>时，<spanclass="math inline">\(S^\#(p,k)=k!S(p,k)\)</span></p><p>对每一个满足 <span class="math inline">\(0\leqslant k\leqslantp\)</span> 的整数k，有 <spanclass="math inline">\(S^\#(p,k)=\sum\limits_{t=0}^k(-1)^t\dbinom{k}{t}(k-t)^p\)</span>，从而 <spanclass="math inline">\(S(p,k)=\dfrac{S^\#(p,k)}{k!}\)</span></p><blockquote><p>用容斥原理证明</p></blockquote><p><strong>Bell数</strong>为将p个元素划分到<strong>不可区分的盒子</strong>且<strong>没有空盒</strong>的划分个数（对盒子数量无要求，相当于分成几堆），<spanclass="math inline">\(B_p=S(p,0)+S(p,1)+...+S(p,p)\)</span></p><p>Bell数满足递推式 <spanclass="math inline">\(B_p=\dbinom{p-1}{0}B_0+\dbinom{p-1}{1}B_1+...+\dbinom{p-1}{p-1}B_{p-1}\)</span></p><p><strong>第一类Stirling数</strong>:将p个物品排成k个非空的循环排列的方法，记为 <spanclass="math inline">\(s(p,k)\)</span></p><p><spanclass="math inline">\([n]_p=n(n-1)...(n-(p-1))=a_n^pn^p-a_n^{p-1}n^{p-1}+...+(-1)^{p-1}a_n^1n^1+(-1)^pa_n^0n^0\)</span></p><p>其中 <span class="math inline">\(a_n^k=s(p,k)\)</span> ，且有 <spanclass="math inline">\(s(p,0)=0(p\geqslant1),s(p,p)=1(p\geqslant0)\)</span></p><p>满足递推式 <spanclass="math inline">\(s(p,k)=(p-1)s(p-1,k)+s(p-1,k-1)\)</span>​</p><h4 id="总结">总结</h4><table><thead><tr class="header"><th style="text-align: center;">p个球，k个盒</th><th style="text-align: center;">是否为空</th><th style="text-align: center;">方案数</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">盒有区别</td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(k^p\)</span></td></tr><tr class="even"><td style="text-align: center;">盒无区别</td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(\sum\limits_{i=1}^{\min(p,k)}S(p,i)\)</span></td></tr><tr class="odd"><td style="text-align: center;">盒有区别</td><td style="text-align: center;">无空盒</td><td style="text-align: center;"><spanclass="math inline">\(k!S(p,k)\)</span></td></tr><tr class="even"><td style="text-align: center;">盒无区别</td><td style="text-align: center;">无空盒</td><td style="text-align: center;"><spanclass="math inline">\(S(p,k)\)</span></td></tr><tr class="odd"><td style="text-align: center;">k个循环排列</td><td style="text-align: center;">非空</td><td style="text-align: center;"><spanclass="math inline">\(s(p,k)\)</span></td></tr></tbody></table><p><spanclass="math inline">\(S(p,k)=\dfrac{1}{k!}\sum\limits_{t=0}^k(-1)^t\dbinom{k}{t}(k-t)^p\)</span>​​</p><p><span class="math inline">\(S(p,k)=kS(p-1,k)+S(p-1,k-1),(1\leqslantk\leqslant p-1)\)</span></p><p><spanclass="math inline">\(s(p,k)=(p-1)s(p-1,k)+s(p-1,k-1)\)</span></p><h3 id="分拆数">分拆数</h3><p>设一个正整数n，若存在正整数集 <spanclass="math inline">\(\{n_1,n_2,...,n_k\}(1\leqslant k\leqslantn,1\leqslant n_i\leqslant n)\)</span> ，使得 <spanclass="math inline">\(n_1+n_2+...+n_k=n\)</span>，则称这个正整数集是n的一个分拆，称每个 <spanclass="math inline">\(n_i\)</span>为n的一个部分。记n的所有包含k个部分的不同分拆的个数为 <spanclass="math inline">\(p_n^k\)</span> ，n的所有不同分拆的个数为 <spanclass="math inline">\(p_n\)</span> ，成为n的分拆数</p><p>设 <span class="math inline">\(a_1,a_2,...,a_n\)</span>是n个非负整数，且 <spanclass="math inline">\(n=na_n,(n-1)a_{n-1}+...+2a_2+a_1\)</span>，则上式对应n的一个分拆记作 <spanclass="math inline">\(\lambda=n^{a_n}...2^{a_2}1^{a_1}\)</span>。n的分拆数的个数也等价于上面方程的非负整数解的个数</p><p>分拆数满足递推关系 <spanclass="math inline">\(\sum\limits_{j=1}^kp_n^j=p_{n+k}^k\)</span></p><ul><li><p>设 <span class="math inline">\(p_n(r)\)</span>是最大部分为r的n的分拆的个数，<spanclass="math inline">\(q_n(r)\)</span>是满足分拆各部分不大于r的n-r的分拆数量，则 <spanclass="math inline">\(p_n(r)=q_n(r)\)</span>​</p></li><li><p>分拆数定理：正整数n分成k个部分的分拆个数，等于n分成以k为最大部分的分拆个数</p></li></ul><p>分拆图</p><p><img src="/img/离散3/分拆图.png" alt="分拆图" style="zoom:50%;" /></p><p>看成矩阵，其转置被称为共轭分拆，记为 <spanclass="math inline">\(\lambda^*\)</span>。分拆与共轭分拆完全相同则称为自共轭分拆</p><ul><li><p>n的自共轭分拆个数等于n分拆成互不相同的若干奇数的和的分拆个数</p></li><li><p>把n分成奇数部分的分拆个数等于把n分成不同部分的分拆个数</p></li></ul><p>分拆数数列 <span class="math inline">\(p_0,p_1,...,p_n,...\)</span>的生成函数为 <span class="math inline">\(g(x)=\sum\limits_{n=0}^\inftyp_nx^n=\prod\limits_{k=1}^\infty(1-x^k)^{-1}\)</span> ，证明如下：</p><figure><img src="/img/离散3/分拆数证明1.png" alt="分拆数证明1" /><figcaption aria-hidden="true">分拆数证明1</figcaption></figure><figure><img src="/img/离散3/分拆数证明2.png" alt="分拆数证明2" /><figcaption aria-hidden="true">分拆数证明2</figcaption></figure><figure><img src="/img/离散3/分拆数证明3.png" alt="分拆数证明3" /><figcaption aria-hidden="true">分拆数证明3</figcaption></figure><h2 id="着色计数">着色计数</h2><h3 id="置换群与对称群">置换群与对称群</h3><p>给定集合G和G上的二元运算 <span class="math inline">\(\cdot\)</span>，若以下四个条件满足，则称代数结构 <spanclass="math inline">\((G,\cdot)\)</span> 为<strong>群</strong>：</p><ul><li>封闭性：运算在G上封闭，即对于任意 <span class="math inline">\(a,b\inG\)</span> ，都有 <span class="math inline">\(a\cdot b\inG\)</span></li><li>结合律：<span class="math inline">\(a\cdot(b\cdot c)=(a\cdot b)\cdotc\)</span></li><li>存在单位元：存在 <span class="math inline">\(e\in G\)</span>，对于任意 <span class="math inline">\(a\in G\)</span> ，满足 <spanclass="math inline">\(e\cdot a=a\cdot e=a\)</span> ，<spanclass="math inline">\(e\)</span> 称为G的单位元</li><li>存在逆元：对任意 <span class="math inline">\(a\in G\)</span> ，存在<span class="math inline">\(a^{-1}\in G\)</span> ，满足 <spanclass="math inline">\(a\cdot a^{-1}=a^{-1}\cdot a=e\)</span></li></ul><blockquote><p>例如 <span class="math inline">\(G=\{-1,1\}\)</span>在乘法运算下是一个群，整数集Z在加法运算下是一个群</p></blockquote><p><strong>有限群</strong>：G有限。此时 <spanclass="math inline">\(|G|\)</span> 称为群的阶</p><p><strong>循环群</strong>：若存在 <span class="math inline">\(a\inG\)</span>，G中任意元素b均可以表示成a的幂，则该群为循环群，a为生成元</p><p><strong>置换</strong>：设X是一个有限集，X的每个置换可视为X到自身的双射，即<span class="math inline">\(X=\{1,2,...,n\}\)</span> 的置换可表示为<spanclass="math inline">\(\begin{pmatrix}1&amp;2&amp;...&amp;n\\i_1&amp;i_2&amp;...&amp;i_n\end{pmatrix}\)</span>，个数为 <span class="math inline">\(n!\)</span>。记X的所有置换所组成的集合为 <spanclass="math inline">\(S_n\)</span>​</p><p>置换的合成：设f和g为 <spanclass="math inline">\(\{1,2,...,n\}\)</span> 上的两个置换 <spanclass="math display">\[f=\begin{pmatrix}1&amp;2&amp;...&amp;n\\i_1&amp;i_2&amp;...&amp;i_n\end{pmatrix}\,g=\begin{pmatrix}1&amp;2&amp;...&amp;n\\j_1&amp;j_2&amp;...&amp;j_n\end{pmatrix}\]</span> 则f与g按照先f后g的顺序放置得到一个新运算 <spanclass="math display">\[g\circf=\begin{pmatrix}1&amp;2&amp;...&amp;n\\j_1&amp;j_2&amp;...&amp;j_n\end{pmatrix}\circ\begin{pmatrix}1&amp;2&amp;...&amp;n\\i_1&amp;i_2&amp;...&amp;i_n\end{pmatrix}\]</span> 其中 <span class="math inline">\((g\circf)(k)=g(f(k))=j_{i_k}\)</span></p><p>置换的合成实质上定义了 <span class="math inline">\(S_n\)</span>上的一个二元运算，满足结合律但<strong>不满足交换律</strong>。恒等置换、逆置换类似恒等函数、逆函数</p><p><strong>置换群</strong>：若 <span class="math inline">\(S_n\)</span>的非空子集G满足群的要求，则称G是X的一个置换的群，简称置换群。</p><p>置换群满足消去律，<spanclass="math inline">\(X=\{1,2,...,n\}\)</span> 的所有置换的集合 <spanclass="math inline">\(S_n\)</span>以及置换的合成是一个置换群，称为<strong>n阶对称群</strong></p><p><img src="/img/离散3/顶点对称.png" alt="顶点对称" style="zoom:67%;" /></p><p><img src="/img/离散3/对称推广.png" alt="对称推广" style="zoom:67%;" /></p><h3 id="着色">着色</h3><p>设集合 <span class="math inline">\(X=\{1,2,...,n\}\)</span>，以及X的置换群 <span class="math inline">\(G\)</span>，则X的一种着色方案c是对X的每一个元素指定一种颜色的方案，令 <spanclass="math inline">\(c\)</span> 表示X的一种<strong>着色</strong>，<spanclass="math inline">\(c(i)\)</span> 表示 <spanclass="math inline">\(i\)</span> 的颜色</p><p>令C表示X中所有着色的集合，令 <spanclass="math inline">\(f=\begin{pmatrix}1&amp;2&amp;...&amp;k&amp;...&amp;n\\i_1&amp;i_2&amp;...&amp;i_k&amp;...&amp;i_n\end{pmatrix}\)</span>是G中的一个置换，定义 <span class="math inline">\(f*c\)</span> 是使<span class="math inline">\(i_k\)</span> 具有颜色 <spanclass="math inline">\(c(k)\)</span> 的着色，即 <spanclass="math inline">\((f*c)(i_k)=c(k)\)</span></p><blockquote><p>f将k变到 <span class="math inline">\(i_k\)</span> ，k的颜色 <spanclass="math inline">\(c(k)\)</span> 移到 <spanclass="math inline">\(f(k)=i_k\)</span> 并成为 <spanclass="math inline">\(i_k\)</span> 的颜色。</p><p>点不动，颜色动</p></blockquote><p>着色集C需要满足：对G中的任意置换f和C中的任意着色c，<spanclass="math inline">\(f*c\)</span> 任然属于C</p><p><span class="math inline">\((g\circ f)*c=g*(f*c)\)</span></p><p>着色等价关系：X，G，C，<span class="math inline">\(f*c\in C\)</span>。设 <span class="math inline">\(c_1\)</span> 与 <spanclass="math inline">\(c_2\)</span>是C中的任意两种着色，若存在G中的一个置换 <spanclass="math inline">\(f\)</span> ，使得 <spanclass="math inline">\(f*c_1=c_2\)</span>，则称两种着色<strong>等价</strong>，记为 <spanclass="math inline">\(c_1\sim c_2\)</span></p><h3 id="burnside定理">Burnside定理</h3><p>计算X的非等价着色数的公式</p><p><strong>稳定核</strong>：使着色c保持不变的G中所有置换的集合 <spanclass="math inline">\(G(c)=\{f|f\in G,f*c=c\},c\in C\)</span></p><p>推论：</p><ul><li>任何着色c的稳定核也能形成一个置换群</li><li>对G中任意置换f与g，<span class="math inline">\(g*c=f*c\)</span>当且仅当 <span class="math inline">\(f^{-1}\circ g\in G(c)\)</span></li></ul><p>引理：与c等价的着色数 <span class="math inline">\(|\{f*c|f\inG\}|\)</span> 等于G的置换个数除以c的稳定核中的置换个数，即 <spanclass="math inline">\(|\{f*c|f\in G\}|=\dfrac{|G|}{|G(c)|}\)</span></p><p>Burnside定理：设G是X的置换群，C是X中满足“对G中的任意置换f和C中的任意着色c，<spanclass="math inline">\(f*c\)</span>任然属于C”的着色集合，则C中非等价的着色数 <spanclass="math inline">\(N(G,C)=\dfrac{1}{|G|}\sum_{f\in G}|C(f)|\)</span>。其中 <span class="math inline">\(C(f)=\{c|c\in C,f*c=c\}\)</span></p><blockquote><p>即在G中的置换作用下保持不变的着色的平均数</p></blockquote><p>计算步骤：</p><ol type="1"><li>确定置换群G</li><li>确定着色集C</li><li>计数G中每个置换f的不变着色集 <spanclass="math inline">\(C(f)\)</span> 的大小</li><li>使用Burnside公式</li></ol><h3 id="polya计数">Polya计数</h3><p>循环置换：如果在一个置换中，某些元素以循环的方式置换且余下元素保持不变，则称这样的置换为循环置换，简称循环</p><p><img src="/img/离散3/循环置换.png" alt="循环置换" style="zoom:67%;" /></p><p>循环因子分解：设f是集合X的任意置换，<spanclass="math inline">\(D_f=(X,A_f)\)</span> 是顶点集为X且边集为 <spanclass="math inline">\(A_f=\{(i,f(i)|i\in X\}\)</span> 的有向图， <spanclass="math display">\[[i_1\ i_2\ ...\ i_p],[j_1\ j_2\ ...\ j_q],...,[l_1\ l_2\ ...\ l_r]\]</span> 为 <span class="math inline">\(D_f\)</span>所对应的有向圈，则f可以分解为： <span class="math display">\[f=[i_1\ i_2\ ...\ i_p]\circ[j_1\ j_2\ ...\ j_q]\circ...\circ[l_1\ l_2\...\ l_r]\]</span> 称为f的循环因子分解</p><p>记置换f的循环分解中的循环个数为 <spanclass="math inline">\(\#(f)\)</span>，则用k中颜色对X进行着色，f保持C中着色不变的着色数为 <spanclass="math inline">\(|C(f)|=k^{\#(f)}\)</span></p><p><img src="/img/离散3/循环因子分解.png" alt="循环因子分解.png" style="zoom:67%;" /></p><h3 id="限制条件下的着色">限制条件下的着色</h3><p>设f的循环因子分解中有 <span class="math inline">\(e_i\)</span>个i循环，则 <span class="math inline">\(1e_1+2e_2+...+ne_n=n\)</span>，记 <span class="math inline">\(type(f)=(e_1,e_2,...,e_n)\)</span>为置换f的类型。循环数为 <spanclass="math inline">\(\#(f)=e_1+e_2+...+e_n\)</span></p><p>定义置换f的单项式为 <spanclass="math inline">\(mon(f)=z_1^{e_1}z_2^{e_2}...z_n^{e_n}\)</span>，G中的置换按照类型的<strong>生成函数</strong>是G中所有置换的单项式的和，即<span class="math inline">\(\sum_{f\in G}mon(f)\)</span>。G的循环指数定义为生成函数除以置换个数，即 <spanclass="math inline">\(P_G(z_1,z_2,...,z_n)=\dfrac{1}{|G|}\sum_{f\inG}z_1^{e_1}z_2^{e_2}...z_n^{e_n}\)</span></p><p>设集合 <span class="math inline">\(X=\{1,2,...,n\}\)</span>，用k种颜色对X进行着色，C是X的所有 <spanclass="math inline">\(k^n\)</span>种着色的集合，G是X的置换群，则非等价的着色数是用 <spanclass="math inline">\(z_i=k\)</span> 带入G的循环指数得到的数，即 <spanclass="math inline">\(N(G,C)=P_G(k,k,...,k)\)</span></p><p>有限制时的情况如下所示：</p><p><img src="/img/离散3/有限制的非等价着色数.png" alt="有限制的非等价着色数" style="zoom: 67%;" /></p><p>应用：图的同构</p><h2 id="考前公式">考前公式</h2><p><span class="math inline">\(P(n,k)=P(n-1,k)+kP(n-1,k-1)\)</span></p><p><spanclass="math inline">\(\dbinom{n}{k}=\dbinom{n-1}{k}+\dbinom{n-1}{k-1}\)</span>​</p><p>令 <span class="math inline">\(\alpha\)</span>是一个实数，对于所有满足 <spanclass="math inline">\(0\leqslant|x|&lt;|y|\)</span> 的变量x,y，有 <spanclass="math inline">\((x+y)^{\alpha}=\sum\limits_{k=0}^{\infty}\dbinom{\alpha}{k}x^ky^{\alpha-k}\)</span>，其中 <spanclass="math inline">\(\dbinom{\alpha}{k}=\dfrac{\alpha(\alpha-1)...(\alpha-k+1)}{k!}\)</span></p><p>多重集组合 <spanclass="math inline">\(g(x)=\sum\limits_{n=0}^\infty\dbinom{n+k-1}{n}x^n=\dfrac{1}{(1-x)^k}(|x|&lt;1)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>航概碎片</title>
    <link href="/2024/07/01/%E8%88%AA%E6%A6%82%E7%A2%8E%E7%89%87/"/>
    <url>/2024/07/01/%E8%88%AA%E6%A6%82%E7%A2%8E%E7%89%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><p>1903莱特兄弟，“飞行者”1号</p><p>X-1研究机首次突破音障</p><p>米格-21、F-104为第二代战斗机</p><p>米格-25最高，SR-71最快</p><p>英国“鹞”式战斗机垂直起降</p><p>F-117、F-22、B-2隐身</p><p>空中加油机：插头锥管式（同时2-3架，速度慢）、伸缩管式（仅一架，速度快）</p><p>1981，哥伦比亚号航天飞机试飞成功</p><p>1986，挑战者号挑战失败</p><p>2003，哥伦比亚号爆炸</p><h3 id="中国歼击机">中国歼击机</h3><p>歼5：首个喷气式战斗机，高亚声速</p><p>歼6：第一代超声速战斗机</p><p>歼7、歼8：第二代超声速战斗机（歼8自行设计制造）</p><p>歼10：第三代战斗机</p><p>歼11：引进苏-27，第三代重型</p><p>歼15：重型舰载型战斗机</p><p>歼20：隐身战斗机，单座、双发、鸭式气动布局，全动垂尾</p><p>歼31：隐身，单座、双发、常规气动布局，固定双斜垂尾</p><p>飞豹——歼轰7</p><p>枭龙——超7</p><h3 id="中国长征系列火箭">中国长征系列火箭</h3><p>长征一号：近地轨道小型有效载荷</p><p>长征二号：主要承担近地轨道和太阳同步轨道的发射任务？，长二F是中国唯一一型用于载人航天发射的运载火箭，液体火箭发动机</p><p>长征三号：地球静止轨道、同步卫星/高轨道？</p><p>长征四号：太阳同步轨道卫星</p><p>长征五号：大、远</p><p>长征六号：新一代小型运载火箭，无毒无污染</p><p>长征七号：新一代高可靠、高安全的中型液体运载火箭，主要用于发射天舟货运飞船。也发射新一代载人飞船。</p><p>长征八号：新型中型运载火箭，主要面向未来中高轨商业发射市场。</p><p>长征十一号：小型固体，准备时间短</p><h3 id="大气层">大气层</h3><p>对流层：0-7/11/18km，温度随高度升高而下降</p><p>平流层：？-50km，温度随高度升高先不变，再上升（臭氧吸收紫外线）</p><p>中间层（高空对流层）：50-85km，温度随高度升高而下降</p><p>热层：85-800km，空气高度电离，温度随高度升高而上升</p><p>散逸层：800-2000/3000km</p><h3 id="空气动力阻力">空气动力、阻力</h3><p>拉瓦尔喷管</p><p>先收缩再扩张，最窄出Ma=1，速度不断增大</p><p>升力的公式：<span class="math inline">\(Y=\dfrac{1}{2}C_l\rhov^2S\)</span></p><p>摩擦阻力：气体与飞机表面摩擦产生，附着层内气体流速逐渐降为0（与表面、面积有关）</p><p>压差阻力：飞机前后区域压强差产生阻力（减小最大迎风面积、整流做成流线型）</p><p>诱导阻力：由升力产生，来自翼面（与机翼形状有关，可增大展弦比、翼梢小翼等）</p><p>干扰阻力：气流的相互干扰（飞机不同部件之间的相对位置）</p><p>激波阻力：激波是收到强烈压缩的一层薄空气，可分为正激波（Ma=1或稍大于1）和斜激波（Ma超过1很多）。由激波阻滞气流引起阻力。（头部尖锐更好）</p><p>局部激波：采用超临界翼型</p><h3 id="翼型">翼型</h3><h4 id="后掠翼">后掠翼</h4><p>跨声速时提高 <span class="math inline">\(Ma_{临界}\)</span>，超过后也能进一步减小波阻</p><h4 id="三角形机翼">三角形机翼</h4><p>减阻，纵向飞行稳定性好。</p><p>升阻比低，巡航性能不好，着陆性能较差</p><h4 id="小展弦比机翼">小展弦比机翼</h4><p>减小激波阻力</p><p>襟翼小，起落性能差，诱导阻力大。</p><h4 id="变后掠翼">变后掠翼</h4><h4 id="边条机翼">边条机翼</h4><p>边条（前翼）为大后掠角的细长翼，基本翼（后翼）为中等后掠角、中等展弦比的三角形机翼</p><h4 id="鸭式布局">”鸭“式布局</h4><p>尾翼位于机翼之前</p><h4 id="无尾式布局">无尾式布局</h4><h3 id="飞机操纵">飞机操纵</h3><h3 id="直升机操纵">直升机操纵</h3><h3 id="发动机">发动机</h3><p>活塞式发动机</p><p>涡轮喷气发动机</p><p>涡轮风扇发动机（涵道比=外涵道/内涵道，小则涡喷，大则螺浆、桨扇）</p><p>涡轮浆扇发动机</p><p>涡轮轴发动机（直升机）</p><h3 id="gps和其他">GPS和其他</h3><p>24颗卫星，20000km，12h，4颗定位，6个轨道平面，1994年完成</p><p>俄罗斯Glonass：3个轨道平面，每个平面7颗星</p><h3 id="飞机迭代">飞机迭代</h3><h4 id="一代机">一代机</h4><p>美国F-100，苏联米格-19</p><h4 id="二代机">二代机</h4><p>美国F-4、F-5，苏联米格-21</p><h4 id="三代机">三代机</h4><p>美国F-15、F-16，俄罗斯米格-29、苏27、苏30，欧洲EF2000、法国阵风、幻影2000</p><h4 id="四代机">四代机</h4><p>美国F-22、F-35，中国歼-20、歼-31，俄罗斯苏-57</p><h3 id="各类构造图">各类构造图</h3><p>见课本，包括浮空器、飞机、机翼、直升机等等</p><p>国际空间站由<strong>16</strong>个国家研制，第一个模块由<strong>俄罗斯</strong>发射，总重超过<strong>400吨</strong>，<strong>1998</strong>开建</p><p>美国<strong>贝尔/波音</strong>V22“鱼鹰”属于<strong>倾转旋翼机</strong></p><p>中国自行研制的跨越世界屋顶的飞机是<strong>运10</strong></p><p>二战中著名飞机：日本“零”式、美国P51、P61</p><p>挑战者号1986爆炸，哥伦比亚2003</p><p>神舟5号发射于<strong>2003年</strong>10月5日</p><p>我国直升机工业主要产品有<strong>直985</strong></p><p>20世纪40年代初，<strong>大型液体火箭</strong>的成功发射奠定了现代航天技术的基础</p><p>运20最大起飞重量为<strong>220吨</strong></p><p>神舟5号<strong>杨利伟</strong></p><p>神舟6号<strong>费俊龙、聂海胜</strong></p><p>神舟7号<strong>景海鹏、刘伯明、翟志刚</strong> ，翟志刚太空行走</p><p><strong>1957</strong>苏联发射第一颗人造地球卫星</p><p><strong>1961</strong>加加林</p><p><strong>1969</strong>美国登月</p><p><strong>1970</strong>东方红一号</p><p><strong>1971</strong>年，苏联发射第一个空间站“礼炮号”</p><p><strong>1981</strong>年美国首飞航天飞机</p><p>2011美国航天飞机全部退役</p><p>中国首颗数据中继卫星“天链一号”于<strong>2008</strong>年发射成功</p><p>具有前掠翼的飞机是<strong>X-29</strong> （选质数）</p><p>旅行者1号经历了<strong>36</strong>年飞出太阳系（有不见者，三十六年）</p><p>具有超声速巡航能力的战斗机<strong>不能提高低空飞行性能</strong></p><p>高动态临近空间飞行器的飞行速度<strong>Ma&gt;1</strong></p><p>发展中的隐身技术选全部</p><p>嫦娥一号由<strong>长征三号甲</strong>发射（三甲医院），2007年10月24日（奥运前一年）</p><p>天宫一号对接<strong>神舟8号</strong> （18岁）</p><p><strong>2007年2月26日</strong>，大飞机立项（最接近2.29）</p><p>中国BZK-005中高空远程无人侦察机的特点是<strong>双尾撑布局、具有隐身能力</strong></p><p>C919在<strong>2017年5月5日</strong>首飞</p><p>2008年，首架自主知识产权的涡扇支线客机<strong>ARJ21-700</strong>在上海成功首飞</p><p>隐身：<strong>F-22、B-2、F-117</strong></p><p>过失速机动的作用：有利于空中近距格斗、提高对目标的击毁概率（厉不厉害你击格）</p><p>嫦娥2号目前<strong>飞往深空探测</strong></p><p>嫦娥工程不包含载人登月</p><p>歼15舰载机的外形特点不包含V型垂尾</p><p><strong>应用卫星不选实验，卫星用途不选商业</strong></p><p>静/动升力组合式飞艇，其静升力大约占到总升力的<strong>60%-70%</strong>（及格就行）</p><p>临近空间的区域为<strong>20km-100km</strong>（平流层+）</p><p><strong>1903年12月17日，莱特兄弟，美国</strong></p><p><strong>1783年11月21日</strong>，法国人，蒙哥尔费气球，人类首次乘坐航空器飞行（一起爬山）</p><p>F22速度不高于三倍声速</p><p>高超声速飞行器的最大平飞速度为<strong>马赫数大于5</strong></p><p>尾旋螺旋半径小</p><p>影响升力的因素为机翼面积而非机身面积！</p><p>采用襟翼的主要目的是<strong>增加升力</strong></p><p>飞机发生声障时不选气动加热</p><p>轨道交汇和对接不用于飞船和卫星，用于飞船与空间站、航天飞机与空间站、航天飞机与卫星</p><p>前掠翼只选大迎角低速过失速机动性能好、起飞着陆性能好。（只选性能好）</p><p><strong>歼击机、教练机</strong>可以做尾旋</p><p>采用变后掠翼的主要目的不是增大失速迎角</p><p>气体温度升高，<strong>粘性增大</strong></p><p>变后掠翼<strong>气动中心变化大</strong></p><p>直升机的飞行操纵包括机头转向操纵</p><p>三角机翼没有升力大（不选三个字的）</p><p>重力梯度稳定的卫星姿态控制方式，不耗费能源、结构简单、可长期运行，但控制精度较低。</p><p>关于飞机的纵向稳定性，飞机重心在焦点之前，则当飞机受到扰动而机头上仰时，产生下俯的稳定力矩（中心在前+相反）</p><p>菱形翼型，上下表面产生<strong>斜激波、膨胀波</strong></p><p>航天器的轨道类型包括<strong>圆、椭圆、抛物线、双曲线</strong>（全选）</p><p>伯努利原理是<strong>能量守恒定律</strong>在流体流动中的应用</p><p>“鸭”式布局起降好、高速好、升力好，但稳定性不好</p><p>军用飞机的速度：最大平飞速度</p><p>小展弦比<strong>激波阻力小、机动性能好，但起落性能差、诱导阻力大</strong></p><p>采用腹鳍是为了使飞机具有足够的<strong>方向静稳定性</strong></p><p>机翼上反角是为了使飞机具有足够的<strong>横向静稳定性</strong></p><p>轨道机动不包括轨道摄动（机动可以，但不要摄）</p><p>行星际空间环境主要受<strong>太阳活动、来自银河系的宇宙线、微流星体的影响</strong>，而非来自银河系的高能带电粒子</p><p>冷却液体火箭发动机推力室壁的推进剂的特殊要求是<strong>粘度小、传热性好</strong>，无需无毒、物理安定</p><p>涡轮螺桨发动机与涡轮喷气发动机相比，<strong>低亚声速好、耗油率小</strong>、但功率重量比大</p><p>涡喷中，严格限制工作时间的状态有<strong>起飞状态、慢车状态</strong>，慢车状态推力约为起飞状态的<strong>4%</strong>，巡航为起飞状态的<strong>65%-75%</strong>，最大状态为<strong>85-90%</strong></p><p>冲压发动机<strong>不能自行起飞</strong>，必须要有助推器</p><p>目前常规的化学火箭发动机的比冲最大约为<strong>5000m/s</strong></p><p>轴流式压气机工作的过程中，静子叶片的作用是<strong>改变气流方向</strong></p><p>战斗机的加力式涡轮风扇发动机的涵道比一般<strong>小于1</strong></p><p><strong>涡轮</strong>发动机有压气机</p><p>涡喷的单位推力是指每<strong>单位流量</strong>的空气进入发动机所产生的推力</p><p>涡喷的单位耗油率是指产生<strong>单位推力</strong>每小时所消耗的燃油量</p><p>涡轮螺浆发动机的飞行速度范围是<strong>500-700km</strong></p><p>超声速飞机采用<strong>拉瓦尔</strong>尾喷管（从燃烧室出来时不一定超过音速）</p><p>固体火箭不用于航天飞机的主发动机</p><p>对近地空间的环境探测、科学研究属于<strong>探空火箭</strong></p><p>冲压发动机没有专门的压气机</p><p>第四代飞机所采用的发动机推重比在<strong>10</strong>左右（4是4,10是10）</p><p>液体火箭发动机可以<strong>反复启动</strong></p><p>并联型多级火箭的缺点是<strong>飞行阻力大、分离时干扰大、级间连接较复杂</strong>，弯曲刚度不差</p><p>桨扇不带大飞机</p><p>涡扇靠风扇，排气速度不大</p><p>加力燃烧室位于<strong>涡轮后面</strong> （不一定主燃烧室后面）</p><p>火箭发动机的性能参数主要有<strong>推力、冲量、比冲</strong>，没有推进剂消耗率</p><p>现代冲压发动机没有低速发动机</p><p>液体火箭发动机的推进剂可单元组、双元组、三元组（一生二，二生三）</p><p>产生推力矢量的方式不包括摆动发动机（不能摆）</p><p>涡轮螺浆发动机与活塞式发动机相比，具有功率比重大、耗油率低、振动小的优点，但低空性能不好</p><p>离心式压气机与轴流式压气机相比，其增压比<strong>小</strong></p><p>轴流式压气机中转子叶片的作用是<strong>增压增速</strong>，相邻叶片构成的通道是<strong>扩散形</strong></p><p>涡轮喷气发动机涡轮导向器叶片的通道是<strong>收缩形</strong></p><p>垂直起落发动机也属于燃气涡轮发动机</p><p>涡轮喷气发动机的推重比指<strong>地面</strong>上最大工作状态下，发动机推力与其<strong>结构重量</strong>之比</p><p>涡扇不适合高超声速飞行</p><p>活塞用航空汽油，涡喷用航空煤油</p><p>液体火箭发动机没有推力终止装置（覆水难收）</p><p>头部空速管上的水平叶片用于测量<strong>俯仰角度</strong></p><p>卫星测控的测控作用距离一般为100000km以下（十万伏特）</p><p>天链一号是同步轨道卫星，高度<strong>36000km</strong>，由<strong>4</strong>颗卫星组成</p><p>无人机数据链路主要由<strong>机载数据终端、地面设备</strong>组成，没有地面控制站、通信指挥系统。其中地面设备主要由<strong>视频接收机、中断处理机</strong>组成，没有遥控、遥测（瑶瑶）</p><p>无人机数据中继站包括<strong>地面、空中、卫星</strong>中继站，没有海上（怕进水）</p><p>无人机地面控制站由全选组成524</p><p>“望远号”海上测量船已经有<strong>7</strong>艘</p><p>自主导航：惯性、天文</p><p>发射台上的救生方式：弹射座椅、逃逸塔，不能用降落伞（太低），不能用冗余设计</p><p>电传操纵系统<strong>传递电信号</strong>，不用动力传动装置。驾驶员操作<strong>微型操纵杆</strong></p><p>地形匹配导航选两个地形465</p><p>自动测向器属无线电测向</p><p>迎角传感器测量<strong>飞机轴线相对于气流</strong>的夹角的传感器</p><p>中国航天陆上测控站包括<strong>东风站、青岛站、国外站、机动站</strong></p><p>景象匹配导航以<strong>地表特征</strong>为匹配特征，地形为<strong>地形高度轮廓</strong></p><p>导航参数显示仪显示的内容包括<strong>机场、附近各种导航台位置及其名称</strong>（只和目的地有关）</p><p>捷联惯导系统为<strong>数字平台</strong></p><p>机载设备不包含<strong>操纵系统</strong></p><p>飞机的自动控制指自动控制<strong>气动舵面和油门杆</strong></p><p>战斗机过载可达<strong>8-9</strong></p><p>弹道导弹也适合<strong>天文导航</strong>498</p><p>飞行速度的测量方法中最为简单的方法是<strong>压力测量法</strong></p><p>航天测控控制中心不包括西昌</p><p>20世纪<strong>70年代</strong>后期，飞行器座舱中出现了电子式显示器</p><p>空中、海上遇难时的求援频率为<strong>121.5MHz</strong> （接近120）</p><p>轨迹控制要求飞行器<strong>重心保持或跟踪</strong>给定的飞行轨迹</p><p>地基系统地面站对中低轨道覆盖率为<strong>2%-3%</strong>，中继卫星为<strong>40%-50%</strong></p><p>载人航天测控系统无须大口径天线</p><p>常用的导弹制导有光纤、红外、电视、激光（全选）</p><p>后三点式起落架的尾轮重量不大568</p><p>载人登月飞船没有轨道舱</p><p>美国凤凰号对火星的探测方式是星表<strong>着陆定点探测</strong></p><p>轨道舱一般是圆柱形或球形，没有电源、气源</p><p>空中吊车式软着陆方式最大的优点是<strong>着陆冲击小</strong></p><p>着陆腿式软着陆的最大优点是<strong>落点精准</strong></p><p>玉兔号月球车不包含机械挖掘臂</p><p>机身横截面以<strong>圆形</strong>为最好</p><p>弹道导弹的控制方法有<strong>摆动发动机、摆动喷管、固定式姿态控制发动机</strong>，没有控制翼面。</p><p>直升机尾桨的类型包括<strong>常规尾桨、涵道尾桨、无尾桨系统</strong></p><p>返回舱没有推进系统</p><p>按气动外形和飞行弹道方式，导弹可分为<strong>有翼导弹、弹道导弹</strong>两大类</p><p>逃逸舱指应急舱</p><p>美国航天飞机的轨道器可以在太空飞行<strong>30</strong>天左右，最多可以乘载<strong>10</strong>人</p><p>飞行器结构不包含发动机</p><p>桁条主要用于支撑<strong>蒙皮</strong>、将<strong>蒙皮</strong>的气动力传递给翼肋（只和蒙皮有关）</p><p>巡航导弹和弹道导弹不同，一般采用<strong>空气喷气发动机</strong></p><p>母子弹头都有推进，机动式；都没有，集束；母有子无，分导式；</p><p>航天飞机没有返回舱</p><p>飞机飞行时作用在机翼上的外载荷没有气动集中载荷</p><p>弹道导弹的飞行过程：先发动机推力前进，再惯性飞行</p><p>强度是指结构抵抗破坏的能力，刚度是指抵抗变形的能力</p><p>航天器的专用系统有<strong>电视摄像系统、通信转发器</strong></p><p>“和平”号空间站的科学实验舱包括5个舱室</p><p>机身的结构形式与机翼的相同之处是都有桁条、蒙皮材料相同</p><p>第一个提出现代飞机形式构想的科学家是<strong>乔治·凯利</strong></p><p>飞机在低空作超音速飞行，则由于空气密度较大，<strong>发动机需用功率增加</strong>，波阻无关</p><p>B787、A350XWB复合材料使用率占全机50%以上</p><p>马赫数可以作为判断空气压缩程度的指标</p><p>高尔夫球表面很多小坑的主要原因是减小<strong>压差阻力</strong>、减小空气流过球体时的<strong>气流分离</strong></p><p>产生声障的根本原因是<strong>局部激波</strong></p><p>美国DAPRA研制的全新“空天战机”<strong>X-37B</strong>，通过火箭送入轨道环绕地球飞行，然后再以滑翔方式返回地面</p><p>高速飞行器使用垂直尾翼来<strong>增大方向静稳定性</strong></p><p>要求飞机能够成功飞行，先不必解决方便维护746</p><p>图-144超音速旅客机的机头向下偏转的原因是由于<strong>机头太长，方便观察跑道</strong></p><p>采用多支点多轮小车式起落架的目的是减小机轮对<strong>跑道的压强、减小起落架对飞机的局部载荷</strong></p><p><strong>C-37“金雕”、X-29</strong>采用前掠翼布局（选质数）</p><p>天宫一号与神舟<strong>8 9 10</strong>飞船进行对接</p><p>“捕食者”无人机采用倒V型尾翼</p><p>汶川地震后，<strong>Mi-26</strong>吊装13.2吨挖掘机</p><p>国庆60周年首批歼击机女飞行员所驾驶的飞机机型是<strong>K-8</strong></p><p>A-320在<strong>天津</strong>投产</p><p>俄罗斯第五代战机为<strong>T-50</strong></p><p>“鹞”式战斗机的起落架为“<strong>自行车</strong>”式，6个辅助喷口</p><p>北京一号是<strong>通用飞机</strong></p><p>AM42型发动机是<strong>气缸成V型排列、有增压器、采用水冷却系统</strong>的航空活塞发动机</p><p>米格飞机上“纠偏机构”主要解决机轮定向归位问题</p><p>安-225采用“小车式“起落架，<strong>32</strong>个轮胎</p><p>厚、轻的蒙皮为<strong>蜂窝夹层结构蒙皮</strong>792</p><p>乒乓球在鼓风机中，<strong>重力与阻力</strong>平衡</p><p>边界层从翼面分离时机翼升力下降</p><p>红外隐身的主要措施有<strong>采用涡扇发动机、采用矩形二元喷管、发动机布置在机身或机翼上面</strong></p><p>导航显示只选机场、方位台，主飞行显示器选航向角、俯仰角</p><p>2009国庆阅兵女飞行员开<strong>K-8</strong></p><p>航天器再入段是<strong>80-100km</strong></p><p>副翼负责<strong>滚转</strong>运动</p><h2 id="新题">新题</h2><p>歼11战斗机是中国在引进俄罗斯<strong>苏-27</strong>战斗机基础上;自行生产的第三代重型空中优势战斗机。</p><p>国际空间站建成后总质量超过<strong>400</strong>吨</p><p>发射“天舟”货运飞船的运载火箭是<strong>长征7号</strong></p><p>逃逸塔的发动机为<strong>固体火箭发动机</strong></p><p>36 37 38 57 61 63 77 80 104 110 113 121 126</p><p>与传统的机械陀螺仪相比，激光陀螺的主要优势是<strong>无旋转部件和摩擦部件</strong></p><p>人类首架在其他行星上飞行的可控飞行器是<strong>机智号</strong></p><p>北斗卫星的发射场是<strong>西昌卫星发射中心</strong></p><p>歼20于<strong>2017</strong>年正式服役</p><p>仅有一个中央发射机和一个接收机的相控阵雷达属于<strong>有源相控阵雷达</strong></p><p>陀螺转子轴的进动方向取决于<strong>动量矩方向</strong>和<strong>外力矩方向</strong></p><p>神舟<strong>13</strong>号飞船……空间站长期有人驻留</p><p>东风17属于<strong>高超声速弹道导弹</strong></p><p>火箭发动机与航空发动机相比，其主要优势为推力与飞行高度无关、推力不受飞行姿态影响、飞行速度不受限制、推重比高（全选）</p><p>雷达隐身的主要措施是应用吸波材料、采用倾斜的双立尾、外形隐身</p><p>红外隐身的主要措施是</p><p>可重复使用的载人航天器除了航天飞机外还有<strong>“龙”飞船</strong></p><p>无人航天器再入大气层时的再入角一般为<strong>3-8</strong></p><p>从北斗1号到北斗3号共发射了<strong>59</strong>颗卫星</p><p>嫦娥5号携带<strong>2kg</strong>月壤</p><p>AC313是中国第一个完全按照适航条例规定和程序自行研制的<strong>大型</strong>运输直升机</p><p>北斗3号<strong>2020</strong>年开通</p><p>载人飞船返回时大段朝前的主要目的是<strong>尽快减速</strong></p><p>“和平号”科学实验舱有<strong>5</strong>个舱室</p><p>国际空间站中加拿大的遥控机械臂可搬动<strong>20吨</strong></p><p>声爆的强弱同飞行高度、飞行速度、飞机重量、飞行姿态、大气状态有关，和发动机推力无关</p><p>2011年1月11日，歼20首飞成功</p><p>252-254</p><h2 id="易错题">易错题</h2><p><strong>天舟一号</strong>中国第一次“太空加油”</p><p>超声速飞机梢根比<strong>较小</strong></p><p>轴流式压气机中转子叶片的作用是<strong>增压增速</strong>，相邻叶片构成的通道是<strong>扩散形</strong></p><p>轴流式压气机工作的过程中，静子叶片的作用是<strong>改变气流方向、增压</strong></p><p>涡轮喷气发动机涡轮导向器叶片的通道是<strong>收缩形</strong></p><p>20世纪<strong>70年代</strong>后期，飞行器座舱中出现了电子式显示器</p><p>仅有一个中央发射机和一个接收机的相控阵雷达属于<strong>无源</strong>相控阵雷达</p><p>每个辐射器都装有一个发射/接受组件的相控阵雷达属于<strong>有源</strong>相控阵雷达</p><p>GPS从70年代开始研制，1994年完成</p><p>北斗卫星从<strong>西昌</strong>卫星发射中心发射</p><p>纵墙主要承受<strong>剪力</strong></p><p>导弹的气动布局、三代战斗机代表机型</p><p>歼31<strong>常规气动布局</strong></p><p>雷达隐身的措施主要包括外形隐身、倾斜双立尾、应用吸波材料（不降温）</p><p>红外隐身可采用涡扇发动机、矩形二元喷管、发动机布置在机身或机翼上面（不吸波）</p><p>减小激波阻力的方法有<strong>三角机翼、边条、鸭式</strong>60-65</p><p>三轴稳定法是俯仰轴、偏航轴、滚转轴（无自转轴）</p><p>涡轮螺桨与活塞式相比，具有功率重量比大、振动小、耗油率小（低空性能不好）</p><p>涡轮螺桨与涡喷相比，具有功率低亚声速飞行速率高、耗油率小</p><p>靠风扇，排气速度不大</p><p>桨扇可达800km/h以上</p><p>液体火箭发动机可重启但没有推力终止装置</p><p>固体火箭发动机常用于<strong>导弹、探空火箭、飞机起飞的助推器</strong></p><p>导航显示仪显示的内容包括机场、地标位置和标高、航向角</p><p>发射台、低空状态：弹射座椅、逃逸塔</p><p>在轨飞行：中断飞行计划</p><p>返回阶段：多个并联制动发动机、多降落伞、弹射座椅</p><p>无人机地面控制站全选166</p><p>无人机数据链路：机载数据终端、地面设备</p><p>飞行器结构：受力部件、支撑构件</p><p>蒙皮也参与承受弯矩、剪力、扭矩</p><p>后三点、前三点190</p><p>后三点起落架的优点是易于安装尾轮、结构简单；着陆滑跑迎角大</p><p>缺点是易倒立、低空失速、视界不好、方向稳定性差</p><p>前三点式的优点是以上改正</p><p>缺点是前起落架复杂（载荷大）、前轮易摆振</p><p>载人飞船一般由轨道舱、服务舱和__乘员返回舱组成（小程序为全选）</p><p>飞船轨道舱有工作区和生活区</p><p>航天飞机轨道器=飞机</p><p>串联的优点：气动阻力小、级间连接简单、分离时干扰小且故障少</p><p>缺点：弯曲刚度差、运输存储不便</p><p>并联的优点：加快研制、长度短</p><p>并联型多级火箭的缺点是<strong>飞行阻力大、分离时干扰大、级间连接较复杂</strong>，弯曲刚度不差</p><p>天宫1号和神舟8号空间无人交会对接</p><p>临近空间的区域为20km-100km</p><p>低动态临近空间飞行器不包括亚轨道飞行器</p><p>战术导弹用固体火箭发动机</p><p>战斗机涵道比小于1</p><p>产生推力矢量的方式不包括摆动发动机</p><p>火箭飞行时的俯仰、偏航靠喷管摆动，滚转靠侧面喷管</p><p>直升机不选直4</p><p>双垂直尾翼增大<strong>方向静稳定性</strong></p><p>长时间爬升、加速平飞为<strong>额定状态</strong></p><p>蒙皮不按外挂其他都选</p><p>航天飞机中可重复使用的部分不包括返回舱，因为没有返回舱</p><p>太空加油是<strong>天舟1号</strong></p><p>786</p><p>AM42型发动机是一种<strong>汽缸成V型排列、有增压器、采用水冷却系统</strong>的航空活塞发动机（无变速加速器）</p><p>联管燃烧室的主要特点是<strong>各火焰筒在同一环腔内</strong>，但而非通过联焰器……</p><p>载人飞船逃逸舱指应急舱</p><p>无人机数据链路的地面设备主要由<strong>视频接收机、终端处理机</strong>等组成（不选瑶瑶）</p><p>无人机的机载数据终端主要由<strong>机载天线、遥控接收机、终端处理机</strong>组成</p><p>“鸭”式布局起降好、高速好、升力好，但稳定性不好</p><p>属于飞机机翼纵向骨架的是翼梁、纵墙、桁条</p><p>机翼的基本受力部件选全部</p><p>320-340</p><p>火箭发动机性能参数没有推进剂消耗率</p><p>发动机类型有组合</p><p>纵向骨架有桁条</p><p>双垂直尾翼增大方向静稳定性</p><p><strong>XX方向稳定性！</strong></p><p><strong>第几代飞机</strong></p><p><strong>收缩扩张</strong></p><p><strong>新题</strong></p><p>各种机翼</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OO第四单元总结</title>
    <link href="/2024/06/10/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/06/10/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span><br />源码见 <ahref="https://github.com/solor-wind/BUAA_OO">https://github.com/solor-wind/BUAA_OO</a></p></blockquote><h2 id="正向建模与开发">正向建模与开发</h2><p>事实上，在前三个单元的作业中，已经涉及了正向建模相关内容，只是还没有强制要求或者细节不到位。比如每个单元的第一次作业都要先想好一个拓展性较好的架构再开始写代码。而在这一单元中，正向建模更加突出。</p><p>在开始这一单元的作业时，首先绘制的是一个程序架构，在草稿纸上列出要实现的功能、可能要拓展的功能，然后将一些功能或属性封装起来成为类，大致确定有几个类以及每个类大致的功能和属性。比如图书馆类需要管理各种书籍以及借书处等存放书籍的地方、书籍本身并不需要建类因为官方包的<code>BookId</code> 已经足够完善。</p><p>然后，就可以在StarUML上绘制类图、状态图、顺序图了。但因为对UML的不熟悉，导致画图进程较慢而且容易出错。再加上之前只是形成了一个大致的架构，因此经常要修改属性和方法。在这一步骤中耗费了很多时间。</p><ul><li>类图：展现各个类的属性与方法、个各类之间的联系。主要纵向关系有泛化与实现，横向关系有依赖、关联、聚合、组合</li><li>状态图：述对象的状态和状态之间的转换。</li><li>顺序图：展示了对象之间的消息传递顺序，以及消息传递的时序关系。</li></ul><p>最后，就可以对照UML写代码了，由于架构、属性方法都已经建好，基本只需要无脑填写就好了。在一些细节的地方比如类的返回值、更改了两个类之间的调用方法的时候，还要及时修改UML中对应的地方。</p><h2 id="架构设计">架构设计</h2><p>这一单元的作业总体难度比前三个单元都简单一些，最终用了532行完成（去掉空行和注释共483行）</p><p>复杂度分析如下</p><figure><img src="/img/OO/OO第四单元复杂度.png" alt="OO第四单元复杂度" /><figcaption aria-hidden="true">OO第四单元复杂度</figcaption></figure><p>类图如下</p><figure><img src="/img/OO/OO第四单元类图.png" alt="OO第四单元类图" /><figcaption aria-hidden="true">OO第四单元类图</figcaption></figure><p>本单元的核心功能就是对书和人的管理，因此类的设计应当围绕书和人来设计。书的类由官方包提供，而人的属性则需要封装起来单独建立一个类，图书馆负责对书和人的管理。</p><p>书出现的地方主要有：书架、借还处、预约处、漂流书架、人</p><p>因为对每个地方的操作如查询本数等等并不复杂，同时还要经常修改这些地方的书，因此我选择将其放在图书馆类内部，用<code>HashMap</code>来代表每个地方的书籍。但从长远来看，如果要对每个地方添加新的功能，则需要单独建类来保持程序架构的清晰、简洁。</p><h3 id="整理">整理</h3><p>既在开馆时进行整理（开馆整理前先更新时间），也在闭馆时进行整理，实现函数为<code>organize</code></p><p>整理按如下次序进行：</p><ol type="1"><li>检查每个人是否有逾期的借阅书籍并进行扣分</li><li>检查是否有逾期的预约并进行扣分，若为开馆整理则进行移动</li><li>将借阅处的书籍移动到书架或漂流角，并进行加分（若有）</li><li>处理尚未完成的预约</li></ol><h3 id="处理请求">处理请求</h3><p>总体先用 <code>dealRequest</code>进行分类，然后进入具体方法执行重点为借阅、预约两条指令。</p><h4 id="借阅">借阅</h4><p>先将要借阅的书分为漂流角和书架两类，然后按照A类书、B类书、信用分查找是否满足条件。对应方法为<code>borrow</code></p><h4 id="预约">预约</h4><p>先判断信用分、是否是漂流角书籍，然后按条件检查是否能借阅。能则加入到预约队列中，即<code>LinkedList&lt;String&gt; logP,LinkedList&lt;LibraryBookId&gt; logB</code>。同时，预约处已经存在的书籍以<code>LinkedList&lt;LibraryBookId&gt; aoBook</code>等类型的容器存储信息。预约的对应方法为 <code>order</code></p><h3 id="读者">读者</h3><p><code>HashMap&lt;LibraryBookId, LocalDate&gt; books</code>存储当前读者借阅的书籍以及对应逾期时间，方便进行逾期判断与处理。</p><h3 id="代码与uml">代码与UML</h3><p>由于遵循了先UML后代码的顺序，最终UML模型和最终的代码设计基本一致。</p><h2 id="oo课程架构设计思维">OO课程架构设计思维</h2><p>OO第一单元：层次化设计的思想的应用和工程实现将其——递归下降解析表达式</p><ul><li>通过单元训练理解了递归下降的架构和层次化设计思想</li><li>通过第二次作业的重构真正运用了层次化设计思想</li></ul><p>OO第二单元：多线程的设计方法——模拟多线程实时电梯系统</p><ul><li>通过第五次作业学习了多线程的编写方法</li><li>通过第六、七次作业学习了电梯的调度方法、死锁避免与处理方法</li></ul><p>OO第三单元：JML规格理解与代码实现——实现简单社交关系的模拟和查询</p><ul><li>学习了JML</li><li>实践了Junit等各种测试方法</li></ul><p>OO第四单元：正项建模与开发——使用UML设计图书馆系统</p><ul><li>学习了UML中类图、状态图、顺序图的制作方法</li><li>领悟了正向建模对较大代码量程序设计的帮助</li></ul><h2 id="oo课程测试思维">OO课程测试思维</h2><p>很幸运在课程中通过了每一次强测和互测。</p><p>在课程中，也学到并运用了许多测试思维，编写了评测机。事实证明，下面的每种方法都必不可少。评测机源码见<ahref="https://github.com/solor-wind/BUAA_OO_TEST">BUAA_OO_TEST</a></p><h3 id="静态分析">静态分析</h3><p>个人在这方面的做法主要包括两方面：</p><ul><li>逐条比对指导书。写完代码后，将指导书每一行都阅读一遍，确保没有缺少功能/错误实现功能</li><li>逐行分析代码。将代码的每行阅读一遍，确保每一行、每个方法都达到了目的。</li><li>白箱测试。主要针对互测环节，阅读他人代码寻找bug</li></ul><h3 id="动态测试">动态测试</h3><p>这部分收获最大，主要是与zx一同完成了覆盖每次作业的功能较为完善的评测机。在编写评测机的过程中，无论负责数据生成还是正确性检验，事实上都要求对指导书仔细理解，确保不会遗漏各种情况，也因此经常会出现边改评测机边改自己代码的情况。</p><ul><li>黑箱测试。按指导书数据限制，以一定比例生成尽量全覆盖的数据，并进行正确性检验。</li><li>压力测试。针对指导书的边界限制条件和特殊情况，构造有针对性的数据。如第一单元的exp(0)、第二单元在第50秒给出70条指令等等。大部分都需要手动构造。</li></ul><h2 id="oo课程收获">OO课程收获</h2><h3 id="代码量">代码量</h3><table><thead><tr class="header"><th style="text-align: center;">作业</th><th style="text-align: center;">含注释与空行</th><th style="text-align: center;">不含注释与空行</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">hw3</td><td style="text-align: center;">775</td><td style="text-align: center;">679</td></tr><tr class="even"><td style="text-align: center;">test3</td><td style="text-align: center;">504</td><td style="text-align: center;">385</td></tr><tr class="odd"><td style="text-align: center;">hw7</td><td style="text-align: center;">1236</td><td style="text-align: center;">1091</td></tr><tr class="even"><td style="text-align: center;">test7</td><td style="text-align: center;">477</td><td style="text-align: center;">397</td></tr><tr class="odd"><td style="text-align: center;">hw11(除去官方包)</td><td style="text-align: center;">1604</td><td style="text-align: center;">1407</td></tr><tr class="even"><td style="text-align: center;">test11</td><td style="text-align: center;">1470</td><td style="text-align: center;">1325</td></tr><tr class="odd"><td style="text-align: center;">hw15</td><td style="text-align: center;">532</td><td style="text-align: center;">483</td></tr><tr class="even"><td style="text-align: center;">test15</td><td style="text-align: center;">933</td><td style="text-align: center;">843</td></tr></tbody></table><blockquote><p>hw为作业，test为评测机（和zx一起完成）</p></blockquote><p>OO课程应该是上大学以来代码量最大的一门课程了。对比来看，大一下的数据结构大作业只有325行（含注释与空行），大二上的计组最终写了1622行（含注释与空行），OOpre最终写了1328行（无注释与空行1102）。从这里就可以看出，OO成功训练出了我们<strong>短时间内写出大量高质量代码</strong>（<del>或者屎山</del>）的能力，真的让我受益匪浅</p><h3 id="架构与重构">架构与重构</h3><p>总共4个单元，每个单元的三次迭代都添加了意想不到的功能，这对架构设计是十分严苛的考验，但也逼迫我学会了<strong>先设计架构再写代码</strong>、提前思考功能并<strong>预留拓展性</strong>的能力。以第一单元为例，由于第一次作业仅为多项式结构，并不设计嵌套单元，因此在架构层面偷懒。结果第二次作业的exp就让我苦不堪言，思考了好几天才重构出一个可以存储、运算的架构。</p><h3 id="建议">建议</h3><ul><li>希望能开放评测机的运行环境、硬件设备等信息，方便进行测试。或者改变评测机运行方式，不是高强度并发而是分散均匀测试。</li><li>适当放宽代码风格检查的限制，比如“不能使用形如import*”这一条对建立软件包来说很不友好</li><li>后两个单元可以放一些其他内容，或者改进junit评测和顺序图评测、减少指导书修改次数</li></ul><h3 id="致谢">致谢</h3><p>感谢助教们的辛勤付出，让我的代码能力得到极大提升。感谢我周围的同学们，对我顺利完成作业提供了很多帮助。感谢Hyggge，OO前两个单元的领路人。</p><h2 id="结语">结语</h2><p><em>OO结束了，但以程序员生涯的视角来看，它并没有结束，甚至不是结束的开始，而只是开始的结束。</em></p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OO第三单元总结</title>
    <link href="/2024/05/16/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/16/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span><br />源码见 <ahref="https://github.com/solor-wind/BUAA_OO">https://github.com/solor-wind/BUAA_OO</a></p></blockquote><h2 id="题目概述与架构">题目概述与架构</h2><p>维护一个简单的社交网络，对其中的用户和彼此之间的关系、标签、消息进行管理</p><ul><li>第9周：维护一个图，修改操作包括：添加节点、添加/删除/修改边，主要查询操作包括：查询两节点是否联通、查询极大联通子图的数量、查询三元组的数量</li><li>第10周：增加tag（子图），新增修改操作：向某个节点添加标签、向标签内添加/删除节点，新增查询操作：子图内所有边权之和、两节点之间的最短路径（边权视为1）、互为最好朋友的节点对个数（即彼此边权最大）</li><li>第11周：增加message，新增修改操作：添加/删除/发送消息，新增查询操作：查询消息相关</li></ul><figure><img src="/img/OO/OO第三单元架构.png" alt="OO第三单元架构" /><figcaption aria-hidden="true">OO第三单元架构</figcaption></figure><h2 id="算法与时间复杂度">算法与时间复杂度</h2><p><del>我宣布，这是BFS的胜利，是摆烂人的胜利</del></p><p>课程组限制：10000条指令，CPU最大运行时间10s，最多使用760MB空间</p><p>显然，程序的整体时间复杂度不能超过 <spanclass="math inline">\(O(n^2\log n)\)</span>，也意味着每个方法的时间复杂度不能超过 <spanclass="math inline">\(O(n\log n)\)</span>​</p><h3 id="第9周">第9周</h3><p>主要难点在于 <code>qci(query_circle)</code> 、<code>qbs(query_block_sum)</code> 和 <code>qts(query_triple_sum)</code>这三条指令</p><ul><li>qci：查询两点之间是否存在路径。两点、路径，最先想到的是dijstra算法，但事实上这一询问只要求返回是否存在，因此可以考虑其他实现更加简单、时间复杂度更优的算法。往届大都采用并查集，但本次第一次作业就加入了删除操作，使得并查集的动态维护变得复杂，因此被我放弃（<del>主要是因为懒</del>）。最终我采用了BFS，单次查询时间复杂度<span class="math inline">\(O(V+E)\)</span> ，即 <spanclass="math inline">\(O(n)\)</span> ，可以通过。（dfs可能爆栈）</li><li>qbs：查询图中极大联通子图的数量（相当于有几个连通块）。同样采用BFS解决</li><li>qts：查询图中三元组（triple，三个节点互相连接）的数量。这个没办法BFS了，只能通过动态维护实现。当新增边/删除边时，遍历这条边的两个节点的公共节点，增加/删除<code>triple</code> 的数量。维护的时间复杂度 <spanclass="math inline">\(O(n)\)</span> ，查询时间复杂度为 <spanclass="math inline">\(O(1)\)</span></li></ul><h3 id="第10周">第10周</h3><p>主要难点在于 <code>qtvs(query_tag_value_sum)</code>、<code>qbs(query_best_acquaintance)</code> 、<code>qcs(query_couple_sum)</code> 和<code>qsp(query_shortest_path)</code> 四条指令</p><ul><li>qtvs：查询子图中的边权之和。采用类似BFS的方法实现，遍历tag（子图）中的每一个节点，遍历与节点直接相连的每一条边，若这条边的另一节点也在子图中，则加上对应权重。看似两层循环，时间复杂度为<span class="math inline">\(O(n^2)\)</span>，但实际上最多对每条边遍历2次，因此类似BFS，仍然为 <spanclass="math inline">\(O(n)\)</span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : persons.keySet()) &#123;<span class="hljs-comment">//注意第二层不能改为遍历子图节点，否则真就变成O(n^2)了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : ((MyPerson) persons.get(i)).getAcquaintance().keySet()) &#123;<br>        <span class="hljs-keyword">if</span> (persons.containsKey(j)) &#123;<br>            valueSum += persons.get(i).queryValue(((MyPerson) persons.get(i)).getAcquaintance().get(j));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>qba：查询某人的最好朋友是谁（节点连接的所有其他节点中，边权最大且序号最小的）。动态维护有序的数据，可以采用TreeMap。具体采用<code>TreeMap&lt;Integer, TreeSet&lt;Integer&gt;&gt;</code>的嵌套方式。第一层以边权为key，Set为value；第二层存储id。这样就可以用<code>map.get(map.lastKey()).first()</code>的方式得到边权最大的set中的id最小的结果。动态维护时间复杂度为 <spanclass="math inline">\(O(\log^2 n)\)</span> ，单次查询时间复杂度为 <spanclass="math inline">\(O(1)\)</span></li><li>qcs：查询couple（彼此的关系（边权）最好且序号最小）的数量。解决了qba之后，qcs就十分简单——直接遍历当前所有节点，对符合“某人的最好朋友的最好朋友是自己”的节点进行计数即可，最后除以二。时间复杂度<span class="math inline">\(O(n)\)</span></li><li>qsp：查询一个节点到另一个节点之间最少需要经过几个节点。我一看——这不是单源最短路么！——堆优化dij秒了。后来发现由于边权视为1，直接用BFS就行，但是已经写完dij了，<del>又懒得改了</del>。堆优化dij时间复杂度<span class="math inline">\(O(n\log n)\)</span> ，BFS依然 <spanclass="math inline">\(O(n)\)</span></li></ul><h3 id="第11周">第11周</h3><p>架构上，network中用HashMap存储Message，而Person中用LinkedList存储Message。对于emojiMessage，则采用<code>HashMap&lt;Integer,Integer&gt;</code>的方式存储emojiId和heat。同时，MyEmojiMessage等类还要继承MyMessage类，避免大量重复代码。</p><p>性能方面基本不会有太多问题，唯一需要注意的是emojiMessage相关的操作，不仅要区分messageId和emojiId，还要知道什么时候删除、从哪些容器中删除</p><h2 id="本单元的测试过程">本单元的测试过程</h2><h3 id="黑箱测试与白箱测试">黑箱测试与白箱测试</h3><p>黑箱测试顾名思义，把测试对象看作一个黑箱，完全不考虑程序内部的逻辑结构和内部特性而检查程序的功能是否符合它的功能说明。在本次作业中就对应不看程序代码而只测试正确性，此时需要结合JML，构造覆盖率较高、较为全面的测试点进行测试。</p><p>白箱测试则相反，程序内部的逻辑结构和内部特性完全可见，此时不仅要通过测试点对齐进行测试，还要分析其内部代码结构是否符合功能规范。本次作业中对应自己和互测过程中的静态代码检查，通过阅读代码逻辑来找到和JML不一致的地方，进行有针对的测试。</p><h3 id="各种测试">各种测试</h3><h4 id="单元测试">单元测试</h4><p>单元测试，是指对软件中的最小可测试单元进行检查和验证。在这次作业中，对应于对每个方法的测试，要结合JML的约束来测试，比如<code>pure</code> 约束要求不能有任何副作用。</p><h4 id="功能测试">功能测试</h4><p>功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。在这次作业中就要求对社交网络的各个功能/指令去进行测试，看是否正常运行。</p><h4 id="集成测试">集成测试</h4><p>在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。在本单元的作业中，相当于各个方法之间互相调用、各个类之间相互合作的测试，即测试过程中对多个方法的联合调用进行测试。</p><h4 id="压力测试">压力测试</h4><p>压力测试，一般为长时间或超大负荷地运行测试软件来测试被测系统的性能、可靠性、稳定性等。在本次作业中就明显的表现为对时间复杂度过高的方法集中调用以测试是否超时。</p><h4 id="回归测试">回归测试</h4><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。具体表现为每次迭代开发的过程中，不仅要对新引入的指令、方法进行测试，还应对之前的方法进行测试以防错误修改出现bug</p><h2 id="评测机与手动数据构造">评测机与手动数据构造</h2><h3 id="评测机">评测机</h3><p>本次依然与zx合作完成评测机的搭建，主要负责数据生成部分。由于能够卡时间、测试性能的样例基本不可能随机构造出来，因此本次数据生成主要针对正确性部分，而性能测试点手动构造完成。具体思路如下：</p><p>首先将随机生成指令数量，第三次作业默认将40%的指令用于建图，15%用于添加tag，35%用于添加消息，10%用于查询，比例可调。</p><p>具体代码已经开源<ahref="https://github.com/solor-wind/BUAA_OO_TEST">https://github.com/solor-wind/BUAA_OO_TEST</a></p><h4 id="建图">建图</h4><p>首先不能纯随机建图，否则生成的图过于稀疏，强度过低，覆盖不到所有情况。因此，采用的洛谷的数据生成器，首先生成一个较为稠密的图，然后随机添加散点，再随机添加散点到稠密图之间的边。这样可以保证稠密图、线状图、散点三者皆有，覆盖尽可能多的情况。</p><h4 id="添加节点">添加节点</h4><p>tag相关指令要求子图内的节点数量不能过少，因此采用了类似建图的方法。先添加一些比较大的子图，再随机生成相关tag</p><h4 id="添加消息">添加消息</h4><p>由于消息必须要两个节点之间有边或者tag存在才有效，因此上述两个过程需要保留已经建立的边和tag相关数据，方便生成有效的消息。</p><h4 id="查询">查询</h4><p>随机查询，其中查询已有节点、tag等指令占查询的80%，其余为随机查询。</p><h3 id="手动数据构造">手动数据构造</h3><p>大多数情况下，评测机可以覆盖较多的正确性检验情况，手动数据构造在本单元一般用于压力测试。</p><p>下面以第一次作业中的 <code>qci(query_circle)</code>指令为例，构造压力测试</p><p>针对BFS，构造如下数据：使用ln构造300个点的完全图，而后再用6000条数据构造一条长链，共计3300个点的连接图，而后剩余指令查询两端是否连通。</p><p>针对DFS，构造如下数据：使用ln构造300个点的完全图，而后再用9990条数据构造一条长链，共计5295个点的连接图，而后剩余指令查询两端是否连通。</p><p>针对并查集和延迟维护/延迟查询，构造如下数据：使用ln构造300个点的完全图，而后再用5000条数据构造一条长链，共计2800个点的连接图，而后剩余指令以下面形式为一组进行删边、加边、查询。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">mr 300 301 -1<br>qci 1 2800<br>ar 300 301 1<br></code></pre></td></tr></table></figure><h2 id="性能bug规格与实现junit">性能bug、规格与实现、Junit</h2><p>很幸运本单元没有在强测和互测中发现bug，性能bug也没有出现。</p><p>对于JML，仅仅是对方法的前提、副作用与结果进行了约束，并未对具体实现有所约束。因此，要采取合适的数据结构进行存储（如用HashMap存储Person），采用合适的算法进行计算（如动态维护triple而非三重循环）</p><p>对于Junit，一定要利用规格信息来更好的设计实现Junit测试。本单元的Junit测试提交了多次，大部分原因都是忽略了方法中的<code>pure</code>等副作用限制或检查不足。对于副作用的检查，不仅要采用类似影子电梯式的构造方法防止浅拷贝，还要对每一属性进行检查，同时对数据生成也要保证有所覆盖。</p><h2 id="心得体会">心得体会</h2><p>这个单元的压力相比前两个单元小了很多，主要是因为课程组为我们搭好了总体架构，而且有JML对方法功能进行描述，自己只需严格按JML来并保证时间复杂度不太高即可。</p><p>关于JML，这种契约式编程思想主要应用于航空航天等高精尖领域，对代码正确性要求极为严格。实现是一定要注意方法的前提与副作用，不能只专注于功能。</p><p>槽点：</p><ol type="1"><li>关于代码风格限制。500行的行数限制，然而Runner超过700行，且使用了import*。</li><li>关于时间限制。过于严苛的时间限制，又不公布评测机硬件环境。从公测结束到强测开始，长达好几个小时的时间是否可以均匀测试，而非短时间内高强度并发？</li><li>频繁修改指导书</li></ol>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OO第二单元总结</title>
    <link href="/2024/04/15/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/15/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span><br />源码见 <ahref="https://github.com/solor-wind/BUAA_OO">https://github.com/solor-wind/BUAA_OO</a></p><p>！注意：第二单元第三次作业有千分之三的概率出现撞梯的bug</p></blockquote><h2 id="关于线程">关于线程</h2><h3 id="在哪里使用多线程">在哪里使用多线程</h3><p>进入电梯这一单元，首先困扰我的是在哪里使用多线程。</p><p>这一单元的任务乍一看似乎并不需要使用多线程，只需要建类模拟即可。但是，从完成作业的角度出发，由于时间戳的检验，必须开启线程并sleep一定时间来通过测试。</p><p>那么，应该在哪里使用多线程呢？首先，官方投喂包给出了建议——输入要开一个线程，这就是第一个线程了。其次，6个电梯似乎也应该也应该对应6个线程，每个线程单独处理这一电梯的乘客。这大体就是要使用线程的地方。</p><h3 id="线程和实例">线程和实例</h3><p>知道了在哪里使用多线程，还要思考怎么使用。线程其实可以理解为任务，也就是宏观上同时有多个任务在执行。</p><p>首先是输入部分，可以把获取输入的部分写到run函数中，然后在主类里启动。</p><p>其次是电梯部分，电梯应该获取输入并处理乘客的需求，可以再输入类里启动电梯线程，把获取乘客、处理请求的部分写进run函数中。</p><p>输入类从标准输入获取输入，而电梯如何获取乘客呢？类比生产者-消费者模式，可以建一个请求列表，输入类将输入分类以后放入每个电梯对应的列表中，电梯再从列表里读取。具体的，可以再输入类中建立请求列表并存储，然后在新建电梯类时将已经建好的列表传递给电梯，这样输入类和电梯类就共享同一个请求列表。</p><p>在上面的分析中，可以将实例（比如某个类）理解为线程的载体，输入类的run让输入线程知道怎么执行任务，电梯类也是。而电梯线程、输入线程除了分别要执行电梯类、输入类中的一些方法，还要去访问一些实例，比如请求队列。当两个线程共同访问一个实例，或执行同一个方法时，可能会出现问题，这时就要上锁。</p><h3 id="上锁">上锁</h3><p>上锁的办法主要由三种：锁对象、锁方法、Lock类</p><h4 id="锁对象">锁对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (a)&#123;<br><span class="hljs-comment">/*To Do*/</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，对象a成为了锁，执行这一段代码的线程持有锁a，任何其他线程没办法进入由a锁住的任何代码段（不限于这一个代码段）</p><h4 id="锁方法">锁方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dosth</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">/*To Do*/</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，方法dosth本身成为了锁，任何时间内只有一个线程能进入并执行这一方法。</p><h4 id="lock类">Lock类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.lock();<br><span class="hljs-comment">/*To Do*/</span>;<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>感觉既有锁方法的特性，又有锁对象的特性。在线程a进入<code>lock.lock()</code> 之后，就获取了锁，其他线程无法再进入被<code>lock.lock()</code> 限制住的代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>readWriteLock.readLock().lock();<br><span class="hljs-comment">/*To Do*/</span>;<br>readWriteLock.readLock().unlock();<br><span class="hljs-comment">/*..</span><br><span class="hljs-comment">*...</span><br><span class="hljs-comment">*/</span>..<br>readWriteLock.writeLock().lock();<br><span class="hljs-comment">/*To Do*/</span>;<br>readWriteLock.writeLock().unlock();<br></code></pre></td></tr></table></figure><p>读写锁是一种特殊的锁，多个线程可以同时持有readLock，但当一个线程持有writeLock时，其他线程都被阻塞在外。</p><h3 id="轮询与死锁">轮询与死锁</h3><p>可以理解为一个线程的run代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">synchronized</span> (a)&#123;<br><span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中a还由其他线程访问。可以看到如果a一直不大于0，那么线程就会反复执行这段代码，反复进行if判断，而且进入锁时还阻塞了其他线程，很浪费CPU时间。下面的代码就一定程度避免了轮询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">synchronized</span> (a)&#123;<br><span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span><br>                a.wait();<span class="hljs-comment">//简写了，实际还要用try-catch包围</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，线程在a&lt;0时会先等待，当a的值被其他线程修改时，由其他线程来唤醒这个线程。</p><p>具体到作业就是当请求队列为空且电梯里没人时，可以先让电梯线程wait，当输入线程加入新的请求后，由输入线程去唤醒电梯线程（因为共享同一个关于请求队列的锁）</p><p>一种死锁情况大致长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dosth1</span><span class="hljs-params">()</span>&#123;<br>    dosth2();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dosth2</span><span class="hljs-params">()</span>&#123;<br>dosth1();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果线程A进入 <code>dosth1()</code> 的同时，线程B进入<code>dosth2()</code>，那么两个线程就会因为获取不到双方所需的锁而都处于阻塞状态，进入死锁。防止死锁的方法之一是尽量不使用嵌套锁。</p><h2 id="代码架构">代码架构</h2><p><del>依托屎山</del></p><h3 id="架构与时序图">架构与时序图</h3><figure><img src="/img/OO/OO第二单元UML图.png" alt="OO第二单元UML图" /><figcaption aria-hidden="true">OO第二单元UML图</figcaption></figure><p>首先是输入类，根据课程组的输入包创建线程，进而创建调度器类，调度器再创建每个电梯的请求队列和电梯本身，并将请求队列、全局队列放入电梯中。</p><p>当有输入时，输入类调用调度器的分配方法进行分配，调度器根据算法将输入放到某个电梯的请求队列中并唤醒这个电梯，而后电梯开始运行，直至所有请求执行完毕。</p><p>大致的时序图如下</p><figure><img src="/img/OO/OO第二单元时序图.png" alt="OO第二单元时序图" /><figcaption aria-hidden="true">OO第二单元时序图</figcaption></figure><h3 id="作业变化">作业变化</h3><h4 id="第一次作业">第一次作业</h4><p>第一次作业只要求完成电梯运行即可，由输入为每个人指定电梯。</p><p>采用生产者-消费者模式。生产者即输入线程，不断提供新的输入；消费者是电梯，将请求处理完毕。</p><p>连接生产者和消费者的托盘是调度器和请求队列。输入线程调用调度器的分配方法，而调度器和每个电梯都共享一个请求队列，因此由调度器将请求放到对应电梯的请求队列中。</p><p>多线程下的共享对象只有请求队列，因此对请求队列加锁即可。</p><h4 id="第二次作业">第二次作业</h4><p>第二次作业不再指定电梯，而是由我们实现调度功能，同时还新增了电梯重置。</p><p>与第一次作业相比，新增了影子电梯这一类来实现相应的调度策略。具体来说，调度器调用电梯类获得当前电梯的状态，以影子电梯类型返回，而后再调用影子电梯中的方法模拟运行时间做出选择。对于电梯重置，新增了全局请求队列，调度器和所有电梯共享，重置时将电梯内的乘客和请求队列中的请求退回到全局请求队列，结束时调用分配方法进行再分配。</p><p>第二次作业中新增了全局请求队列这一共享对象，类比请求队列加锁即可。但是，影子电梯策略还使得每个电梯内的所有状态都称为共享对象，必须解决调度器线程和电梯线程的冲突。与第一次作业不同，我从锁对象改为了锁方法，又改为了使用Lock锁。但不停地改动、过多的共享对象终于使代码成为了屎山，臃肿不堪。</p><h4 id="第三次作业">第三次作业</h4><p>第三次作业新增了重置为双轿厢电梯。</p><p>对策是新增一个换乘楼层类作为AB两个电梯的共享对象，当一个要改变楼层时，先对换乘楼层中的数据进行修改，如果发现另一个电梯也在换乘楼层，则进入等待并将驱离请求设为true，另一电梯在会在离开楼层后唤醒这一电梯。</p><p>第二次作业已经是屎山，但第三次作业又让代码混乱程度更上一层楼。主要原因是使用了线程池，但由于电梯回调调度器这一策略使得结束条件难以设定，最终在不断尝试中勉强通过。当完成双轿厢电梯重置后，原电梯先要克隆出AB两个电梯放入调度器类，然后结束。当调度器将请求分配给已经结束的电梯时，还要通过线程池重启线程。这中间的线程调度过于复杂，导致了debug过程也极其困难。</p><h3 id="复杂度分析">复杂度分析</h3><figure><img src="/img/OO/OO第二单元方法复杂度.png"alt="OO第二单元方法复杂度" /><figcaption aria-hidden="true">OO第二单元方法复杂度</figcaption></figure><p>可以看到方法复杂度相比上一单元有了明显的提升。</p><p>allocate方法负责处理各种请求，包括重置请求，调用分配方法将其放入对应电梯的等待队列并唤醒电梯。除此之外，还承担了输出receive、判断结束线程池的任务，从而导致复杂度较高。</p><p>wtf方法负责影子电梯的调用，将请求放入影子电梯中并调用该电梯的模拟方法拿到运行时间，选择最小时间并返回电梯编号。其中由于需要判断电梯是否在重置、双轿厢电梯换乘楼层的选择等导致复杂度较高。</p><p>Shadow类中的in_out方法负责open状态下的人员进出。事实上在Elevator类中已经将in和out分离开来，但忘记修改影子电梯的方法。</p><p>Strategy类中的两个get_advice方法负责实现单个电梯的运行策略，接受当前电梯的状态并返回策略，涉及到大量的条件判断以及特殊判断，从而复杂度较高。</p><figure><img src="/img/OO/OO第二单元类复杂度.png" alt="OO第二单元类复杂度" /><figcaption aria-hidden="true">OO第二单元类复杂度</figcaption></figure><p>最终可以看到，Elevator、Allocater、Strategy由于包含了上述复杂度较高的方法，类复杂度也居高不下。</p><p>总共1118行（去除空行987行）</p><h2 id="策略与性能">策略与性能</h2><h3 id="调度策略">调度策略</h3><p>采用<strong>影子电梯</strong></p><p>什么是影子电梯？简而言之，就是把当前所有电梯的状态复制一份，称为“影子”。将需要处理的请求分别加入这些影子电梯的等待队列，模拟电梯完成运送过程，获得各个电梯运行所需时间，选择时间花费最小的电梯分配请求。</p><p>可以看出，影子电梯类似贪心，总是选择当前状态下的最优解，以此来逼近全局最优解。具体实现如下：</p><ol type="1"><li>克隆电梯类。这一过程中要解决多线程共享对象下读写冲突，同时还要考虑克隆的“精度”问题。对于前者我选择将电梯类中需要克隆的对象在读写前后加上Lock类型的锁，对于后者我仅仅精确到电梯楼层与方向、开门状态和乘客，处于开门第几秒、移动第几秒等信息并未克隆（因为直接sleep了，想不到啥好方法，<del>摆烂</del>）。</li><li>模拟运行。将电梯克隆完毕后，需要将对应电梯类的代码进行修改，将<code>sleep(400)</code> 换成 <code>time+=400</code>，<code>wait()</code>改为直接结束，运行结束返回时间。同时注意与原本电梯的策略应大致相同。</li><li>迭代修改。对电梯类进行修改时，也要注意对影子电梯类的对应部分进行同步修改，同时考虑策略类是否合理。</li><li>特殊判断。对于换乘电梯，其时间的计算改为运送至换乘楼层+开关门时间*2+运送到目的地楼剩余层数*移动时间。这只是一种简单近似，但完成了将双轿厢电梯归类到普通电梯的任务，使得两种类型的电梯都可以通过影子电梯来完成选择。除此之外，不对正在进行重置或者起始楼层时换成楼层顶点的电梯进行分配。</li></ol><p>事实上，影子电梯并不是性价比最高的选择，<strong>自由竞争</strong>（让电梯去抢人，谁先到谁先获得请求）实现更加简单，同时类似自然选择的策略让其效率并不低。但由于课程组通过receive输出禁止了电梯在未获得请求下的移动，自由竞争无法实现。</p><p>另一种仅次于以上两种方法的策略是<strong>随机数</strong>。看似无理，但效率也并没有低多少，而且实现更加简单<del>一行解决</del>。缺点是debug比较困难，很多bug没办法复现</p><p>最后就是课程组的标程——均匀分配。</p><h3 id="运行策略">运行策略</h3><p>采用<strong>look</strong>算法</p><p>look算法是生活中大多数电梯的运行策略，平均情况下效率较好，而且符合人性，具体实现如下（参考<ahref="http://hyggge.github.io/2022/04/29/oo/oo-di-er-dan-yuan-zong-jie/">Hyggge的博客</a>）：</p><ul><li><p>首先为电梯规定一个初始方向，然后电梯开始沿着该方向运动。</p></li><li><p>到达某楼层时，</p><p>首先判断是否需要开门</p><ul><li>如果发现电梯里有人可以出电梯（到达目的地），则开门让乘客出去；</li><li>如果发现该楼层中有人想上电梯，并且目的地方向和电梯方向相同，则开门让这个乘客进入。</li></ul></li><li><p>接下来，进一步判断电梯里是否有人</p><p>。如果电梯里还有人，则沿着当前方向移动到下一层。否则，检查请求队列中是否还有请求（目前其他楼层是否有乘客想要进电梯）——</p><ul><li>如果请求队列不为空，且某请求的发出地是电梯"前方"的某楼层，则电梯继续沿着原来的方向运动。</li><li>如果请求队列不为空，且所有请求的发出地都在电梯"后方"的楼层上，或者是在该楼层有请求但是这个请求的目的地在电梯后方（因为电梯不会开门接反方向的请求），则电梯掉头并进入"判断是否需要开门"的步骤（循环实现）。</li><li>如果请求队列为空，且输入线程没有结束（即没有输入文件结束符），则电梯停在该楼层等待请求输入（wait）。</li></ul></li></ul><p>当第一单元强测结束之后，我悲哀的发现look算法比另一种算法低了5分，这就是<strong>量子电梯</strong></p><p>量子电梯的名称来源于其“瞬移”的特性，即如果按逻辑分析，会发现电梯的移动通过瞬移实现，本质是一种hack评测的方法，现实生活中不可能实现（<del>所以是谁这么卷先想出来的</del>）</p><p>考虑如下输入，电梯开、关门时间均为0.2s，移动一层楼的时间是0.4s</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">1.0</span>]<span class="hljs-number">1</span>-FROM-<span class="hljs-number">1</span>-TO-<span class="hljs-number">6</span>-BY-<span class="hljs-number">2</span><br>[<span class="hljs-number">1.3</span>]<span class="hljs-number">2</span>-FROM-<span class="hljs-number">1</span>-TO-<span class="hljs-number">6</span>-BY-<span class="hljs-number">2</span><br>[<span class="hljs-number">1.6</span>]<span class="hljs-number">3</span>-FROM-<span class="hljs-number">1</span>-TO-<span class="hljs-number">6</span>-BY-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>look算法会在1.0秒时开门，进入两个乘客，1.4秒时关门，开始移动，并在1.8秒时输出信息表明已经到到下一楼层了，忽略1.6秒时的乘客请求。</p><p>但量子电梯不是。前1.4s与look算法相同，关门后电梯并不移动，而是先等待0.4秒，如果有乘客到来则输出开关门信息让乘客进入，否则等待结束后后瞬移到下一楼层并输出信息。</p><p>这样一来，量子电梯就能比look算法捎带更多的人，效率更高。</p><h2 id="评测机与bug">评测机与bug</h2><p>很幸运这一单元并没有在测试中出现bug，hack别人的数据大多由评测机跑出来</p><h3 id="bug与解决方法">bug与解决方法</h3><ol type="1"><li>死锁。考察死锁的发生原因，可以发现<strong>锁的嵌套使用</strong>是必要条件，因此在代码中尽量避免嵌套使用锁大概就可以避免死锁。</li><li>线程陷入等待无法唤醒。一定注意有wait就要有notify，而且对应同一个锁，而且notify一定是比wait后调用。</li><li>轮询。按课程组实现即可，当有输入时，输入线程去唤醒电梯线程而非电梯线程一直去查看有无请求。</li><li>性能问题。请看如下数据点（<del>真下头</del>），如果实现不当会将所有乘客分配到同一电梯，导致超时。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">2.0</span>]RESET-Elevator-<span class="hljs-number">1</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.0</span>]RESET-Elevator-<span class="hljs-number">2</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.0</span>]RESET-Elevator-<span class="hljs-number">3</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.0</span>]RESET-Elevator-<span class="hljs-number">4</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.0</span>]RESET-Elevator-<span class="hljs-number">5</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.0</span>]RESET-Elevator-<span class="hljs-number">6</span>-<span class="hljs-number">3</span>-<span class="hljs-number">0.6</span><br>[<span class="hljs-number">49.5</span>]<span class="hljs-number">1</span>-FROM-<span class="hljs-number">11</span>-TO-<span class="hljs-number">1</span><br>......(上一行换个乘客id重复<span class="hljs-number">63</span>次)<br></code></pre></td></tr></table></figure><h3 id="评测机">评测机</h3><p>和zx合作开发了评测机，我主要负责正确性检验，zx负责数据生成和多线程调用。</p><h4 id="正确性检验">正确性检验</h4><p>正确性检验采用模拟方式。首先读入输入，获得待处理的乘客信息。其次逐行分析输出，按输出顺序模拟6个电梯的状态，当出现不合法行为时返回报错。具体根据不同指令判断错误。架构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_input</span>(<span class="hljs-params">inputfile: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-comment">#以乘客id为key，返回包含时间、出发到达楼层信息的字典,同时检查输入格式</span><br>    <span class="hljs-keyword">return</span> waiters<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_output</span>(<span class="hljs-params">outputfile: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-comment">#返回列表，提取输出的关键信息如时间戳、指令等，同时检查输出格式</span><br>    <span class="hljs-keyword">return</span> actions<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">waiters, actions</span>):<br>    elevators=&#123;&#125;<span class="hljs-comment">#加入电梯进行模拟</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(actions)):<br>        <span class="hljs-keyword">match</span> action[<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;RESET_ACCEPT&#x27;</span>:<br>                <span class="hljs-comment">#检查，错误直接返回，正确则改变电梯对应状态</span><br></code></pre></td></tr></table></figure><h4 id="其他的心得">其他的心得</h4><p>正确性检验的编写要求对指导书较为熟悉，并能考虑全面，顾及到尽可能多的情况。在编写的过程中，我对细节的考虑也不断完善，反过来修复了作业中的部分bug。</p><p>搭建评测机过程中有不少bug需要处理，因而版本迭代次数较多，又因为是2人合写，终于促使我使用git进行版本管理和合作开发。第一次主动使用git，不得不说确实舒服，也积累了相关经验。</p><p>具体代码已经开源<ahref="https://github.com/solor-wind/BUAA_OO_TEST">https://github.com/solor-wind/BUAA_OO_TEST</a></p><h2 id="心声">心声</h2><p>写过的最烂的代码，真的，没有之一。</p><p>烂的原因有两个：</p><ol type="1"><li>各种函数回调、类与类之间的嵌套。为了解决无法结束、结束时没分配完乘客的问题，让电梯完成重置后再调用一遍调度器。这是最大的败笔</li><li>线程间的共享对象。要么锁不住，要么死锁。终究是临界区没有划分好，共享对象不够清晰明确。</li></ol><p>收获是在经历了无比艰难的代码编写和debug之后，终于入门了多线程。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/2024/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/03/18/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span><br />源码见 <ahref="https://github.com/solor-wind/BUAA_OO">https://github.com/solor-wind/BUAA_OO</a></p></blockquote><h2 id="题目概述">题目概述</h2><p>第一单元的主题是表达式括号展开，要求读入一个包含加、减、乘、乘方以及括号的表达式，输出恒等变形展开所有必要括号括号后的表达式。</p><ul><li>第一周：括号嵌套仅一层、单变量</li><li>第二周：新增表达式因子、自定义函数因子，允许多层嵌套</li><li>第三周：支持求导因子、函数定义时允许引用已定义函数。</li></ul><h2 id="量化分析">量化分析</h2><h3 id="代码量">代码量</h3><figure><img src="/img/OO/OO第一单元代码量.png" alt="OO第一单元代码量" /><figcaption aria-hidden="true">OO第一单元代码量</figcaption></figure><h3 id="复杂度">复杂度</h3><p><img src="/img/OO/OO第一单元类复杂度.png" alt="OO第一单元类复杂度" style="zoom: 80%;" /></p><p>可以发现Simplify类的复杂度严重超标，主要原因是表达式化简需要对各种情况进行特判，而且还加入了提取最大公因数和对输入预处理的功能，导致复杂度过高</p><figure><img src="/img/OO/OO第一单元方法复杂度.png"alt="OO第一单元方法复杂度" /><figcaption aria-hidden="true">OO第一单元方法复杂度</figcaption></figure><p>print_unit方法复杂度也严重超标，原因在于加入exp因子后，需要进行特判的情况增加，还要判断是否为表达式来化简括号，因此复杂度高。</p><h2 id="思路与架构">思路与架构</h2><p>先上类图</p><figure><img src="/img/OO/OO第一单元架构.png" alt="OO第一单元架构" /><figcaption aria-hidden="true">OO第一单元架构</figcaption></figure><p>其中，程序的主体是先存储自定义函数，然后调用lexer对输入表达式进行词法分析，接着用parse进行输入解析，解析完毕后调用toPoly方法运算、转化成统一形式，最后进一步化简输出。</p><p>解析部分采用<strong>递归下降</strong>（有点编译原理的感觉），分为表达式、项、因子三个层次。表达式解析调用项的解析方法，项再调用因子的解析方法，如果是表达式因子等特殊因子还可以再调用表达式解析方法直至解析完毕。主要因子均继承Factor接口，方便统一管理，内部属性与特点相对应。解析自定义函数调用时采用<strong>字符串递归替换</strong>的方法，具体实现在myFun类中。</p><p>计算方面采用<strong>标准项</strong>统一处理，建立Unit类作为HashMap的key，相同即可合并。表达式类、项类、每种因子类均实现了toPoly方法转化为<code>HashMap&lt;Unit,BigInteger&gt;</code>类型，便于运算、化简、输出。多项式加法、乘法、求导写成了静态方法放进Poly类中。类似的，预处理与化简方法也写成了静态方法放进Simplify类中。</p><h3 id="输入预处理">输入预处理</h3><p>这一部分较为简单，直接用正则表达式对字符串进行匹配替换即可，主要是去掉空白符和连续的正负号方便后续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">pre_process</span><span class="hljs-params">(String input)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> input.replaceAll(<span class="hljs-string">&quot;[ \t]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        output = output.replaceAll(<span class="hljs-string">&quot;\\+\\+&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;\\+-&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;-\\+&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>        output = output.replaceAll(<span class="hljs-string">&quot;--&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><p>替换完毕后，将自定义函数的函数名、指定的形参、函数体分别存放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-comment">//函数名-具体函数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//参数列表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//函数体</span><br></code></pre></td></tr></table></figure><h3 id="输入解析">输入解析</h3><p>首先使用lexer（词法分析器），逐个读入字符并分类为数字、变量、+-等符号，提供peek（返回当前的token，即遇到了什么）、next（读入下一个token）方法。</p><p>parser采用递归下降的方法，将表达式拆解为表达式、项、因子三层：</p><ul><li>表达式遇到加减号调用解析项的方法，将解析完的内容加到项容器中（容器中的元素是加减关系）</li><li>项遇到乘号调用解析因子的方法，将解析完的内容加到因子容器中（容器中的元素是相乘关系）。</li><li>解析因子的方法根据当前Token的不同，调用不同的解析方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Expr <span class="hljs-title function_">parseExpr</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">Expr</span> <span class="hljs-variable">expr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Expr</span>();<br>    expr.addTerm(sign, parseTerm());<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-keyword">return</span> expr;<br>&#125;<br><span class="hljs-keyword">public</span> Term <span class="hljs-title function_">parseTerm</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">Term</span> <span class="hljs-variable">term</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Term</span>();<br>    term.addFactor(parseFactor());<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-keyword">return</span> term;<br>&#125;<br><span class="hljs-keyword">public</span> Factor <span class="hljs-title function_">parseFactor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123; <span class="hljs-comment">//表达式因子</span><br>        <span class="hljs-keyword">return</span> parseExprFactor();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;exp&quot;</span>)) &#123; <span class="hljs-comment">//指数函数因子</span><br>        <span class="hljs-keyword">return</span> parseExpFactor();<br>    &#125; <span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义函数的解析">自定义函数的解析</h4><p>关于自定义函数因子，我并没有相应的因子类，而是通过字符串递归替换得到没有自定义函数的字符串，然后调用lexer、parser等方法去解析，再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">parseFun</span><span class="hljs-params">(Lexer lexer)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> lexer.peek();<span class="hljs-comment">//确定调用哪一个函数</span><br>    ArrayList&lt;String&gt; can = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//实参</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>            <span class="hljs-comment">/*...*/</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>            right++;<br>            <span class="hljs-keyword">if</span> (right == left) &#123;<br>                lexer.next();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lexer.peek().equals(<span class="hljs-string">&quot;(&quot;</span>)) &#123;<br>            left++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.containsKey(lexer.peek())) &#123;<br>            tmp.append(parseFun(lexer));<span class="hljs-comment">//递归替换</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        tmp.append(lexer.peek());<br>        lexer.next();<br>    &#125;<br>    tmp.append(<span class="hljs-string">&quot;)&quot;</span>);<br>    can.add(tmp.toString());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + MyFun.callFun(name, can) + <span class="hljs-string">&quot;)&quot;</span>;<span class="hljs-comment">//字符串替换函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表达式的存储">表达式的存储</h3><p>上面已经介绍过表达式、项的存储方法，现在介绍各类因子的存储</p><h4 id="常量幂函数因子">常量、幂函数因子</h4><p>常量和幂函数可以统一成 <span class="math inline">\(a\timesx^b\)</span> 的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger parameter;<span class="hljs-comment">//系数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="表达式因子">表达式因子</h4><p>内部用一个表达式类存储即可，再加上表达式括号后面的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExprFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Expr expr;<span class="hljs-comment">//表达式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指数函数因子">指数函数因子</h4><p>由于指数函数内部也是一个因子，因此用Factor来存储。虽然有种无限递归的感觉，但暂时没有出问题。同样还要存储后面跟的指数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> Factor factor;<span class="hljs-comment">//指数内的因子</span><br>    <span class="hljs-keyword">private</span> BigInteger exponent;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="求导因子">求导因子</h4><p>事实上极其简单，甚至最初我还将它直接归类到表达式因子。但事实上求导因子的toPoly方法要调用表达式类的toDelta方法，自身的toDelta方法要先调用表达式类的toDelta方法，再求导一次。而表达式因子只有toDelta方法会求导，且仅求一次导数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeltaFactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factor</span> &#123;<br>    <span class="hljs-keyword">private</span> Expr expr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表达式计算">表达式计算</h3><p>核心思想有两个，第一个还是<strong>递归调用</strong>，第二个是<strong>存算分离</strong>。</p><h4 id="总体结构1递归调用">总体结构1——递归调用</h4><p>这里的递归调用类似解析部分的递归下降法。</p><ul><li>表达式依次调用存储的项的 <code>toPoly</code>方法，获得结果后进行多项式加法并返回</li><li>项依次调用存储的因子的 <code>toPoly</code>方法，获得结果后进行多项式乘法并返回</li><li>因子实现 <code>toPoly</code>方法，如果内部存储有表达式，直接调用表达式的 <code>toPoly</code>方法再处理即可</li></ul><p>求导方法类似，但需要用到以下几个公式 <span class="math display">\[\begin{aligned}(a\times x^b\times e^c)&#39;&amp;=a\times b\times x^{b-1}\timese^c+a\times x^b\times e^c\times(c)&#39;\\[f(g(x))]&#39;&amp;=f&#39;(g(x))g&#39;(x)\\(\prod_i f_i)&#39;&amp;=\sum_if_i&#39;(\prod_{j\neq i}f_j)\\\sum f_i&amp;=\sum f_i&#39;\end{aligned}\]</span> 大体结构如上，但如何进行合并化简呢？</p><h4 id="总体结构2存算分离">总体结构2——存算分离</h4><p>存储时只存储相应因子的必要部分，计算时再化为统一的Unit或Poly类进行处理。</p><p>考察所有类别的因子，可以发现都能化成形如 <spanclass="math inline">\(a\times x^b\times \exp(c)\)</span>的基本项。因此，我决定采用Unit类来表示，并在存储的各类中添加toPoly方法转化成<code>HashMap&lt;Unit,BigInteger&gt; poly</code>来计算，<strong>Unit存储b和c，相同即可合并</strong></p><p><strong>注意以自建类作key时，一定要在类中重写equals和HashCode方法！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger exponent;<span class="hljs-comment">//指数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;Unit, BigInteger&gt; factor;<span class="hljs-comment">//因子</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Unit)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Unit</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Unit) o;<br>        <span class="hljs-keyword">return</span> other.exponent.equals(exponent)&amp;&amp;other.factor.equals(factor);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hash(exponent, factor.hashCode());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>系数a：Unit类中<strong>不存储系数</strong>，而是由各个因子中的toPoly方法将系数填写到<code>HashMap</code> 中的 <code>value</code> 中</li><li>指数b：存储在Unit的 <code>BigInteger exponent</code> 中</li><li>指数函数中的嵌套因子c：转化成多项式后，存储在Unit的<code>HashMap&lt;Unit,BigInteger&gt; factor</code> 中</li></ul><p>例如，2可以在计算过程中转化成多项式<code>HashMap&lt;Unit,BigInteger&gt; poly</code>，poly的大小为1，包含一个键值对，key为Unit，value为2。由于3为常数，所以Unit中指数项exponent为0，存储指数函数因子的factor为空。</p><p>又如，<span class="math inline">\(3\times x^6\times\exp(1+x^2)\)</span> 可以转化成多项式<code>HashMap&lt;Unit,BigInteger&gt; poly</code>，poly的大小为1，包含一个键值对，key为Unit，value为3。Unit里又存储了指数6和因子<span class="math inline">\(x^2+1\)</span> ，其中因子为<code>HashMap&lt;Unit,BigInteger&gt; factor</code>。factor的大小为2，有2个键值对，其中key1是Unit1，value1为1（代表1）;key2是Unit2，value2为1（代表<span class="math inline">\(x^2\)</span>）。Unit1中exponent为0，<strong>用factor为空代表 <spanclass="math inline">\(\exp(0)\)</span>​</strong>；Unit2中exponent为2，factor同样为空。</p><p>在IDEA中可以看到如下的展开式</p><figure><img src="/img/OO/表达式存储.png" alt="表达式存储" /><figcaption aria-hidden="true">表达式存储</figcaption></figure><p>根据如上的思路，我们可以在表达式类、项类和所有因子类中构建toPoly方法将表达式转化为统一形式</p><h4 id="性能优化与拓展性">性能优化与拓展性</h4><p>注意到在第二次作业中，有部分测试点进行了边界压力测试，如果采用的方法不当，极有可能出现MLE或TLE的情况，比如测试点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>(((((((((((x^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>关于MLE：在处理表达式因子或指数函数因子后的指数时，如果采用向相应容器（比如项类的容器）中存入指数个因子的方法，那么在应对上述情况时很有可能爆内存，而且计算时会进行递归调用，产生很多重复计算。</p><p>关于TLE：在计算表达式时，如果采用展开所有项（如 <spanclass="math inline">\((x+1)^2=x^2+x+x+1\)</span>​）的方法而不合并，则在应对较大数据时计算效率会大大下降，建议边计算边合并。</p><p>目前架构能做到 <code>(x+1)^1000</code>秒算，新增因子时，只需新建因子类、完善Unit类中的属性、修改Poly类中的加减法、添加输出方式即可，总体架构仍然可以保持不变</p><h3 id="结果化简">结果化简</h3><p>由于题面允许指数函数后接指数，即允许 <code>exp(2)^10</code>存在，于是可以用 <spanclass="math inline">\(\exp(a*x+b*y)=\exp(x)^a+\exp(y)^b\)</span>​这一公式进行任意优化。</p><p>但是，注意到以下几个例子：</p><ul><li><code>exp((10000+10000*x))=exp((1+x))^10000</code></li><li><code>exp((2*x))=exp(x)^2</code></li><li><code>exp((10+20*x+20*x^2))=exp((2+4*x+4*x^2))^5</code></li><li><code>exp((1+3*x))^2=exp((2+6*x))</code></li><li><code>exp((3*x+2*x^2+2*x^3+2*x^4+2*x^5))=exp(x)*exp((x+x^2+x^3+x^4+x^5))^2</code></li></ul><p>这说明无法单纯的提出来最大公因数来得到最优解，因为<strong>无法确定提出什么因数合适、是否要将因数合并进去</strong>。所以，我选择正确性优先，在保证正确性的基础上，寻找最大公因数并提取，并与最初的表达式的长短比较得出相对较短的字符串并输出。</p><h2 id="评测机与bug">评测机与bug</h2><p>和好友ZX共同完成了评测机。</p><h3 id="数据生成">数据生成</h3><h4 id="框架">框架</h4><p>采用python编写，具体框架即课程组给定的形式化表述。</p><ul><li>首先主函数调用生成自定义函数的函数（可选），然后根据指定的样例数调用表达式生成函数</li><li>表达式生成函数根据一定的概率调用一定数量的项生成函数，拼接成表达式</li><li>项生成函数根据一定的概率调用一定数量、一定种类的因子生成函数，拼接成项</li><li>常数、自变量因子直接返回，表达式因子、求导函数因子会递归调用表达式生成函数，指数函数因子会一定概率调用表达式生成函数</li></ul><p>具体的一些细节如空白符、正负号、前导0、指数的产生封装成小函数。</p><h4 id="功能">功能</h4><p>基本实现了所有类型样例的全覆盖，但缺点就是随机程度高，需要大量样例才能全覆盖。生成各种因子以及许多参数均可个性化调整，存储在json文件中，目前支持的参数主要有：测试样例数、是否自动生成自定义函数（或者自己指定函数）、括号嵌套层数上限、表达式中项数量的上限、项中因子数量的上限、产生各种因子的概率、空白符等多余内容的概率……</p><h3 id="正确性判定">正确性判定</h3><p>主要方法有两种——对拍与syms库</p><p>对拍采用讨论区JZY大佬的方法即可，两人分别跑一次数据，再用其中一个人跑一下刚才二人的结果的相减，若最终结果为0，则可以认为大概率没有问题</p><p>syms库即python中的库，这部分的实现主要由好友ZX完成，大致包括表达式结果的预处理（如dx替换为diff）、调用数据生成器和java并运行、结果比较与输出、超时跳过（Linux可选）。</p><h3 id="bugs">bugs</h3><p>很幸运第一单元的作业没有在强测、互测中发现bug，以下测试点均为互测中有效hack数据，主要通过评测机发现。</p><h4 id="section">1.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">4294967296</span><span class="hljs-comment">//系数/指数转化过程中使用了int</span><br></code></pre></td></tr></table></figure><h4 id="section-1">2.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>(<span class="hljs-number">1</span>+x+x^<span class="hljs-number">2</span>+x^<span class="hljs-number">3</span>)^<span class="hljs-number">6</span><span class="hljs-comment">//低性能压力测试1</span><br><br><span class="hljs-number">0</span><br>(((((((((((x^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span>)^<span class="hljs-number">8</span><span class="hljs-comment">//强测的压力测试...恐怖如斯</span><br><br><span class="hljs-number">0</span><br>exp((-x))<span class="hljs-comment">//应该原样输出，但很多人输出为exp(-x)，忽略了-x不是因子</span><br><br><span class="hljs-number">0</span><br>exp((exp((x-x))-exp((x-x))))<span class="hljs-comment">//有关0的处理</span><br></code></pre></td></tr></table></figure><h4 id="section-2">3.0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>dx(exp(exp(exp(exp(exp(exp(exp(exp(x^<span class="hljs-number">2</span>)))))))))<span class="hljs-comment">//性能测试/正确性测试</span><br></code></pre></td></tr></table></figure><h2 id="心声">心声</h2><p><del>开学第一天即王炸</del></p><p>相比上学期的OOpre，这周的作业可谓是疾如猛火。开学第一天即布置高强度作业，最终码量甚至逼近OOpre的总码量，而且思维难度更高，对架构、性能要求也更高。</p><p>第一周幸好有训练单元提供的架构，输入解析改一改即可，直接省了近一半的代码量。但剩下的部分任然不可小觑，借鉴了学长的博客后还是采用了自己的架构，简单省事，用<code>HashMap&lt;BigInteger,BigInteger&gt;</code>存储多项式，也为第二周的重构埋雷。</p><p>第二周比第一周更难，主要是指数函数因子的出现让我不得不思考如何存储才能在计算时快速合并。反复阅读学长博客后，我不得不承认学长的架构自有其道理，但其中的细节还需要自己思考、处理，比如以Unit作key。最终重构后的代码也在强测中取得了良好的表现，看来以后决不能偷偷省事，一定要预先思考需求、做好架构。</p><p>第三周由于第二周的良好架构，作业发布当晚就写完了，最终码量775/679（总行/非空行）。</p><p>总的来说，OO不失为一次涅槃，高强度的码量与高难度的作业迫使我们一次又一次的思考架构。第一单元的作业让我对递归下降的解析法理解更加深刻，同时对层次化设计的思想也有了一定的应用经验。</p>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OOpre总结</title>
    <link href="/2024/01/24/OOpre%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/24/OOpre%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="架构分析">架构分析</h4><h5 id="功能分析">功能分析</h5><p>Main:处理输入</p><p>Control:根据命令类型执行不同的命令，存储所有的冒险者、战斗日志（按月）</p><p>Adventure:执行冒险者的各种操作，存储雇佣的冒险者、药水瓶、装备、食物、战斗日志（按人）、背包</p><h5 id="继承关系">继承关系</h5><figure><img src="/img/image-20231104115232742.png"alt="image-20231104115232742" /><figcaption aria-hidden="true">image-20231104115232742</figcaption></figure><h5 id="几个特点">几个特点</h5><ol type="1"><li><p>control中相似操作用选择信号代替，减少代码重复</p><p>具体的，删除、加入、获取名字等方法一样，分别用1、2、3指代药水瓶、装备、食物；价值体接口中的<code>get_value</code>专门用来返回各个类特有的属性如药水瓶的容量、装备的星级、食物的能量等</p></li><li><p>除必需遍历输出的战斗日志外，全部采用HashMap、TreeSet，提高效率</p></li><li><p>输入只在Main中，其他方法传入字符串等参数，方便调试</p></li></ol><h5 id="架构变动">架构变动</h5><ul><li>最大的架构变动来自于P3到P4，原因是Main类里实在塞不下那么多类型的指令调用（代码风格过不去），因此把指令实现都放在了control类中，此后新增的操作分为switch1、switch2等等，<strong>嵌套调用</strong></li><li>其次要算新增了价值体，<strong>继承的使用</strong>大大简化了Adventrue类中存储结构的设计</li><li>最后一个小改动是战斗日志的处理，P6到P7的改动将这个处理更加清晰地分为2个方法</li></ul><h5 id="不足分析">不足分析</h5><ul><li>case数太多，寻找更优雅的解决多指令的方式</li><li>战斗日志的输入解读仍然不尽如人意，代码冗长、不优雅，看上去还是像屎山</li></ul><h4 id="junit的体会">Junit的体会</h4><h5 id="简单评价">简单评价</h5><p>个人角度来看，junit侧重于针对每个类或者方法单独测试，然而大部分的bug实际上来自于方法之间的调用、类与类之间的关系等等，因而<strong>对某一类、方法的测试</strong>可能局限于简单测试功能的完善性，而无法进行完全的测试。但如果通过对不同情况的仔细考虑造出强数据点并<strong>在类似顶层类（如control）中进行测试</strong>，则既可以测试每一方法、类，又能测试类与类、方法与方法间的调用关系，更加完备。</p><h5 id="使用体验">使用体验</h5><ul><li>assert的使用确实可以减少自己一个一个对数据点的烦恼。</li><li>在每次迭代后，都需要花费很多时间精心设计覆盖率足够高的数据点，看似很不划算，但真的是检验程序的一种绝佳方法（我自己在测试时经常出现程序崩溃的情况，输出错误反而很少。。。），确保提交的程序至少能够成功执行某些情况下的全部指令。</li></ul><h4 id="oopre的体会">OOpre的体会</h4><h5 id="面向对象编程">面向对象编程</h5><p>其实从C++和java对比来看更为明显，C++虽然也有类、支持继承、重载等等，但并没有显式的推荐一个类单独写一个文件（<del>自己都快把类当有函数的结构体用了</del>），还是容易造成”一main到底“的情况。而在OOpre中，由于java中的主体是类，真的需要<strong>认真考虑每个类到底有什么属性、功能</strong>，从而认真设计，相当于迫使程序员面向对象编程。</p><h5 id="框架">框架</h5><p>OOpre中，每次迭代都要根据新增的数据类型与指令要求设计新的存储、调用方法，因而程序的框架就十分重要。另一方面，代码量的显著增加也要求每次设计必须预先规划，而不能边写边想边改。</p><p>比如针对冒险者的操作大多根据id进行，因此可以用HashMap进行存储。但后续增加通过名字查询的功能时，又不得不增加一个名字-id的HashMap也是无奈之举。</p><p>又如类与类之间的联系、分工也应在开始编写之前考虑清楚，具体框架见前述。</p><h5 id="代码风格">代码风格</h5><p>统一化的代码风格这一要求其实还是容易理解的，但是还是有一些要求令我在编写时绷不住，只能尽量靠近要求</p><ul><li>每行不得超过100字符。从前写C时每行很难超过50字符，但由于java中相互调用太多，因此一行中很容易因为各种方法的嵌套调用而超过100字符。（<del>其实也说明代码结构不够简洁</del>）</li><li>每个方法不得超过60行。这一条与上面一条结合，直接促成了我P3到P4的架构大改。</li><li>变量命名必须使用小驼峰。主要是和我之前已经习惯的下划线的命名方式冲突，改起来比较费劲。</li></ul><h4 id="课程建议">课程建议</h4><ol type="1"><li>第一次作业相关环境的配置、java语法的介绍太少太乱，太难上手，而且各种说明放在一个文件夹里，每个说明还只解决半个问题。比如git和idea的下载完全可以分成两个文件，git的下载、配置、使用说明等等和gitlab的配置完全可以放在一起，一步到位。又比如《公测文档》、《建议得分说明》、《其他说明》互有重叠，想查找相关说明时无法根据文件名查找，还得逐一查看。</li><li>既然没有互测，可不可以把强测结果开放时间、bug修复时间提前？（进一步的，考虑提前开放下一次作业？）</li></ol>]]></content>
    
    
    <categories>
      
      <category>OO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P7设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P7建议：先理解异常的处理过程，明确需要硬件完成是哪一部分，然后逐步搭建。（异常的处理和系统桥感觉相对独立？）</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h2 id="设计要求架构与需求">设计要求、架构与需求</h2><h3 id="设计要求">设计要求</h3><p>处理器应为五级流水线设计，支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mfc0,mtc0,eret,syscall</span><br></code></pre></td></tr></table></figure><p>其他详见“P7提交要求”</p><h3 id="任务需求">任务需求</h3><p>说实话，P7的教程给出了大致框架，但很多地方的细节并未给出，或者分散在不同地方（不同章节、SMRL、设计文档等），难以明确需求与任务要求，从而导致实现困难，下面是个人的总结。</p><h4 id="术语的明确">术语的明确</h4><ul><li>内部异常：指由于执行指令引发的异常，如算术溢出、地址未对齐等等</li><li>外部中断：指外部引发的中断，如计时器、tb给出的中断信号等等</li><li>异常/中断：以上两类事件的统称</li></ul><h4 id="任务">任务</h4><h5 id="核心任务实现异常的处理">核心任务：实现异常的处理</h5><h6 id="处理步骤">处理步骤</h6><ol type="1"><li>根据当前CP0的SR状态、内部异常exc信号、外部中断HWint信号判断是否中断</li><li>把宏观PC写入EPC（注意延迟槽指令），异常信息写入CP0的Cause寄存器，SR相应位置1进入内核态（处理中断过程中禁止嵌套中断）</li><li>将PC调整到0x4180，清空宏观PC及之前的流水线寄存器</li><li>执行异常处理程序（处理异常、响应中断、回到原来指令等操作都交给软件实现）</li></ol><h6 id="具体实现">具体实现</h6><ul><li>每一级新增异常判断，流水异常信号——对应步骤1</li><li>每一级新增中断信号，进行清空操作——对应步骤2</li><li>每一级针对新增的指令进行修改（要结合CP0的设计一起进行），完成阻塞和转发的修改——对应步骤4</li><li>CP0的实现，包括接受内部异常与外部中断信号、给出中断信号、实现对三个寄存器的写入与读出。</li></ul><h6 id="一些细节">一些细节</h6><ul><li>CP0位置：我选择在E级，此时已经可以判断出所有类型，并且不会对乘除模块的寄存器、DM与外设、寄存器堆进行写入，同时可以参考乘除模块进行转发与阻塞的处理</li><li>延迟槽的判断：直接引入M级指令，若M为跳转，则判断为延迟槽</li><li>优先级：复位信号&gt;外部中断&gt;内部异常，这体现在Cause寄存器写入等方面</li><li><code>HWint=&#123;3'b0,interrupt,timer0,timer1&#125;</code>（看了学长的博客才知道，根本没有6个中断）</li></ul><h5id="附属任务将cpu封装为单周期实现与外设沟通的系统桥">附属任务：将CPU封装为单周期，实现与外设沟通的系统桥</h5><h6 id="封装为单周期">封装为单周期</h6><p>考察CPU的功能，主要有以下几点：</p><ul><li>执行指令进行计算——需要IM接口(提供pc，获取指令)</li><li>与外设进行读、写操作——需要DM等接口(提供addr、写入数据，获取读出数据)</li><li>获取外部中断信号——2个timer和tb的中断</li><li>老2样——clk与reset</li><li>课程组检查寄存器的入口——寄存器堆相关信号</li></ul><h6 id="系统桥">系统桥</h6><p>考察系统桥的功能，就是根据M级指令、地址、数据，向外设提供相应的写使能信号、写入数据，同时对来自外设的数据进行选择。因此，接口应该能实现以上功能。</p><h3 id="架构">架构</h3><figure><img src="/img/微系统架构.png" alt="微系统架构.png" /><figcaption aria-hidden="true">微系统架构.png</figcaption></figure><h2 id="模块规格">模块规格</h2><h3 id="命名规则">命名规则</h3><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能_去向</code> 命名。</p><h3 id="cpu">CPU</h3><h4 id="封装">封装</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">reset</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">int_export</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">外部中断信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">int_timer0</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟中断信号0</td><td style="text-align: center;">Timer0</td></tr><tr class="odd"><td style="text-align: center;">int_timer1</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟中断信号1</td><td style="text-align: center;">Timer1</td></tr><tr class="even"><td style="text-align: center;">macroscopic_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">宏观pc</td><td style="text-align: center;">EX/tb</td></tr><tr class="odd"><td style="text-align: center;">i_inst_rdata</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IM的指令</td><td style="text-align: center;">IF_instr</td></tr><tr class="even"><td style="text-align: center;">i_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF的pc</td><td style="text-align: center;">IF_pc</td></tr><tr class="odd"><td style="text-align: center;">w_grf_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">w_grf_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">w_grf_wdata</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">w_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">WB</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">m_inst_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级pc</td><td style="text-align: center;">EX_pc_MEM/bridge</td></tr><tr class="even"><td style="text-align: center;">out_instr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的指令</td><td style="text-align: center;">EX_instr_MEM/bridge</td></tr><tr class="odd"><td style="text-align: center;">out_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的地址</td><td style="text-align: center;">EX_out/bridge</td></tr><tr class="even"><td style="text-align: center;">out_WD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入外设的数据</td><td style="text-align: center;">EX_rt_MEM或W级转发</td></tr><tr class="odd"><td style="text-align: center;">out_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从外设读取的数据</td><td style="text-align: center;">MEM_data</td></tr></tbody></table><h4 id="模块共有信号">模块共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级（IF为out）</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，跳至0x4180</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="odd"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="even"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从tb获取的指令</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">IF_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF级当前指令</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">IF_exc_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">内部异常信号</td><td style="text-align: center;">ID</td></tr></tbody></table><h4 id="id">ID</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，清空D级</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="odd"><td style="text-align: center;">EPC</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">CP0的EPC</td><td style="text-align: center;">EX_rt(转发)、CP0</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF的异常信号</td><td style="text-align: center;">IF</td></tr><tr class="even"><td style="text-align: center;">ID_exc_EX</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">给EX的异常信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量与操作">内部变量与操作</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">req</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号，清空本级</td><td style="text-align: center;">CP0</td></tr><tr class="even"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="odd"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">EX_CP0</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从CP0读取的值</td><td style="text-align: center;">CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从ID流水下来的内部异常信号</td><td style="text-align: center;">ID</td></tr><tr class="even"><td style="text-align: center;">EX_exc_CP0</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给CP0的内部异常信号</td><td style="text-align: center;">CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示E级产生了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">EX_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">E级产生新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">mul是否正忙</td><td style="text-align: center;">mul</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;<span class="hljs-comment">//即时给出运算结果，上升沿时赋给EX_out</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_tmp_new;<span class="hljs-comment">//同上，EX_new</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] EX_tmp_addr;<span class="hljs-comment">//EX_addr</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] start;<span class="hljs-comment">//从E级指令给出mul所需信号,req时为0</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] hi;<span class="hljs-comment">//</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] lo;<br></code></pre></td></tr></table></figure><h5 id="内部模块mul">内部模块——mul</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">start</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">开始运算信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rs</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">B</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rt</td><td style="text-align: center;">EX_rt_use</td></tr><tr class="even"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">正忙信号</td><td style="text-align: center;">busy</td></tr><tr class="odd"><td style="text-align: center;">hi</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法高位/除法余数</td><td style="text-align: center;">out</td></tr><tr class="even"><td style="text-align: center;">lo</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法低位/除法的商</td><td style="text-align: center;">out</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要读出的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">读出的数据</td><td style="text-align: center;">bridge</td></tr><tr class="odd"><td style="text-align: center;">MEM_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示M级有了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">MEM_new_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">M级新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传向下一级的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op;<span class="hljs-comment">//位扩展选择信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data_out;<span class="hljs-comment">//原始读出数据</span><br></code></pre></td></tr></table></figure><h5 id="内部模块ext">内部模块——ext</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">A</td><td style="text-align: center;">读出地址的低位</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">Din</td><td style="text-align: center;">in</td><td style="text-align: center;">Din</td><td style="text-align: center;">原始数据</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">Op</td><td style="text-align: center;">in</td><td style="text-align: center;">Op</td><td style="text-align: center;">扩展选择信号</td><td style="text-align: center;">op</td></tr><tr class="even"><td style="text-align: center;">Dout</td><td style="text-align: center;">out</td><td style="text-align: center;">Dout</td><td style="text-align: center;">扩展后的数据</td><td style="text-align: center;">MEM_data_WB</td></tr></tbody></table><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h4 id="cp0">CP0</h4><p>位于E级，此时已经可以判断出所有异常类型，而且不会写入乘除模块、DM以及寄存器</p><p>通过E级指令来写入/读出相应寄存器，读出/写入的值与E级其他指令一样流水</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">HWint</td><td style="text-align: center;">in</td><td style="text-align: center;">[5:0]</td><td style="text-align: center;">输入中断信号</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">exc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">异常类型</td><td style="text-align: center;">EX_exc_CP0</td></tr><tr class="odd"><td style="text-align: center;">EX_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">E级pc</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">EX_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">E级指令</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">MEM_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级指令，判断延迟槽</td><td style="text-align: center;">EX_instr_MEM</td></tr><tr class="even"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入CP0的数据</td><td style="text-align: center;">EX_rt</td></tr><tr class="odd"><td style="text-align: center;">CP0_rd</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从CP0读出的数据</td><td style="text-align: center;">EX_CP0</td></tr><tr class="even"><td style="text-align: center;">EPC</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">EPC</td><td style="text-align: center;">IF</td></tr><tr class="odd"><td style="text-align: center;">Req</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">中断信号</td><td style="text-align: center;">好多</td></tr></tbody></table><h5 id="寄存器对应位的功能">寄存器对应位的功能</h5><p>其中，SR编号12，Cause编号13，EPC编号14</p><table><thead><tr class="header"><th style="text-align: center;">寄存器</th><th style="text-align: center;">功能域</th><th style="text-align: center;">位域</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">IM（Interrupt Mask）</td><td style="text-align: center;">15:10</td><td style="text-align: center;">分别对应六个外部中断，相应位置 1表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过<code>mtc0</code>这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr class="even"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">EXL（Exception Level）</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr class="odd"><td style="text-align: center;">SR（State Register）</td><td style="text-align: center;">IE（Interrupt Enable）</td><td style="text-align: center;">0</td><td style="text-align: center;">全局中断使能，该位置 1 表示允许中断，置0 表示禁止中断。</td></tr><tr class="even"><td style="text-align: center;">Cause</td><td style="text-align: center;">BD（Branch Delay）</td><td style="text-align: center;">31</td><td style="text-align: center;">当该位置 1 的时候，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr class="odd"><td style="text-align: center;">Cause</td><td style="text-align: center;">IP（Interrupt Pending）</td><td style="text-align: center;">15:10</td><td style="text-align: center;">为 6 位待决的中断位，分别对应 6个外部中断，相应位置 1 表示有中断，置 0表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr class="even"><td style="text-align: center;">Cause</td><td style="text-align: center;">ExcCode</td><td style="text-align: center;">6:2</td><tdstyle="text-align: center;">异常编码，记录当前发生的是什么异常。</td></tr><tr class="odd"><td style="text-align: center;">EPC</td><td style="text-align: center;">-</td><td style="text-align: center;">-</td><td style="text-align: center;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><h5 id="异常码">异常码</h5><table><thead><tr class="header"><th style="text-align: left;">异常与中断码</th><th style="text-align: left;">助记符与名称</th><th style="text-align: left;">指令与指令类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;"><code>Int</code> （外部中断）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">中断请求，来源于计时器与外部中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;"><code>AdEL</code> （取指异常）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">PC 地址未字对齐。</td></tr><tr class="odd"><td style="text-align: left;">PC 地址超过<code>0x3000 ~ 0x6ffc</code>。</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>AdEL</code> （取数异常）</td><td style="text-align: left;"><code>lw</code></td><td style="text-align: left;">取数地址未与 4 字节对齐。</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>lh</code></td><td style="text-align: left;">取数地址未与 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>lh</code>, <code>lb</code></td><td style="text-align: left;">取 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">计算地址时加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">取数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;"><code>AdES</code> （存数异常）</td><td style="text-align: left;"><code>sw</code></td><td style="text-align: left;">存数地址未 4 字节对齐。</td></tr><tr class="even"><td style="text-align: left;"><code>sh</code></td><td style="text-align: left;">存数地址未 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>sh</code>, <code>sb</code></td><td style="text-align: left;">存 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">计算地址加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">向计时器的 Count 寄存器存值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">存数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">8</td><td style="text-align: left;"><code>Syscall</code> （系统调用）</td><td style="text-align: left;"><code>syscall</code></td><td style="text-align: left;">系统调用。</td></tr><tr class="even"><td style="text-align: left;">10</td><td style="text-align: left;"><code>RI</code>（未知指令）</td><td style="text-align: left;">-</td><td style="text-align: left;">未知的指令码。</td></tr><tr class="odd"><td style="text-align: left;">12</td><td style="text-align: left;"><code>Ov</code>（溢出异常）</td><td style="text-align: left;"><code>add</code>, <code>addi</code>,<code>sub</code></td><td style="text-align: left;">算术溢出。</td></tr></tbody></table><h3 id="bridge">Bridge</h3><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级指令</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级要读/写的地址</td><td style="text-align: center;">CPU</td></tr><tr class="odd"><td style="text-align: center;">MEM_WD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">M级要写入的数据</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">MEM_RD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给M的从外设读取的数据</td><td style="text-align: center;">CPU</td></tr><tr class="odd"><td style="text-align: center;">WD</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传给外设的写入的数据</td><td style="text-align: center;">CPU</td></tr><tr class="even"><td style="text-align: center;">DM_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从DM读出的数据</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">m_data_byteen</td><td style="text-align: center;">out</td><td style="text-align: center;">[3:0]</td><td style="text-align: center;">DM写使能</td><td style="text-align: center;">tb</td></tr><tr class="even"><td style="text-align: center;">m_int_byteen</td><td style="text-align: center;">out</td><td style="text-align: center;">[3:0]</td><td style="text-align: center;">外部中断写使能</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">Timer0_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">Timer0读出的数据</td><td style="text-align: center;">Timer0</td></tr><tr class="even"><td style="text-align: center;">Timer0_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">Timer0写使能</td><td style="text-align: center;">Timer0</td></tr><tr class="odd"><td style="text-align: center;">Timer1_RD</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">Timer1读出的数据</td><td style="text-align: center;">Timer1</td></tr><tr class="even"><td style="text-align: center;">Timer1_we</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">Timer1写使能</td><td style="text-align: center;">Timer1</td></tr></tbody></table><p>主要功能：根据从M级的指令、地址、数据，给出相应的读写信号、写入数据的预处理、读出数据的选择</p><h3 id="timer">Timer</h3><h2 id="冒险处理">冒险处理</h2><p>新增了E级到D级的转发（eret）</p><p>mfc0采用之前的转发就好</p><p>mtc0采用之前的转发就好</p><h4 id="转发">转发</h4><p>转发共5个接受：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rs_base;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] MEM_data;<br></code></pre></td></tr></table></figure><p>共2处提供：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WB_data_ID;<br></code></pre></td></tr></table></figure><p>其中，2处提供接口还给出new信号与addr，代表新值产生且可用、要写入的寄存器编号</p><p>接受者只需判断new与addr即可决定转发与否（有新值且可用就转发）</p><h4 id="阻塞">阻塞</h4><p><span class="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算见表格</p><p>采用Time模块传递计算结果，<code>[31:0] use_new</code>具体每位对应结果如下表</p><p>[2][1][0]分别对应rs、rt、rd</p><table><thead><tr class="header"><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">rd</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[0]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-&gt;</td><td style="text-align: center;">use或new的数值</td><td style="text-align: center;">&lt;-</td><td style="text-align: center;">1代表正在算乘除法</td><td style="text-align: center;">-&gt;</td><td style="text-align: center;">0为use，1为new</td><td style="text-align: center;">&lt;-</td></tr></tbody></table><p>若 <span class="math inline">\(T_{use}&lt;T_{new}\)</span>，或乘除类指令遇上busy，则执行阻塞操作：</p><ol type="1"><li>冻结IF/ID</li><li>清除ID/EX</li><li>禁止PC</li></ol><h4 id="注意事项">注意事项</h4><ul><li>从W级转发到D级，采用D级内部转发（如beq）</li><li>转发时如果地址是0寄存器应剔除</li></ul><h2 id="添加指令">添加指令</h2><ol type="1"><li><p>添加到const、IF已有指令里</p></li><li><p>填写TIME表格，根据use和new更改M级中的MEM_new与MEM_new_addr，添加Time中的use与new值</p></li><li><p>根据操作在每个模块添加行为</p><ul><li>IF：指令获取与延迟槽、未知指令与取指异常</li><li>ID：给出跳转指令</li><li>EX：各种计算行为、存储地址计算</li><li>MEM：给出写入内存的地址、转发信号、对读出的数据进行加工</li><li>WB：给出写寄存器信号、寄存器编号、数据</li><li>Bridge：sw类指令给出使能信号判断</li></ul></li><li><p>每类指令对应行为（P5）</p><ul><li>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</li><li>lw：修改EX计算过程、添加WB回写信号，……</li><li>sw：修改EX计算过程、Bridge使能判断、MEM写入，………</li><li>j：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</li><li>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</li></ul></li><li><p>是否有新的转发通路、阻塞可能</p></li></ol><h2 id="思考bug与测试">思考、bug与测试</h2><h4 id="思考题">思考题</h4><ol type="1"><li><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>当键盘、鼠标有输入时（状态更新或其他），向CPU发出中断信号，CPU接到中断信号后判断中断种类，并执行相应区域代码，完成输入信号的读取。其中，输入信号需要驱动程序的解读。</p></li><li><p>请思考为什么我们的 CPU处理中断异常必须是已经指定好的地址？如果你的 CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>必须是已经指定好的地址。处理中断异常程序的目的是维护系统、程序的正常运行，并返回错误信息。如果地址由用户自定义，可能地址无效产生新的异常、或处理程序也产生新的异常等，达不到目的。</p></li><li><p>为何与外设通信需要 Bridge？</p><p>外设种类很多而CPU指令集有限，因此要把外设的接口和CPU的接口通过系统桥连接起来，通过统一的方式，由系统桥选择相关信息的输入输出。</p></li><li><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并针对每一种模式绘制状态移图。</p><figure><img src="/img/计时器状态转换图.jpg" alt="计时器状态转换图" /><figcaption aria-hidden="true">计时器状态转换图</figcaption></figure><p>state的状态转换其实 一样，区别在于从INT到IDLE这一步。</p><p>模式0将ctrl[0]置0，IRQ仍然为1，让state在IDLE卡死</p><p>模式1将IRQ置0，ctrl[0]仍然为1，让state能继续由IDLE到LOAD，顺便在这一过程中把IRQ置0，实现循环</p></li><li><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>EPC会存入0，跳转回正常指令的时候出错。pc、错误信息</p></li><li><p>为什么 <code>jalr</code> 指令为什么不能写成<code>jalr $31, $31</code>？</p><p>根据MARS的行为，jalr两个寄存器相同会导致先写入当前pc+4，再从寄存器取数跳转，实际上达不到跳转到$31的目的</p></li><li><p>[P7 选做] 请详细描述你的测试方案及测试数据构造策略。</p><p>详见“测试部分”</p></li></ol><h4 id="写p7遇到的bug">写P7遇到的bug</h4><p>eret的跳转值要接受来自mtc0(E级)的转发，还要判断地址是不是EPC</p><p>ID在中断时写寄存器操作不能停(相当于W级)</p><p>未知指令少打了个sb、mtc0的指令编码敲错了</p><p>计数器之间的地址不连续</p><p>外部异常比内部异常优先写入Cause</p><p>stall和req时应当保持pc</p><p>判断溢出的实现有误，应严格按MARS文档来</p><p>不管跳转指令是否跳转，其后的延迟槽指令都必须携带BD标记</p><p>写入外设的数据和DM提前准备好的冲突</p><p>应流水延迟槽标记，而非通过M级判断</p><p>阻塞、中断的时候没管BD</p><p>测测延迟槽阻塞、中断（已测）</p><p>外部中断的时候，BD需要置1吗——需要</p><p>SR的IP要每周期修改一次</p><p>mtc0和mfc0如果超出12-14怎么办——不用管</p><p>何时复位EXL——eret到CP0的下一上升沿</p><p>取值异常或RI后视为nop提交至CP0</p><p>未知指令判断时，mtc0？、</p><p>在延迟槽中断后，修改pc使得在延迟槽重新执行，BD需要置1吗？——不需要</p><p>eret处中断怎么办——不会出现tb中断</p><p>从中断发生器（不是计时器）读出的数据应该保持0</p><p>CP0部分位是只读，未使用的位应当保持为0！！！</p><p>通过sw相应一些中断时，阻塞阻塞再eret？、</p><p>mtc0、mfc0的rt和rd不要混！！！</p><p>D/E流水线寄存器在阻塞的时候应当流水上一级pc和BD！！！</p><p>好奇：课程组到底是怎么测试时钟中断的？</p><p>优化：lui提前至D级实现、取消对0寄存器的阻塞</p><h4 id="测试部分">测试部分</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">2</span>)s<br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">12</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">3</span>,<span class="hljs-number">6</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sb</span> $<span class="hljs-number">4</span>,<span class="hljs-number">11</span>($<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2p5冒险测试">part2——p5冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><h5 id="part3p6新增指令测试">part3——p6新增指令测试</h5><p>重点测试边缘数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> $<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">or</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">slt</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">sltu</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">5</span>,$<span class="hljs-number">6</span><br><span class="hljs-attribute">addi</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">9</span>,-<span class="hljs-number">1</span><br><span class="hljs-attribute">andi</span> $<span class="hljs-number">10</span>,$<span class="hljs-number">10</span>,-<span class="hljs-number">1</span><br><span class="hljs-attribute">sb</span> $<span class="hljs-number">11</span>,-<span class="hljs-number">1</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">11</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">12</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lui</span> $<span class="hljs-number">11</span> <span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span> <span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">11</span>,<span class="hljs-number">2</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lb</span> $<span class="hljs-number">13</span>,<span class="hljs-number">3</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lh</span> $<span class="hljs-number">14</span>,<span class="hljs-number">2</span>($<span class="hljs-number">4</span>)<br><br><span class="hljs-attribute">mult</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">15</span><br><span class="hljs-attribute">multu</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">16</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">17</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">18</span><br><span class="hljs-attribute">mthi</span> $<span class="hljs-number">19</span><br><span class="hljs-attribute">mtlo</span> $<span class="hljs-number">20</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">20</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">20</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">bne</span> $<span class="hljs-number">19</span>,$<span class="hljs-number">21</span>,loop<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">21</span>,$<span class="hljs-number">21</span>,$<span class="hljs-number">20</span><br><span class="hljs-attribute">nop</span><br><span class="hljs-comment">#重点测试符号乘除</span><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>x1111<br><span class="hljs-attribute">add</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">0</span><br><span class="hljs-attribute">mult</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">4</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">5</span><br><span class="hljs-attribute">multu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">6</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">7</span><br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">13</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">9</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">10</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">11</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">12</span><br><span class="hljs-attribute">div</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">13</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">14</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">8</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">15</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">16</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">8</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">mfhi</span> $<span class="hljs-number">17</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">18</span><br><span class="hljs-attribute">divu</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">19</span><br><span class="hljs-attribute">mflo</span> $<span class="hljs-number">20</span><br><br></code></pre></td></tr></table></figure><h5 id="part4p7中断异常测试">part4——p7中断异常测试</h5><p>异常全覆盖</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1c01</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><br><br><span class="hljs-comment">#pc地址未对齐</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">0x300a</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-number">2</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><span class="hljs-comment">#顺便延迟槽</span><br><span class="hljs-comment">#pc地址超范围</span><br><span class="hljs-keyword">jr </span>$<span class="hljs-number">2</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">0x0003</span><br><br><span class="hljs-comment">#lw、lh没有字对齐</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br><span class="hljs-keyword">lh </span>$<span class="hljs-number">2</span>,<span class="hljs-number">1</span>($<span class="hljs-number">0</span>)<br><span class="hljs-comment">#lh、lb取Timer寄存器的值</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">0x7f00</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#应该没错</span><br><span class="hljs-keyword">lh </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<br><span class="hljs-keyword">lb </span>$<span class="hljs-number">5</span>,<span class="hljs-number">20</span>($<span class="hljs-number">4</span>)<br><span class="hljs-comment">#计算地址加法溢出</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">1</span>($<span class="hljs-number">6</span>)<br><span class="hljs-comment">#取数地址超出范围</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0x7f0c</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">#sw、sh没有字对齐</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br><span class="hljs-keyword">sh </span>$<span class="hljs-number">2</span>,<span class="hljs-number">1</span>($<span class="hljs-number">0</span>)<br><span class="hljs-comment">#sh、sb取Timer寄存器的值</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#应该没错</span><br><span class="hljs-keyword">sh </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">4</span>)<br><span class="hljs-keyword">sb </span>$<span class="hljs-number">5</span>,<span class="hljs-number">20</span>($<span class="hljs-number">4</span>)<br><span class="hljs-comment">#计算地址加法溢出</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">65535</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">1</span>($<span class="hljs-number">6</span>)<br><span class="hljs-comment">#向计时器Count寄存器存值</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">7</span>)<br><span class="hljs-comment">#存数地址超出范围</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">7</span>,<span class="hljs-number">100</span>($<span class="hljs-number">7</span>)<br><br><span class="hljs-comment">#syscall</span><br><span class="hljs-keyword">syscall</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">#RI</span><br><span class="hljs-keyword">nor </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,$<span class="hljs-number">4</span><br><br><span class="hljs-comment">#算术溢出</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">8</span>,$<span class="hljs-number">6</span><span class="hljs-comment">#不应溢出</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">6</span>,$<span class="hljs-number">8</span><span class="hljs-comment">#溢出</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">6</span>,$<span class="hljs-number">7</span><span class="hljs-comment">#溢出</span><br><span class="hljs-keyword">sub </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">0</span>,$<span class="hljs-number">6</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-number">9</span>,$<span class="hljs-number">9</span>,-<span class="hljs-number">100</span><span class="hljs-comment">#溢出</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span>,end<span class="hljs-comment">#死循环</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">#异常处理程序</span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">12</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">13</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-built_in">k0</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">eret</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><span class="hljs-comment">#应当没有延迟槽</span><br></code></pre></td></tr></table></figure><p>中断、异常、阻塞、延迟槽交错，限制部分中断</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1c01</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><br><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">2</span>,<span class="hljs-number">0x7fff</span><br><span class="hljs-keyword">lui </span>$<span class="hljs-number">3</span>,<span class="hljs-number">0x7fff</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">3</span>,end<br><span class="hljs-keyword">add </span>$<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,$<span class="hljs-number">3</span><span class="hljs-comment">#延迟槽指令出错。可在此处加入外部中断，断2次</span><br><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<span class="hljs-comment">#阻塞的时候来点外部中断</span><br><span class="hljs-keyword">bne </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">4</span>,end<span class="hljs-comment">#此处需要更改机器码让beq出错</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">1</span><br><br><span class="hljs-comment">#时钟中断</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">5</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">9</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">8</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">6</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">0x7f00</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">4</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><span class="hljs-comment">#啥时候中断我也搞不清……</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><br><span class="hljs-keyword">and </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">0</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">1</span>,<span class="hljs-number">0x1001</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-number">1</span>,$<span class="hljs-number">12</span><span class="hljs-comment">#不许时钟中断了</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-number">8</span>,<span class="hljs-number">4</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">sw </span>$<span class="hljs-number">5</span>,<span class="hljs-number">0</span>($<span class="hljs-number">6</span>)<br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><span class="hljs-comment">#啥时候中断我也搞不清……</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-keyword">add </span>$<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,$<span class="hljs-number">5</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br><span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>,$<span class="hljs-number">0</span>,end<span class="hljs-comment">#死循环</span><br><span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br><br><span class="hljs-comment">#异常处理程序</span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">12</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">13</span><br><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x7c</span><br><span class="hljs-keyword">and </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k1</span><br><span class="hljs-keyword">bne </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">0</span>,WTF<br>    <span class="hljs-keyword">sb </span>$<span class="hljs-number">0</span>, <span class="hljs-number">0x7f20</span>($<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">0</span>, <span class="hljs-number">0x7f00</span>($<span class="hljs-number">0</span>)<br><span class="hljs-symbol">WTF:</span><br><span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-built_in">k0</span>,<span class="hljs-number">4</span><br><span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>,$<span class="hljs-number">14</span><br><span class="hljs-keyword">eret</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P6设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P6%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P6%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P6建议：在P5基础上添加乘除槽即可</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h3 id="设计要求">设计要求</h3><p>处理器应为五级流水线设计，支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>直接通过顶层模块 mips.v 的 output 端口传出相应信号，不允许出现<code>display</code> 语句，具体要求见“在线测试相关说明”小节。</p></li><li><p>要求存储器外置，即将 IM 和 DM 放置在 CPU 之外。P6 的 IM 和 DM两个模块被内置于官方评测的 testbench 中（官方使用的 tb已在“存储器外置”小节公开），<strong>不再需要</strong>大家自行实现 IM 和DM 模块。官方 tb 中实现的指令存储器（IM，instructionmemory）和数据存储器（DM，data memory）的容量如下：</p><ul><li><p>IM：容量为 <strong>16KB</strong> (32bit/word ×<strong>4096word</strong>)</p></li><li><p>DM：容量为 <strong>12KB</strong> (32bit/word ×<strong>3072word</strong>)</p></li></ul></li><li><p>需有单独的<strong>乘除法模块</strong>和<strong>数据扩展模块</strong>，我们会分别在“乘除模块”和“支持按字节访存”两个小节中中予以详细说明。</p></li><li><p>最外层的 mips 模块的文件名必须为 mips.v ，该文件中的 module也必须命名为 <strong>mips</strong> 。</p></li></ol><h3 id="架构">架构</h3><h3 id="模块规格">模块规格</h3><h4 id="命名规则">命名规则</h4><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能(_去向)</code> 命名。</p><h4 id="共有信号">共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级（IF为out）</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr><tr class="even"><td style="text-align: center;">IF_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从tb获取的指令</td><td style="text-align: center;">tb</td></tr><tr class="odd"><td style="text-align: center;">IF_pc</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">IF级当前指令</td><td style="text-align: center;">tb</td></tr></tbody></table><h4 id="id">ID</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="even"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">EX_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示E级产生了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">EX_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">E级产生新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">mul是否正忙</td><td style="text-align: center;">mul</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out;<span class="hljs-comment">//即时给出运算结果，上升沿时赋给EX_out</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_tmp_new;<span class="hljs-comment">//同上，EX_new</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] EX_tmp_addr;<span class="hljs-comment">//EX_addr</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] start;<span class="hljs-comment">//从E级指令给出mul所需信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] hi;<span class="hljs-comment">//</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] lo;<br></code></pre></td></tr></table></figure><h5 id="内部模块mul">内部模块——mul</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">EX</td></tr><tr class="odd"><td style="text-align: center;">start</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">开始运算信号</td><td style="text-align: center;">EX</td></tr><tr class="even"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rs</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">B</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算数rt</td><td style="text-align: center;">EX_rt_use</td></tr><tr class="even"><td style="text-align: center;">busy</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">正忙信号</td><td style="text-align: center;">busy</td></tr><tr class="odd"><td style="text-align: center;">hi</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法高位/除法余数</td><td style="text-align: center;">out</td></tr><tr class="even"><td style="text-align: center;">lo</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">乘法低位/除法的商</td><td style="text-align: center;">out</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要读出的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">读出的数据</td><td style="text-align: center;">m_data_rdata</td></tr><tr class="odd"><td style="text-align: center;">MEM_new</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">表示M级有了新的要写入寄存器的值</td><td style="text-align: center;">instr</td></tr><tr class="even"><td style="text-align: center;">MEM_new_addr</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">M级新值的寄存器地址</td><td style="text-align: center;">instr</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">传向下一级的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-2">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] op;<span class="hljs-comment">//位扩展选择信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] data_out;<span class="hljs-comment">//原始读出数据</span><br></code></pre></td></tr></table></figure><h5 id="内部模块">内部模块</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">in</td><td style="text-align: center;">A</td><td style="text-align: center;">读出地址的低位</td><td style="text-align: center;">MEM_addr</td></tr><tr class="even"><td style="text-align: center;">Din</td><td style="text-align: center;">in</td><td style="text-align: center;">Din</td><td style="text-align: center;">原始数据</td><td style="text-align: center;">MEM_data</td></tr><tr class="odd"><td style="text-align: center;">Op</td><td style="text-align: center;">in</td><td style="text-align: center;">Op</td><td style="text-align: center;">扩展选择信号</td><td style="text-align: center;">op</td></tr><tr class="even"><td style="text-align: center;">Dout</td><td style="text-align: center;">out</td><td style="text-align: center;">Dout</td><td style="text-align: center;">扩展后的数据</td><td style="text-align: center;">MEM_data_WB</td></tr></tbody></table><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h3 id="冒险处理">冒险处理</h3><h4 id="转发">转发</h4><p>转发共5个接受：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_data;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rs_base;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_rt;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] MEM_data;<br></code></pre></td></tr></table></figure><p>共2处提供：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] EX_out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WB_data_ID;<br></code></pre></td></tr></table></figure><p>其中，2处提供接口还给出new信号与addr，代表新值产生且可用、要写入的寄存器编号</p><p>接受者只需判断new与addr即可决定转发与否（有新值且可用就转发）</p><h4 id="阻塞">阻塞</h4><p><span class="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算见表格</p><p>采用Time模块传递计算结果，<code>[31:0] use_new</code>具体每位对应结果如下表</p><p>[2][1][0]分别对应rs、rt、rd</p><table><thead><tr class="header"><th style="text-align: center;">rs</th><th style="text-align: center;">rt</th><th style="text-align: center;">rd</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[0]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">-&gt;</td><td style="text-align: center;">use或new的数值</td><td style="text-align: center;">&lt;-</td><td style="text-align: center;">1代表正在算乘除法</td><td style="text-align: center;">-&gt;</td><td style="text-align: center;">0为use，1为new</td><td style="text-align: center;">&lt;-</td></tr></tbody></table><p>若 <span class="math inline">\(T_{use}&lt;T_{new}\)</span>，或乘除类指令遇上busy，则执行阻塞操作：</p><ol type="1"><li><p>冻结IF/ID</p></li><li><p>清除ID/EX</p></li><li><p>禁止PC</p></li></ol><h4 id="注意事项">注意事项</h4><ul><li><p>从W级转发到D级，采用D级内部转发（如beq）</p></li><li><p>转发时如果地址是0寄存器应剔除</p></li></ul><h3 id="添加指令">添加指令</h3><ol type="1"><li><p>添加到const里</p></li><li><p>填写TIME表格，根据use和new更改M级中的MEM_new与MEM_new_addr，添加Time中的use与new值</p></li><li><p>根据操作在每个模块添加行为</p><ul><li><p>IF：指令获取与延迟槽</p></li><li><p>ID：给出跳转指令</p></li><li><p>EX：各种计算行为、存储地址计算</p></li><li><p>MEM：给出写入内存的地址、byte信号，对读出的数据进行加工</p></li><li><p>WB：给出写寄存器信号、寄存器编号、数据</p></li></ul></li><li><p>每类指令对应行为（P5）</p><ul><li><p>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</p></li><li><p>lw：修改EX计算过程、添加WB回写信号，……</p></li><li><p>sw：修改EX计算过程、MEM写入，………</p></li><li><p>j：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</p></li><li><p>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</p></li></ul></li><li><p>是否有新的转发通路、阻塞可能</p></li></ol><h3 id="思考题与测试">思考题与测试</h3><ol type="1"><li><p>为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的HI、LO 寄存器？</p><p>乘除法相较其他运算，复杂性更高且时间更长（延迟更大），与ALU分离有利于保持模块的清晰关系、缩短时钟周期。便于在本级存储运算结果而不是回写到寄存器，否则其他使用寄存器的指令均需要被阻塞，性能下降严重。</p></li><li><p>真实的流水线 CPU是如何使用实现乘除法的？请查阅相关资料进行简单说明。</p><p>类似于竖式乘法，乘数最低位*被乘数并累加右移直至每位乘数都算完，32位需5次加法-100周期的时间。</p><p>类似于算式除法，每次尝试减去能减去的最大值（含比较过程），重复计算得商、余数</p></li><li><p>请结合自己的实现分析，你是如何处理 Busy信号带来的周期阻塞的？</p><p>当D级是乘除类指令且E级是乘除类指令或busy时，阻塞</p></li><li><p>请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</p><p>可读性好，当前执行的指令一目了然。字、半字、字节的处理具有统一性。</p></li><li><p>请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</p><p>不是。写入低位时，按字读和按字写效率近似，写入低位效率高于写入高位</p></li><li><p>为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</p><ul><li><p>const中定义指令编码，减少代码量、提高易读性</p></li><li><p>time计算指令单独成一模块，采用列举法，便于新增指令</p></li></ul></li><li><p>在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</p><p>见转发</p></li><li><p>如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证<strong>覆盖</strong>了所有需要测试的情况；如果你是<strong>完全随机</strong>生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了<strong>特殊的策略</strong>，比如构造连续数据冒险序列，请你描述一下你使用的策略如何<strong>结合了随机性</strong>达到强测的效果。</p></li></ol><h4 id="测试部分">测试部分</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">4</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">4</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">2</span>)s<br><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">4</span>,$<span class="hljs-number">4</span>,<span class="hljs-number">12</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sh</span> $<span class="hljs-number">3</span>,<span class="hljs-number">6</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sb</span> $<span class="hljs-number">4</span>,<span class="hljs-number">11</span>($<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2冒险测试">part2——冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><h5 id="part3新增指令测试">part3——新增指令测试</h5><p>重点测试边缘数据</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">and</span> <span class="hljs-symbol">$</span><span class="hljs-number">1</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br><span class="hljs-keyword">or</span> <span class="hljs-symbol">$</span><span class="hljs-number">3</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>sub <span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>slt <span class="hljs-symbol">$</span><span class="hljs-number">7</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>sltu <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">5</span>,<span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>addi <span class="hljs-symbol">$</span><span class="hljs-number">9</span>,<span class="hljs-symbol">$</span><span class="hljs-number">9</span>,<span class="hljs-number">-1</span><br>andi <span class="hljs-symbol">$</span><span class="hljs-number">10</span>,<span class="hljs-symbol">$</span><span class="hljs-number">10</span>,<span class="hljs-number">-1</span><br>sb <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">-1</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>sh <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">0</span>(<span class="hljs-symbol">$</span><span class="hljs-number">0</span>)<br>lw <span class="hljs-symbol">$</span><span class="hljs-number">12</span>,<span class="hljs-number">0</span>(<span class="hljs-symbol">$</span><span class="hljs-number">0</span>)<br>lui <span class="hljs-symbol">$</span><span class="hljs-number">11</span> <span class="hljs-number">0x1111</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">11</span> <span class="hljs-number">0x1111</span><br>sh <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-number">2</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>lb <span class="hljs-symbol">$</span><span class="hljs-number">13</span>,<span class="hljs-number">3</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br>lh <span class="hljs-symbol">$</span><span class="hljs-number">14</span>,<span class="hljs-number">2</span>(<span class="hljs-symbol">$</span><span class="hljs-number">4</span>)<br><br>mult <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">15</span><br>multu <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">16</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">17</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">11</span>,<span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">18</span><br>mthi <span class="hljs-symbol">$</span><span class="hljs-number">19</span><br>mtlo <span class="hljs-symbol">$</span><span class="hljs-number">20</span><br><br>lui <span class="hljs-symbol">$</span><span class="hljs-number">20</span>,<span class="hljs-number">0</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">20</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">loop</span>:<br>bne <span class="hljs-symbol">$</span><span class="hljs-number">19</span>,<span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-keyword">loop</span><br>sub <span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-symbol">$</span><span class="hljs-number">21</span>,<span class="hljs-symbol">$</span><span class="hljs-number">20</span><br>nop<br><span class="hljs-comment">//重点测试符号乘除</span><br>lui <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-number">0x1111</span><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-number">0x1111</span><br>add <span class="hljs-symbol">$</span><span class="hljs-number">3</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">0</span><br>mult <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">4</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">5</span><br>multu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">6</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">7</span><br><br>ori <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">0</span>,<span class="hljs-number">13</span><br>add <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">9</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">10</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">11</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">12</span><br><span class="hljs-built_in">div</span> <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">13</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">14</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">8</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">15</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">16</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">8</span>,<span class="hljs-symbol">$</span><span class="hljs-number">2</span><br>mfhi <span class="hljs-symbol">$</span><span class="hljs-number">17</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">18</span><br>divu <span class="hljs-symbol">$</span><span class="hljs-number">2</span>,<span class="hljs-symbol">$</span><span class="hljs-number">3</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">19</span><br>mflo <span class="hljs-symbol">$</span><span class="hljs-number">20</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P5设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P5%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P5%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P5建议：可以在P4的基础上先搭建没有转发、阻塞的流水线CPU，确认功能完善后逐步添加阻塞、转发通路。对于P5，转发与阻塞情况不多，也可采用列举法，后期改为TIME</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h3 id="设计要求">设计要求</h3><ol type="1"><li>处理器应支持如下指令集：{ add, sub, ori, lw, sw, beq, lui, jal, jr,nop }，为五级流水线设计。</li><li>流水线的设计以追求性能为第一目标，因此必须尽最大可能<strong>支持转发</strong>以解决数据冒险。这一点在本project的最终成绩中所占比重较大，课上测试时会通过测试程序所运行的<strong>总周期数</strong>进行判定，望大家慎重对待。</li><li>对于 b 类和 j 类指令，流水线设计必须<strong>支持延迟槽</strong>，因此设计需要注意使用<strong>PC@D + 8</strong>或<strong>PC@I + 4</strong>。</li><li>为了解决数据冒险而设计的转发数据来源必须是<strong>某级流水线寄存器</strong>，<strong>不允许</strong>对功能部件的输出直接进行转发。</li><li>指令存储器（IM，instruction memory）和数据存储器（DM，datamemory）要求如下：<ul><li>IM：容量为 <strong>16KiB</strong>（<strong>4096</strong> ×32bit）。</li><li>DM：容量为 <strong>12KiB</strong>（<strong>3072</strong> ×32bit）。</li></ul></li><li>PC 的初始地址为 <strong>0x00003000</strong>，和 Mars中我们要求设置的代码初始地址相同。</li><li>最外层的 mips 模块的文件名必须为 mips.v ，该文件中的 module也必须命名为 <strong>mips</strong> 。</li></ol><h3 id="模块规格">模块规格</h3><h4 id="架构">架构</h4><figure><img src="/img/CPU架构.jpg" alt="CPU架构" /><figcaption aria-hidden="true">CPU架构</figcaption></figure><h4 id="命名规则">命名规则</h4><p>流水线信号共5级，IF/ID ID/EX EX/MEM MEM/WB，两个寄存器间的信号用<code>级别_数据/功能(_去向)</code> 命名。</p><h4 id="控制器设计">控制器设计</h4><h5 id="指令解读">指令解读</h5><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">000011</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">较为复杂</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">001000</td><td style="text-align: center;">PC=rs</td></tr></tbody></table><p>jal：$31=PC+4，PC=PC[31:28]+index00</p><h4 id="共有信号">共有信号：</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">xx_pc</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的pc</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_pc_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的pc</td><td style="text-align: center;">下一级yy（WB无）</td></tr><tr class="odd"><td style="text-align: center;">xx_instr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">当前级的指令</td><td style="text-align: center;">上一级</td></tr><tr class="even"><td style="text-align: center;">xx_instr_yy</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要传给下一级的指令</td><td style="text-align: center;">下一级yy（WB无）</td></tr></tbody></table><h4 id="if">IF</h4><h5 id="接口">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，使pc保持不变</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">IF_j</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">是否跳转</td><td style="text-align: center;">ID_j_IF</td></tr><tr class="odd"><td style="text-align: center;">IF_pc4</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">ID_pc_IF</td></tr></tbody></table><h5 id="内部变量">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IM [<span class="hljs-number">0</span>:<span class="hljs-number">4095</span>];<span class="hljs-comment">//存储指令</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IF_pc;<span class="hljs-comment">//存储pc，同时也是当前的pc</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] IF_instr;<span class="hljs-comment">//当前的指令</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc_addr;<span class="hljs-comment">//方便截取特定位宽</span><br><span class="hljs-keyword">assign</span> pc_addr=IF_pc-<span class="hljs-number">32&#x27;h3000</span>;<br><span class="hljs-keyword">assign</span> IF_instr=IM[pc_addr[<span class="hljs-number">13</span>:<span class="hljs-number">2</span>]];<br></code></pre></td></tr></table></figure><h4 id="id">ID</h4><h5 id="接口-1">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">stall</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">阻塞信号，清空D级</td><td style="text-align: center;">staller</td></tr><tr class="even"><td style="text-align: center;">WB_pc_ID</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">写入指令的pc</td><td style="text-align: center;">WB_pc_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_we</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">WB_we_ID</td></tr><tr class="even"><td style="text-align: center;">ID_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器</td><td style="text-align: center;">WB_addr_ID</td></tr><tr class="odd"><td style="text-align: center;">ID_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的值</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="even"><td style="text-align: center;">ID_rs_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">ID_rt_sign</td><td style="text-align: center;">in</td><td style="text-align: center;">[2:0]</td><td style="text-align: center;">转发选择，0为原值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;">EX_out，EX_data_WB，MEM_data_WB</td></tr><tr class="odd"><td style="text-align: center;">ID_rt_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">转发值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">ID_rs_base</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">EX_rs_base</td></tr><tr class="odd"><td style="text-align: center;">ID_rt</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">EX_rt</td></tr><tr class="even"><td style="text-align: center;">ID_j_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">跳转指示信号</td><td style="text-align: center;">IF_j</td></tr><tr class="odd"><td style="text-align: center;">ID_pc_IF</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IF_pc4</td></tr></tbody></table><h5 id="内部变量-1">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rs_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ID_rt_use;<span class="hljs-comment">//搭配转发使用</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] grf [<span class="hljs-number">0</span>:<span class="hljs-number">31</span>];<span class="hljs-comment">//32个寄存器</span><br></code></pre></td></tr></table></figure><h4 id="ex">EX</h4><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">EX_rs_base</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rs寄存器的值</td><td style="text-align: center;">ID_rs_base</td></tr><tr class="even"><td style="text-align: center;">EX_rt_use</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">参与运算的rt寄存器的值，可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">EX_rt</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><tdstyle="text-align: center;">传递rt供sw写入的值，也可能从转发处来</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">EX_out</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">MEM_addr</td></tr><tr class="odd"><td style="text-align: center;">EX_rt_MEM</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">rt寄存器的值</td><td style="text-align: center;">MEM_data</td></tr></tbody></table><h4 id="mem">MEM</h4><h5 id="接口-2">接口</h5><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MEM_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的地址</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">MEM_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入的数据</td><td style="text-align: center;">EX_rt_MEM</td></tr><tr class="odd"><td style="text-align: center;">MEM_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">内存中读出的数据</td><td style="text-align: center;">WB_lw_data</td></tr><tr class="even"><td style="text-align: center;">EX_data_WB</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">WB_alu_data</td></tr></tbody></table><h5 id="内部变量-2">内部变量</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] DM [<span class="hljs-number">0</span>:<span class="hljs-number">3071</span>];<br></code></pre></td></tr></table></figure><h4 id="wb">WB</h4><p>输出均不是reg型</p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">WB_lw_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">从内存取出的数</td><td style="text-align: center;">MEM_data_WB</td></tr><tr class="even"><td style="text-align: center;">WB_alu_data</td><td style="text-align: center;">in</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">运算结果</td><td style="text-align: center;">EX_data_WB</td></tr><tr class="odd"><td style="text-align: center;">WB_we_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">寄存器写入信号</td><td style="text-align: center;">ID_we</td></tr><tr class="even"><td style="text-align: center;">WB_addr_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[4:0]</td><td style="text-align: center;">要写入的寄存器地址</td><td style="text-align: center;">ID_addr</td></tr><tr class="odd"><td style="text-align: center;">WB_data_ID</td><td style="text-align: center;">out</td><td style="text-align: center;">[31:0]</td><td style="text-align: center;">要写入寄存器的值</td><td style="text-align: center;">ID_data</td></tr></tbody></table><h3 id="冒险处理">冒险处理</h3><h4 id="t_use-与-t_new-的计算"><spanclass="math inline">\(T_{use}\)</span> 与 <spanclass="math inline">\(T_{new}\)</span> 的计算</h4><h5 id="指令分类">指令分类</h5><ul><li><p>calr——2个use(rs,rt)，一个new(rd)</p><p>add、sub</p></li><li><p>cali——1个use(rs)，一个new(rt)</p><p>ori、lui</p></li><li><p>lw——1个use(rs/base)，一个new(rt)</p><p>lw</p></li><li><p>sw——2个use(rs,rt)，无new</p><p>sw</p></li><li><p>j_rs——1个use(rs)</p><p>jr、beq</p></li><li><p>j_rt——1个use(rt)</p><p>beq</p></li><li><p>jal——无法分类</p></li></ul><p>其中，beq从属于两种</p><h5 id="列表">列表</h5><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">类型</th><th style="text-align: center;"><spanclass="math inline">\(T_{use}\)</span></th><th style="text-align: center;">转发接口</th><th style="text-align: center;"><spanclass="math inline">\(E\_T_{new}\)</span></th><th style="text-align: center;">提供接口</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">calr</td><td style="text-align: center;">1(rs,rt)</td><td style="text-align: center;">ID_rs_base_EX,ID_rt_EX</td><td style="text-align: center;">1(rd)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">calr</td><td style="text-align: center;">1(rs,rt)</td><td style="text-align: center;">ID_rs_base_EX,ID_rt_EX</td><td style="text-align: center;">1(rd)</td><td style="text-align: center;">EX_out</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">cali</td><td style="text-align: center;">1(rs)</td><td style="text-align: center;">ID_rs_base_EX</td><td style="text-align: center;">1(rt)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">lw</td><td style="text-align: center;">1(base)</td><td style="text-align: center;">ID_rs_base_EX</td><td style="text-align: center;">2(rt)</td><td style="text-align: center;">WB_data_ID</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">sw</td><td style="text-align: center;">1(rs),2(rt)</td><td style="text-align: center;">ID_rs_base_EX,EX_rt_MEM</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">j_rs,j_rt</td><td style="text-align: center;">0(rs,rt)</td><td style="text-align: center;">ID_rs_data,ID_rt_data</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">cali</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td><td style="text-align: center;">1(rt)</td><td style="text-align: center;">EX_out</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">j</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td><td style="text-align: center;">1($31)</td><td style="text-align: center;">EX_out</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">j_rs</td><td style="text-align: center;">0(rs)</td><td style="text-align: center;">ID_rs_data</td><td style="text-align: center;">\</td><td style="text-align: center;">\</td></tr></tbody></table><h4 id="暂停">暂停</h4><h5 id="阻塞分类">阻塞分类</h5><p>总原则： <span class="math inline">\(T_{use}&lt;E\_T_{new}\)</span>、 <span class="math inline">\(T_{use}&lt;M\_T_{new}\)</span>、地址相同</p><p>大致有0&lt;1、0&lt;2、1&lt;2、0&lt;2(M级)四种类型，均需比较地址</p><h5 id="执行操作">执行操作</h5><p>若需要阻塞，则</p><ol type="1"><li>冻结IF/ID</li><li>清除ID/EX</li><li>禁止PC</li></ol><h4 id="转发">转发</h4><h5 id="接口-3">接口</h5><p>见表格</p><h5 id="注意事项">注意事项</h5><ul><li>从W级转发到D级，采用D级内部转发（如beq）</li><li>从W级转发到E、M级，可利用WB的信号直接判断</li><li>MEM写入内存的rt值从D到E再到M，要经过2次转发（如lw $3,0($0) sw$3,0($3)，因为阻塞了一次，W级产生的数据没办法转发到M级，只能是sw在E级时把W级的lw产生的数据转发）</li><li>转发时如果地址是0寄存器应剔除</li></ul><h5 id="遇到的bug修复历史">遇到的bug&amp;修复历史</h5><p>jr忘记加到阻塞里</p><p>lw写入的是rt不是rd，阻塞判断错了</p><p>先lw,后sw发生阻塞时，不能及时转发sw需要、lw产生的rt值</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">4</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">3</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">3</span>,<span class="hljs-number">0</span>($<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>加指令：改const、改阻塞、改转发、</p><h3 id="添加指令">添加指令</h3><ol type="1"><li>添加到const里</li><li>分类，想想有无新的转发通路/阻塞<ul><li>cal：修改EX计算过程、添加WB回写信号，加入相关阻塞指令中（带cal的），加入相关转发指令中（同上，注意供需接口都有）。</li><li>lw：修改EX计算过程、添加WB回写信号，……</li><li>sw：修改EX计算过程、MEM写入，……但是注意“注意事项3”，修改rt在E级的转发</li><li>j_rs：</li><li>j_rt：修改ID跳转判断与跳转地址计算，加入阻塞、转发指令</li><li>jal：修改ID跳转判断与跳转地址计算、EX算pc等、WB回写信号，阻塞转发</li></ul></li><li>在阻塞和转发中分别添加相应值，注意“注意事项3”</li></ol><h3 id="思考题">思考题</h3><p>1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</p><p>​ 提前分支判断使得beq的 <span class="math inline">\(T_{use}\)</span>为0，很容易发生阻塞，如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">0</span>,loop<br></code></pre></td></tr></table></figure><p>​ 如果不提前判断，则可以使用转发解决（但这样好像会多流水一级？）</p><p>2、因为延迟槽的存在，对于 jal等需要将指令地址写入寄存器的指令，要写回 PC +8，请思考为什么这样设计？</p><p>​ jal执行后会无条件执行下一句（pc+4），但jr$ra执行时不会再执行延迟槽中的内容，因此是pc+8</p><p>3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、 ALU ），请思考为什么？</p><p>​ 来自寄存器的输出是稳定的，而功能部件可能输出不稳定</p><p>4、我们为什么要使用 GPR 内部转发？该如何实现？</p><p>​ 为了将来自W级的输出及时写入寄存器（或及时使用）。实现见代码</p><p>5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</p><p>​ 见“冒险处理”</p><p>6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</p><p>​ 见“添加指令”</p><p>7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。</p><p>​分布式译码，每一级流水指令即可，无需流水控制信号，通过宏定义根据指令执行操作</p><p>​ 不足：加指令时需要修改的部件较多</p><h3 id="让我想想">让我想想</h3><h4 id="测试部分">测试部分</h4><h5 id="part1p4的数据测试">part1——P4的数据测试</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>nop<br>jal loop3#往前跳<br>nop<br>jal loop4#往后跳<br>loop4:<br>nop<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>nop<br>jal end2#原地蹦跶<br>nop<br></code></pre></td></tr></table></figure><h5 id="part2冒险测试">part2——冒险测试</h5><p><span class="math inline">\(A_9^4\)</span>？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#add,sub,ori,lui,lw,sw,beq,jal,jr</span><br><span class="hljs-comment">#先把每个寄存器里的值搞成非0</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">2</span>,-<span class="hljs-number">4</span>($<span class="hljs-number">2</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">3</span>,$<span class="hljs-number">2</span>,$<span class="hljs-number">2</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">2</span>,$<span class="hljs-number">3</span>,<span class="hljs-number">8</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">4</span>,<span class="hljs-number">4</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sub</span> $<span class="hljs-number">5</span>,$<span class="hljs-number">4</span>,$<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lui</span> $<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">ori</span> $<span class="hljs-number">6</span>,$<span class="hljs-number">6</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">sw</span> $<span class="hljs-number">6</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">lw</span> $<span class="hljs-number">7</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">7</span>,$<span class="hljs-number">7</span>,<span class="hljs-number">2</span><br><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">0</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">sw</span> $<span class="hljs-number">8</span>,<span class="hljs-number">8</span>($<span class="hljs-number">0</span>)<br><br><span class="hljs-attribute">loop</span>:<br><span class="hljs-attribute">add</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">10</span>,$<span class="hljs-number">9</span><br><span class="hljs-attribute">beq</span> $<span class="hljs-number">9</span>,$<span class="hljs-number">19</span>,loop<br><span class="hljs-attribute">ori</span> $<span class="hljs-number">11</span>,$<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br><span class="hljs-attribute">jal</span> loop2<br><span class="hljs-attribute">add</span> $<span class="hljs-number">12</span>,$<span class="hljs-number">11</span>,$<span class="hljs-number">11</span><br><span class="hljs-attribute">loop2</span>:<br><span class="hljs-attribute">sw</span> $ra,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">ori</span> $ra,$<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">lw</span> $<span class="hljs-number">30</span>,<span class="hljs-number">12</span>($<span class="hljs-number">0</span>)<br><span class="hljs-attribute">jr</span> $<span class="hljs-number">30</span><br><span class="hljs-attribute">nop</span><br></code></pre></td></tr></table></figure><p>把mips.v里的转发、阻塞写到每个模块里，每个模块只需要针对当前指令给出addr和Tnew，ID给出Tuse</p><p>为什么DM的rt需要在E、M级2次转发？</p><p>大概因为sw在DM才用，lw的数据W级才有，错开就？</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P4设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P4%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P4%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P4建议：翻译P3设计即可，注意新加指令</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h4 id="设计要求">设计要求</h4><ul><li><p>处理器为 32 位单周期处理器，不考虑延迟槽，应支持的指令集为：<code>add, sub, ori, lw, sw, beq, lui, jal, jr, nop</code> ，其中：</p><ul><li><p><code>nop</code> 为空指令，机器码<code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</p></li><li><p><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</p></li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层文件为<strong>mips.v</strong>，有效的驱动信号要求包括且仅包括<strong>同步复位信号reset</strong> 和<strong>时钟信号 clk</strong>，接口定义如下：</p></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset<br>);<br></code></pre></td></tr></table></figure><h4 id="模块规格">模块规格</h4><h5 id="顶层设计">顶层设计</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset<br>    );<br><br><span class="hljs-comment">//CON</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Instr;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] j_ctrl;<span class="hljs-comment">//跳转指令，0为正常+4  1为beq  2为jal  3为jr</span><br><span class="hljs-keyword">wire</span> grf_write;<span class="hljs-comment">//grf写入信号</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] grf_reg;<span class="hljs-comment">//选择grf写入的寄存器</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] grf_data;<span class="hljs-comment">//选择grf写入数据来源</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ALU_op;<span class="hljs-comment">//运算选择</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] ALU_data_op;<span class="hljs-comment">//运算数选择</span><br><span class="hljs-keyword">wire</span> MemWrite;<span class="hljs-comment">//数据写入信号</span><br><span class="hljs-comment">//PC</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] j_addr;<span class="hljs-comment">//PC跳转地址</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] pc;<span class="hljs-comment">//PC</span><br><span class="hljs-comment">//ALU</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] ALU_out;<span class="hljs-comment">//ALU运算结果</span><br><span class="hljs-comment">//reg</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] RegAddr;<span class="hljs-comment">//写入的寄存器</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] WD;<span class="hljs-comment">//写入的数据</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD1;<span class="hljs-comment">//读出的寄存器数据1</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] RD2;<span class="hljs-comment">//读出的寄存器数据2</span><br><span class="hljs-comment">//ALU</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] b;<span class="hljs-comment">//运算数2</span><br><span class="hljs-comment">//DM</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] DM_out;<span class="hljs-comment">//DM读出的数据</span><br><span class="hljs-comment">//decode</span><br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">15</span>:<span class="hljs-number">0</span>] im_of;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] Func;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rd;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rt;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] rs_base;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] Op_code;<br>     <span class="hljs-keyword">wire</span> [<span class="hljs-number">25</span>:<span class="hljs-number">0</span>] index;<br><span class="hljs-keyword">assign</span> im_of=Instr[<span class="hljs-number">15</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> Func=Instr[<span class="hljs-number">5</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> rd=Instr[<span class="hljs-number">15</span>:<span class="hljs-number">11</span>];<br><span class="hljs-keyword">assign</span> rt=Instr[<span class="hljs-number">20</span>:<span class="hljs-number">16</span>];<br><span class="hljs-keyword">assign</span> rs_base=Instr[<span class="hljs-number">25</span>:<span class="hljs-number">21</span>];<br><span class="hljs-keyword">assign</span> Op_code=Instr[<span class="hljs-number">31</span>:<span class="hljs-number">26</span>];<br><span class="hljs-keyword">assign</span> index=Instr[<span class="hljs-number">25</span>:<span class="hljs-number">0</span>];<br><br><br><span class="hljs-keyword">assign</span> j_addr=(j_ctrl==<span class="hljs-number">2&#x27;b00</span>)?(pc+<span class="hljs-number">4</span>):<br>    (j_ctrl==<span class="hljs-number">2&#x27;b01</span>)?(pc+<span class="hljs-number">4</span>+&#123;&#123;<span class="hljs-number">14</span>&#123;im_of[<span class="hljs-number">15</span>]&#125;&#125;,im_of,<span class="hljs-number">2&#x27;b0</span>&#125;):<span class="hljs-comment">//beq</span><br>                    (j_ctrl==<span class="hljs-number">2&#x27;b10</span>)?(&#123;pc[<span class="hljs-number">31</span>:<span class="hljs-number">28</span>],index,<span class="hljs-number">2&#x27;b0</span>&#125;):<span class="hljs-comment">//jal</span><br>                    RD1;<span class="hljs-comment">//jr</span><br><span class="hljs-keyword">assign</span> RegAddr=(grf_reg==<span class="hljs-number">2&#x27;b00</span>)?rd:<br>                    (grf_reg==<span class="hljs-number">2&#x27;b01</span>)?rt:<br>                    <span class="hljs-number">5&#x27;b11111</span>;<span class="hljs-comment">//写入$ra</span><br><span class="hljs-keyword">assign</span> WD=(grf_data==<span class="hljs-number">2&#x27;b00</span>)?ALU_out:<br>                (grf_data==<span class="hljs-number">2&#x27;b01</span>)?DM_out:<span class="hljs-comment">//lw</span><br>                (grf_data==<span class="hljs-number">2&#x27;b10</span>)?&#123;im_of,&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;&#125;:<span class="hljs-comment">//lui</span><br>                pc+<span class="hljs-number">4</span>;<span class="hljs-comment">//写入$ra</span><br><span class="hljs-keyword">assign</span> b=(ALU_data_op==<span class="hljs-number">0</span>)?RD2:<br>            (ALU_data_op==<span class="hljs-number">1</span>)?&#123;&#123;<span class="hljs-number">16</span>&#123;<span class="hljs-number">1&#x27;b0</span>&#125;&#125;,im_of&#125;:<span class="hljs-comment">//ori</span><br>            &#123;&#123;<span class="hljs-number">16</span>&#123;im_of[<span class="hljs-number">15</span>]&#125;&#125;,im_of&#125;;<span class="hljs-comment">//lw,sw</span><br><br>controller con(Instr,j_ctrl,grf_write,grf_reg,grf_data,ALU_op,ALU_data_op,MemWrite,ALU_out);<br>PC Pc(clk,reset,j_addr,pc);<br>IM im(pc,Instr);<br>GRF grf(clk,reset,grf_write,RegAddr,WD,rs_base,rt,RD1,RD2);<br>ALU alu(ALU_op,RD1,b,ALU_out);<br>DM dm(clk,reset,MemWrite,ALU_out,RD2,DM_out);<br><br><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>(grf_write==<span class="hljs-number">1</span>&amp;&amp;reset!=<span class="hljs-number">1</span>)<span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: $%d &lt;= %h&quot;</span>, pc, RegAddr, WD);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span>(MemWrite==<span class="hljs-number">1</span>&amp;&amp;reset!=<span class="hljs-number">1</span>)<span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;@%h: *%h &lt;= %h&quot;</span>, pc, ALU_out, RD2);<br>        <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">integer fp;</span><br><span class="hljs-comment">initial begin</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">fp = $fopen(&quot;info.txt&quot;,&quot;w&quot;);</span><br><span class="hljs-comment">end</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h5 id="ifu取指令单元">IFU（取指令单元)</h5><ul><li><p>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</p></li><li><p>PC用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</p></li><li><p><strong>起始地址：0x00003000</strong>。</p></li><li><p>地址范围：0x00003000 ~ 0x00006FFF。</p></li><li><p>IM 用 ROM 实现，容量为 4096 × 32bit。</p></li><li><p>IM 实际地址宽度仅为 12 位，需要使用恰当的方法将 PC 中储存的地址同IM 联系起来。</p></li></ul><h6 id="pcmoore型状态机">PC（Moore型状态机）</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">j_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">pc、Instr</td></tr><tr class="even"><td style="text-align: center;">addr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">下一条指令地址</td><td style="text-align: center;">IM</td></tr></tbody></table><h6 id="im">IM</h6><p><code>reg [31:0] IM [0:4095]</code></p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令地址</td><td style="text-align: center;">j_addr</td></tr><tr class="even"><td style="text-align: center;">Instr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td><td style="text-align: center;">很多</td></tr></tbody></table><h5id="grf通用寄存器组也称为寄存器文件寄存器堆">GRF（通用寄存器组，也称为寄存器文件、寄存器堆）</h5><ul><li><p>用具有写使能的寄存器实现，寄存器总数为 32个，应具有<strong>异步复位</strong>功能。</p></li><li><p><strong>0 号寄存器</strong>的值始终保持为0。其他寄存器<strong>初始值（复位后）均为0</strong>，无需专门设置。</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">WE</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">写使能信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">RegAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">GRF 5 位写入地址</td><td style="text-align: center;">rd/rt/$ra</td></tr><tr class="odd"><td style="text-align: center;">WD</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位写入数据</td><td style="text-align: center;">ALU/DM/im_of/pc</td></tr><tr class="even"><td style="text-align: center;">A1</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">rs_base</td></tr><tr class="odd"><td style="text-align: center;">A2</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">rt</td></tr><tr class="even"><td style="text-align: center;">RD</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">RD2</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr></tbody></table><h5 id="alu算术逻辑单元">ALU（算术逻辑单元）</h5><p>？比较按无符号还是有符号？</p><ul><li><p>提供 32 位加、减、或运算及大小比较功能。</p></li><li><p>加减法按无符号处理（不考虑溢出）。</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">in</td><td style="text-align: center;">2</td><td style="text-align: center;">功能选择</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">a</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数1</td><td style="text-align: center;">RD1</td></tr><tr class="odd"><td style="text-align: center;">b</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数2</td><td style="text-align: center;">RD2/im_of</td></tr><tr class="even"><td style="text-align: center;">out</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">结果</td><td style="text-align: center;">WD/MemAddr/con</td></tr></tbody></table><h5 id="dm数据存储器">DM（数据存储器）</h5><ul><li><p>使用 RAM 实现，容量为 3072 ×32bit，应具有<strong>异步复位</strong>功能，复位值为0x00000000。</p></li><li><p><strong>起始地址：0x00000000</strong>。</p></li><li><p>地址范围：0x00000000 ~ 0x00002FFF。</p></li><li><p>RAM 应使用双端口模式，即设置 RAM 的 <strong>DataInterface</strong> 属性为 <strong>Separate load and storeports</strong>。</p></li></ul><p><code>reg [31:0] DM [0:3071]</code></p><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">同步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">DM 写入控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">MemAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入地址</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">MemData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入数据</td><td style="text-align: center;">RD2</td></tr><tr class="even"><td style="text-align: center;">MemData</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位输出数据</td><td style="text-align: center;">WD</td></tr></tbody></table><h5 id="ext扩展单元">EXT（扩展单元）</h5><ul><li>可以使用 Logisim 内置的 Bit Extender。</li></ul><h5 id="controller控制器">Controller（控制器）</h5><ul><li><p>使用与或门阵列构造控制信号的具体方法见后文叙述。</p></li><li><p>也可以通过其它方式构造控制信号，同学们可以自行探索。</p></li></ul><h6 id="指令解读">指令解读</h6><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr><tr class="even"><td style="text-align: center;">jal</td><td style="text-align: center;">000011</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">index</td><td style="text-align: center;">较为复杂</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">001000</td><td style="text-align: center;">PC=rs</td></tr></tbody></table><p>jal：$31=PC+4，PC=PC[31:28]+index00</p><h6 id="控制器">控制器</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td></tr><tr class="even"><td style="text-align: center;">ALU_out</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">比较结果</td></tr><tr class="odd"><td style="text-align: center;">ctrl</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">PC，0(beq),1(jal),2(jr)</td></tr><tr class="even"><td style="text-align: center;">WE</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，写使能信号</td></tr><tr class="odd"><td style="text-align: center;">GRF_op1</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">GRF，控制写入地址来源,0(rd),1(rt),2($ra)</td></tr><tr class="even"><td style="text-align: center;">GRF_op2</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">GRF，控制写入数据来源,0(ALU),1(DM),2(im_of),3(index)</td></tr><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">ALU，运算选择0(+),1(-),2(|),3(==)</td></tr><tr class="even"><td style="text-align: center;">ALU_op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><tdstyle="text-align: center;">ALU，控制运算数来源（0,rt,1,0-im,2,sign-of）</td></tr><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">DM，写入控制信号</td></tr></tbody></table><h4 id="思考题">思考题</h4><ol type="1"><li><p>阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit ×1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr位数为什么是 [11:2] 而不是 [9:0] ？</p><figure><imgsrc="http://cscore.buaa.edu.cn/assets/cscore-image/refkxh/86953c72-c519-48b2-8cb8-7b2c90850e53/66.png"alt="66.png" /><figcaption aria-hidden="true">66.png</figcaption></figure><p>ALU的运算结果；截取高位实现右移2位的效果（lw、sw均为字操作，地址是4的倍数）</p></li><li><p>思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</p><p>地方</p><p>指令</p></li></ol><p>指令对应的控制信号：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> ctrl=(beq&amp;&amp;ALU_out==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<br>                (jal)?<span class="hljs-number">2</span>:<br>                (jr)?<span class="hljs-number">3</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> WE=(add||sub||ori||lw||lui||jal);<br><span class="hljs-keyword">assign</span> GRF_op1=(ori||lw||lui)?<span class="hljs-number">1</span>:<span class="hljs-comment">//rt</span><br>                    (jal)?<span class="hljs-number">2</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//$ra</span><br><span class="hljs-keyword">assign</span> GRF_op2=(jal)?<span class="hljs-number">3</span>:<br>                    (lui)?<span class="hljs-number">2</span>:<br>                    (lw)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> op=(beq)?<span class="hljs-number">3</span>:<br>                (ori)?<span class="hljs-number">2</span>:<br>                (sub)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> ALU_op=(lw||sw)?<span class="hljs-number">2</span>:<br>                    (ori||lui)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> MemWrite=(sw);<br></code></pre></td></tr></table></figure><p>控制信号每种取值对应的指令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> add,sub,ori,lw,sw,beq,lui,jal,jr;<br><span class="hljs-keyword">assign</span> add=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b100000</span>);<br><span class="hljs-keyword">assign</span> sub=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b100010</span>);<br><span class="hljs-keyword">assign</span> ori=(Op_code==<span class="hljs-number">6&#x27;b001101</span>);<br><span class="hljs-keyword">assign</span> lw=(Op_code==<span class="hljs-number">6&#x27;b100011</span>);<br><span class="hljs-keyword">assign</span> sw=(Op_code==<span class="hljs-number">6&#x27;b101011</span>);<br><span class="hljs-keyword">assign</span> beq=(Op_code==<span class="hljs-number">6&#x27;b000100</span>);<br><span class="hljs-keyword">assign</span> lui=(Op_code==<span class="hljs-number">6&#x27;b001111</span>);<br><span class="hljs-keyword">assign</span> jal=(Op_code==<span class="hljs-number">6&#x27;b000011</span>);<br><span class="hljs-keyword">assign</span> jr=(Op_code==<span class="hljs-number">6&#x27;b000000</span>&amp;&amp;Func==<span class="hljs-number">6&#x27;b001000</span>);<br><br><br><span class="hljs-keyword">assign</span> ctrl=(beq&amp;&amp;ALU_out==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<br>                (jal)?<span class="hljs-number">2</span>:<br>                (jr)?<span class="hljs-number">3</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> WE=(add||sub||ori||lw||lui||jal);<br><span class="hljs-keyword">assign</span> GRF_op1=(ori||lw||lui)?<span class="hljs-number">1</span>:<span class="hljs-comment">//rt</span><br>                    (jal)?<span class="hljs-number">2</span>:<span class="hljs-number">0</span>;<span class="hljs-comment">//$ra</span><br><span class="hljs-keyword">assign</span> GRF_op2=(jal)?<span class="hljs-number">3</span>:<br>                    (lui)?<span class="hljs-number">2</span>:<br>                    (lw)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> op=(beq)?<span class="hljs-number">3</span>:<br>                (ori)?<span class="hljs-number">2</span>:<br>                (sub)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> ALU_op=(lw||sw)?<span class="hljs-number">2</span>:<br>                    (ori||lui)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">assign</span> MemWrite=(sw);<br></code></pre></td></tr></table></figure><p>优劣：第一种比较直接，控制信号直接由指令决定，但可读性差</p><p>第二种可读性好，但指令条数增多后代码冗余</p><ol start="3" type="1"><li><p>在相应的部件中，复位信号的设计都是<strong>同步复位</strong>，这与P3中的设计要求不同。请对比<strong>同步复位</strong>与<strong>异步复位</strong>这两种方式的reset 信号与 clk 信号优先级的关系。</p><p>同步复位：clk&gt;reset</p><p>异步复位：reset&gt;clk</p></li><li><p>C 语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着 C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C语言，MIPS 指令的所有计算指令均可以忽略溢出。请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II:The MIPS32® Instruction Set》中相关指令的 Operation 部分。</p><p>与addiu相比，addi将32位扩展为33位并判断是否溢出，但忽略溢出后只关注前32位，因此相当于没拓展，和addiu相同</p><p>add与addu同理</p></li></ol><h4 id="测试方案">测试方案</h4><h5 id="机器码转指令的">机器码转指令的</h5><p>运行C语言代码（code_instruction.c），1为从文件输入，输出到文件；2为单个指令翻译</p><h5 id="自动生成数据点的代码">自动生成数据点的代码</h5><p>待开发，目前只有手敲代码（</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,0x310c<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br><br>loop3:<br>jr <span class="hljs-variable">$ra</span><br>jal loop3#往前跳<br>jal loop4#往后跳<br>loop4:<br>beq <span class="hljs-variable">$24</span>,<span class="hljs-variable">$21</span>,end2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$21</span><br><span class="hljs-built_in">add</span> <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$ra</span><br>jr <span class="hljs-variable">$25</span><br>end2:<br>jal end2#原地蹦跶<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P3设计文档</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P3%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P3%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>P3建议：在阅读课件的基础上梳理每个线路、接口的数据从哪里来、到哪里去，便于理解</p><p>源代码：<ahref="https://github.com/solor-wind/BUAA_CO">solor-wind/BUAA_CO(github.com)</a></p></blockquote><h4 id="设计要求">设计要求</h4><ul><li><p>处理器为 32 位单周期处理器，应支持的指令集为：<code>add, sub, ori, lw, sw, beq, lui, nop</code> ，其中：</p><ul><li><code>nop</code> 为空指令，机器码<code>0x00000000</code>，不进行任何有效行为（修改寄存器等）。</li><li><code>add, sub</code> 按无符号加减法处理（不考虑溢出）。</li></ul></li><li><p>需要采用<strong>模块化</strong>和<strong>层次化</strong>设计。顶层有效的驱动信号要求包括且仅包括<strong>异步复位信号reset</strong>（clk 请使用内置时钟模块）。</p></li></ul><h4 id="模块规格">模块规格</h4><h5 id="顶层设计">顶层设计</h5><figure><img src="/img/image-20231026090817666.png"alt="image-20231026090817666" /><figcaption aria-hidden="true">image-20231026090817666</figcaption></figure><h5 id="ifu取指令单元">IFU（取指令单元）</h5><ul><li>内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑。</li><li>PC用寄存器实现，应具有<strong>异步复位</strong>功能，复位值为起始地址。</li><li><strong>起始地址：0x00003000</strong>。</li><li>地址范围：0x00003000 ~ 0x00006FFF。</li><li>IM 用 ROM 实现，容量为 4096 × 32bit。</li><li>IM 实际地址宽度仅为 12 位，需要使用恰当的方法将 PC 中储存的地址同 IM联系起来。</li></ul><h6 id="pcmoore型状态机">PC（Moore型状态机）</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">内置</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">异步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">ctrl</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">beq_addr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">跳转指令地址</td><td style="text-align: center;">IM的Instr</td></tr><tr class="odd"><td style="text-align: center;">addr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">下一条指令地址</td><td style="text-align: center;">IM</td></tr></tbody></table><p>难点：异步复位置0x00003000</p><p>解决方案：输出+0x00003000，内部仍从0开始</p><h6 id="im">IM</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">sel？</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">读取选择信号</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">addr</td><td style="text-align: center;">in</td><td style="text-align: center;">12</td><td style="text-align: center;">指令地址</td><td style="text-align: center;">PC</td></tr><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td><td style="text-align: center;">Control/PC/</td></tr></tbody></table><h5id="grf通用寄存器组也称为寄存器文件寄存器堆">GRF（通用寄存器组，也称为寄存器文件、寄存器堆）</h5><ul><li>用具有写使能的寄存器实现，寄存器总数为 32个，应具有<strong>异步复位</strong>功能。</li><li><strong>0 号寄存器</strong>的值始终保持为0。其他寄存器<strong>初始值（复位后）均为0</strong>，无需专门设置。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">clk</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">时钟信号</td><td style="text-align: center;">内置</td></tr><tr class="even"><td style="text-align: center;">rst</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">异步复位信号</td><td style="text-align: center;">顶层输入</td></tr><tr class="odd"><td style="text-align: center;">WE/RegWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">写使能信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">RegAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">GRF 5 位写入地址</td><td style="text-align: center;">Instr</td></tr><tr class="odd"><td style="text-align: center;">WD/RegData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位写入数据</td><td style="text-align: center;">ALU/DM/Instr</td></tr><tr class="even"><td style="text-align: center;">A1</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">Instr</td></tr><tr class="odd"><td style="text-align: center;">A2</td><td style="text-align: center;">in</td><td style="text-align: center;">5</td><td style="text-align: center;">读出数据的寄存器编号</td><td style="text-align: center;">Instr</td></tr><tr class="even"><td style="text-align: center;">RD</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">RD2</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">GRF 32 位读出数据</td><td style="text-align: center;">ALU</td></tr></tbody></table><h5 id="alu算术逻辑单元">ALU（算术逻辑单元）</h5><p>？比较按无符号还是有符号？</p><ul><li>提供 32 位加、减、或运算及大小比较功能。</li><li>加减法按无符号处理（不考虑溢出）。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">op</td><td style="text-align: center;">in</td><td style="text-align: center;">2</td><td style="text-align: center;">功能选择</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">a</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数1</td><td style="text-align: center;">GRF/Instr</td></tr><tr class="odd"><td style="text-align: center;">b</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">操作数2</td><td style="text-align: center;">GRF/Instr</td></tr><tr class="even"><td style="text-align: center;">out</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">结果</td><td style="text-align: center;">GRF/DM</td></tr></tbody></table><h5 id="dm数据存储器">DM（数据存储器）</h5><ul><li>使用 RAM 实现，容量为 3072 ×32bit，应具有<strong>异步复位</strong>功能，复位值为 0x00000000。</li><li><strong>起始地址：0x00000000</strong>。</li><li>地址范围：0x00000000 ~ 0x00002FFF。</li><li>RAM 应使用双端口模式，即设置 RAM 的 <strong>Data Interface</strong>属性为 <strong>Separate load and store ports</strong>。</li></ul><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th><th style="text-align: center;">来源/去向</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">in</td><td style="text-align: center;">1</td><td style="text-align: center;">DM 写入控制信号</td><td style="text-align: center;">Control</td></tr><tr class="even"><td style="text-align: center;">MemAddr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入地址</td><td style="text-align: center;">ALU</td></tr><tr class="odd"><td style="text-align: center;">MemData</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位写入数据</td><td style="text-align: center;">GRF</td></tr><tr class="even"><td style="text-align: center;">MemData</td><td style="text-align: center;">out</td><td style="text-align: center;">32</td><td style="text-align: center;">DM 32 位输出数据</td><td style="text-align: center;">GRF</td></tr></tbody></table><h5 id="ext扩展单元">EXT（扩展单元）</h5><ul><li>可以使用 Logisim 内置的 Bit Extender。</li></ul><h5 id="controller控制器">Controller（控制器）</h5><ul><li>使用与或门阵列构造控制信号的具体方法见后文叙述。</li><li>也可以通过其它方式构造控制信号，同学们可以自行探索。</li></ul><h6 id="指令解读">指令解读</h6><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">31-26</th><th style="text-align: center;">25-21</th><th style="text-align: center;">20-16</th><th style="text-align: center;">15-11</th><th style="text-align: center;">10-6</th><th style="text-align: center;">5-0</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">add</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100000</td><td style="text-align: center;">rd=rs+rt</td></tr><tr class="even"><td style="text-align: center;">sub</td><td style="text-align: center;">000000</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">rd</td><td style="text-align: center;">00000</td><td style="text-align: center;">100010</td><td style="text-align: center;">rd=rs-rt</td></tr><tr class="odd"><td style="text-align: center;">ori</td><td style="text-align: center;">001101</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=rs|im</td></tr><tr class="even"><td style="text-align: center;">lw</td><td style="text-align: center;">100011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">rt=mem(base+of)</td></tr><tr class="odd"><td style="text-align: center;">sw</td><td style="text-align: center;">101011</td><td style="text-align: center;">base</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">mem(base+of)=rt</td></tr><tr class="even"><td style="text-align: center;">beq</td><td style="text-align: center;">000100</td><td style="text-align: center;">rs</td><td style="text-align: center;">rt</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">offset</td><td style="text-align: center;">PC+=4+of00?</td></tr><tr class="odd"><td style="text-align: center;">lui</td><td style="text-align: center;">001111</td><td style="text-align: center;">00000</td><td style="text-align: center;">rt</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">im</td><td style="text-align: center;">rt=im(0*16)</td></tr></tbody></table><h6 id="控制器">控制器</h6><table><thead><tr class="header"><th style="text-align: center;">变量</th><th style="text-align: center;">方向</th><th style="text-align: center;">位宽</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Instr</td><td style="text-align: center;">in</td><td style="text-align: center;">32</td><td style="text-align: center;">指令机器码</td></tr><tr class="even"><td style="text-align: center;">ctrl</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">PC，控制是否beq</td></tr><tr class="odd"><td style="text-align: center;">WE</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，写使能信号</td></tr><tr class="even"><td style="text-align: center;">GRF_op1</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">GRF，控制写入地址来源（0,rd）</td></tr><tr class="odd"><td style="text-align: center;">GRF_op2</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">GRF，控制写入数据来源（0,ALU,1,DM）</td></tr><tr class="even"><td style="text-align: center;">op</td><td style="text-align: center;">out</td><td style="text-align: center;">2</td><td style="text-align: center;">ALU，运算选择</td></tr><tr class="odd"><td style="text-align: center;">ALU_op</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><tdstyle="text-align: center;">ALU，控制运算数来源（0,rt,1,im,2,of）</td></tr><tr class="even"><td style="text-align: center;">MemWrite</td><td style="text-align: center;">out</td><td style="text-align: center;">1</td><td style="text-align: center;">DM，写入控制信号</td></tr></tbody></table><h4 id="思考题">思考题</h4><ol type="1"><li><p>上面我们介绍了通过 FSM 理解单周期 CPU的基本方法。请大家指出单周期 CPU所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p><p>状态存储：GRF、DM、IFU</p><p>状态转移：ALU、Controller、EXT</p></li><li><p>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p><p>合理，IM存储指令，一般无需、也不应在执行过程中修改，因此使用ROM；DM需要读写，因此使用RAM；GRF所需存储规模较小，而且某些指令需要同时执行存储、读出行为，因此每一寄存器用Register较为合理。</p></li><li><p>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p><p>设计了指令解读模块，将32位机器码按字段转为相应的值如OPcode、rt、offset等。思路就是利用splitter，只是将其封装为模块。</p></li><li><p>事实上，实现 <code>nop</code>空指令，我们并不需要将它加入控制信号真值表，为什么？</p><p>输入nop指令时，Conrtoller内部的与门阵列输出信号全为0，GRF、DM的写信号为0，因此相当于没进行任何操作。</p></li><li><p>阅读 Pre 的 <ahref="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS指令集及汇编语言”</a>一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p><p>指令覆盖情况：缺少sub指令</p><p>单一指令覆盖：add缺少 <code>intmax</code>，ori缺少中间值，lui缺少0，lw、sw偏移量没考虑负数，beq跳转范围应包含前后。</p></li></ol><h4 id="测试方案">测试方案</h4><h5 id="机器码转指令的">机器码转指令的</h5><p>运行C语言代码（code_instruction.c），1为从文件输入，输出到文件；2为单个指令翻译</p><h5 id="自动生成数据点的c语言代码">自动生成数据点的C语言代码</h5><p>待开发，目前只有手敲代码（</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.data<br>.space 0x3000<br>.text<br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,2<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,3<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,4<br>ori <span class="hljs-variable">$5</span>,<span class="hljs-variable">$0</span>,5<br>ori <span class="hljs-variable">$6</span>,<span class="hljs-variable">$0</span>,6<br>ori <span class="hljs-variable">$7</span>,<span class="hljs-variable">$0</span>,7<br>ori <span class="hljs-variable">$8</span>,<span class="hljs-variable">$0</span>,8<br>ori <span class="hljs-variable">$9</span>,<span class="hljs-variable">$0</span>,9<br>ori <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,10<br>ori <span class="hljs-variable">$11</span>,<span class="hljs-variable">$0</span>,11<br>ori <span class="hljs-variable">$12</span>,<span class="hljs-variable">$0</span>,12<br>ori <span class="hljs-variable">$13</span>,<span class="hljs-variable">$0</span>,13<br>ori <span class="hljs-variable">$14</span>,<span class="hljs-variable">$0</span>,14<br>ori <span class="hljs-variable">$15</span>,<span class="hljs-variable">$0</span>,15<br>ori <span class="hljs-variable">$16</span>,<span class="hljs-variable">$0</span>,16<br>ori <span class="hljs-variable">$17</span>,<span class="hljs-variable">$0</span>,17<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$0</span>,18<br>ori <span class="hljs-variable">$19</span>,<span class="hljs-variable">$0</span>,19<br>ori <span class="hljs-variable">$20</span>,<span class="hljs-variable">$0</span>,20<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$0</span>,21<br>ori <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,22<br>ori <span class="hljs-variable">$23</span>,<span class="hljs-variable">$0</span>,23<br>ori <span class="hljs-variable">$24</span>,<span class="hljs-variable">$0</span>,24<br>ori <span class="hljs-variable">$25</span>,<span class="hljs-variable">$0</span>,25<br>ori <span class="hljs-variable">$26</span>,<span class="hljs-variable">$0</span>,26<br>ori <span class="hljs-variable">$27</span>,<span class="hljs-variable">$0</span>,27<br>ori <span class="hljs-variable">$28</span>,<span class="hljs-variable">$0</span>,28<br>ori <span class="hljs-variable">$29</span>,<span class="hljs-variable">$0</span>,29<br>ori <span class="hljs-variable">$30</span>,<span class="hljs-variable">$0</span>,30<br>ori <span class="hljs-variable">$31</span>,<span class="hljs-variable">$0</span>,31<br><br><br>ori <span class="hljs-variable">$0</span>,<span class="hljs-variable">$0</span>,1#<span class="hljs-variable">$0</span>应始终为0<br>ori <span class="hljs-variable">$2</span>,<span class="hljs-variable">$0</span>,65535<br>ori <span class="hljs-variable">$3</span>,<span class="hljs-variable">$0</span>,0<br>ori <span class="hljs-variable">$4</span>,<span class="hljs-variable">$0</span>,12<br>lui <span class="hljs-variable">$5</span>,65535<br>lui <span class="hljs-variable">$6</span>,0<br>lui <span class="hljs-variable">$7</span>,8<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$8</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$2</span>#-1<br>lui <span class="hljs-variable">$9</span>,32767<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$9</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$2</span>#intmax<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$9</span>,<span class="hljs-variable">$8</span><br>sub <span class="hljs-variable">$10</span>,<span class="hljs-variable">$8</span>,<span class="hljs-variable">$9</span>#-intmax-1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$10</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$10</span><br>sub <span class="hljs-variable">$11</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$4</span>#65523<br>sub <span class="hljs-variable">$12</span>,<span class="hljs-variable">$4</span>,<span class="hljs-variable">$2</span>#-65523<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$13</span>,<span class="hljs-variable">$11</span>,<span class="hljs-variable">$12</span>#0<br>sub <span class="hljs-variable">$14</span>,<span class="hljs-variable">$5</span>,<span class="hljs-variable">$5</span>#0<br><br>lui <span class="hljs-variable">$18</span>,0<br>ori <span class="hljs-variable">$18</span>,<span class="hljs-variable">$18</span>,0x2ffc<br>sw <span class="hljs-variable">$10</span>,(<span class="hljs-variable">$18</span>)<br>sw <span class="hljs-variable">$11</span>,12280(<span class="hljs-variable">$0</span>)<br>sw <span class="hljs-variable">$12</span>,-4(<span class="hljs-variable">$4</span>)#8<br>lw <span class="hljs-variable">$15</span>,8(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$12</span>,-65533<br>lw <span class="hljs-variable">$16</span>,12284(<span class="hljs-variable">$0</span>)#<span class="hljs-variable">$10</span>,-intmax-1<br>lw <span class="hljs-variable">$17</span>,12280(<span class="hljs-variable">$0</span>)#11,65523<br><br>loop:<br>lui <span class="hljs-variable">$21</span>,0<br>ori <span class="hljs-variable">$21</span>,<span class="hljs-variable">$21</span>,1<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$19</span>,<span class="hljs-variable">$19</span>,<span class="hljs-variable">$21</span><br>beq <span class="hljs-variable">$19</span>,<span class="hljs-variable">$20</span>,loop#<span class="hljs-variable">$19</span>=21跳出<br><br>sub <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span>#<span class="hljs-variable">$22</span>=-20<br>loop2:<br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,loop2<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$22</span>,<span class="hljs-variable">$0</span>,<span class="hljs-variable">$20</span><br>beq <span class="hljs-variable">$22</span>,<span class="hljs-variable">$20</span>,end<br>nop<br>end:<br><span class="hljs-built_in">add</span> <span class="hljs-variable">$23</span>,<span class="hljs-variable">$23</span>,<span class="hljs-variable">$21</span><br></code></pre></td></tr></table></figure><h5 id="命令行自动化测试">命令行自动化测试</h5><p>文件夹下：logisim的jar包、测试电路文件</p><p>文件夹打开命令行输入：<code>java -jar logisim-generic-2.7.1.jar 单周期CPU.circ -tty table &gt; result.txt</code></p><p>运行C语言代码（CPU_test.c），依次输出32个寄存器存储数值，可与MARS比较</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组P7教程</title>
    <link href="/2024/01/23/%E8%AE%A1%E7%BB%84P7%E6%95%99%E7%A8%8B/"/>
    <url>/2024/01/23/%E8%AE%A1%E7%BB%84P7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统">计算机系统</h1><h2 id="mips-微系统">MIPS 微系统</h2><p>当我们完成 P6 以后，可以说我们已经完成了一个复杂度相当高的 CPU，这个CPU可以利用流水线技术并行指令，并按照指令的内容完成计算，修改寄存器中的值。那么是不是完成这个CPU 就是掌握计算机组成这门课程的全貌了呢？我们说并不是这样。</p><p>CPU 的全称是 Central ProcessingUnit，也就是“中央处理器”。也就是说，CPU的功能就是数据的“加工与处理”。而计算机系统不仅要完成数据的加工处理，还要完成诸如输入，输出，存储，网络等多种功能，也就是说，<strong>“CPU不等价于计算机系统”</strong>。在 P7我们要完成的任务，就是实现一个简单的计算机系统，也就是“MIPS微系统”。</p><h2 id="外设">外设</h2><p>外设即外部设备，他们可以看做是与 CPU地位平等的一组设备。在计算机系统中，CPU负责数据的加工处理，而外设则负责输入（鼠标，键盘），输出（显示屏，扬声器），存储（硬盘，U盘），网络（网卡）等。我们的 MIPS 微系统中包括的外设主要有 3种，即计时器、存储器、中断发生器：</p><ul><li>计时器（Timer）：计算机系统中的计时部件，可以按照配置定时地产生时钟中断。</li><li>存储器（Memory）：计算机系统中的存储部件，用于存储指令和数据。我们在P6 的时候已经接触过了。</li><li>中断发生器（InterruptGenerator）：抽象的计算机系统外设，会随机的产生外部中断信号，产生的中断信号在CPU 响应前会持续置高。</li></ul><p>正如 CPU 一样，这些外设也可以用 Verilog语言对其进行建模。最终我们整个微系统都可以用 Verilog语言建模。为了让同学们在 P7有一个更好的实现体验，我们在这一章会只进行设计概念上的介绍，而在下一章介绍具体的实现规格和细节。希望同学们在这一章先熟悉一些系统设计的基本理念，然后在下一章具体的实现中去进一步体悟。</p><h1 id="支持异常处理流的-cpu">支持异常处理流的 CPU</h1><h2 id="之前的-cpu">之前的 CPU</h2><p>在 P6 我们完成的 CPU已经具有了很好的功能，他可以顺序的执行指令（有时会发生跳转）。那么我们考虑，这样的一个CPU 还有哪些缺陷，我们认为主要有两点：</p><ul><li>此时的 CPU 是没有办法处理错误的指令的。例如 <code>add</code>指令，当两个源操作数相加发生溢出的时候，按照规范这是<strong>异常</strong>的情况。我们在P6 的时候默认“溢出加”，会得到一个错误的答案。我们会在 P7对这个问题进行解决。</li><li>此时的 CPU 是没有办法实现与外设复杂的交互的，当计时器向 CPU传递一个信号的时候，CPU是没有办法立刻响应这个信号并做出相应的处理的。</li></ul><p>直观地说，P6 设计出的 CPU运行时的可靠性和完备性都不令人满意。如果运行在其上的程序有一些 bug，CPU既不能检测到这些 bug 并向使用者报告，也不能做出保证正确性的处理，CPU无法满足现实场景下的多种功能。</p><h2 id="异常处理流">异常处理流</h2><p>异常处理流指的是，CPU在执行程序的指令的时候，会发生一些“事件”，改变程序的原有流向，让<code>PC</code> 跳转到特定的地址。</p><p>异常处理流可以很好的解决上面的问题。当指令执行错误时，可以产生一个“事件”。那么CPU就会跳转到一个处理这种执行错误的程序上执行，在处理结束后再跳转回原来的程序（不一定是“事件”来临时的地址）。对于外设的信号，我们可以将其视为一个“事件”，当“事件”来临时，CPU会跳转到一个响应这个“事件”的程序处进行响应，在处理结束后再次跳转回原来的程序。</p><p>异常处理流可以用下面的这张图直观地表示，可以将其理解为<strong>“发生位置不确定的过程调用”</strong>。</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/theory/assets/stream.svg"alt="image-20220626094859732" /><figcaption aria-hidden="true">image-20220626094859732</figcaption></figure><h2 id="概念辨析">概念辨析</h2><p>为了降低同学们实现的困难，我们参照《See MIPS RunLinux》制定了以下概念规范。需要强调的是，这些概念的名字仅在 P7的实现中有效。不同的参考资料对于相同的事物可能会给出不同的概念名称，所以可能指导书会与教材、参考资料或者授课PPT 的概念存在冲突。</p><p><strong>在 P7实验中请以指导书为准，在其他场景中请具体分析。</strong></p><p>我们之前提到的“事件”一共有两种：</p><table><thead><tr class="header"><th style="text-align: left;">概念</th><th style="text-align: left;">定义</th><th style="text-align: left;">举例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">内部异常</td><td style="text-align: left;">由于指令执行错误导致的“事件”</td><td style="text-align: left;">加法溢出，除法除零等</td></tr><tr class="even"><td style="text-align: left;">外部中断</td><td style="text-align: left;">由于外部设备信号导致的“事件”</td><td style="text-align: left;">计时器信号，键盘输入等</td></tr></tbody></table><p>因为这两类“事件”的处理具有一定的共同性，所以我们统一称他们为“异常”，如下图所示：</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/theory/assets/exception.png"alt="image-20220626105259107" /><figcaption aria-hidden="true">image-20220626105259107</figcaption></figure><p>为了响应异常，CPU 会自动跳转到某一特定的地点（将 PC修改为特定值），然后进行异常处理。这里进行异常处理的程序叫做“异常处理程序”，是软件（在计组中表现为一段汇编代码），是不属于MIPS 微系统内的。在课程平台的自动测试中，评测数据将包含handler，但是我们仍要编写它来进行本地测试。</p><p>思考题</p><p>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>思考题</p><p>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><h1 id="软硬件接口">软硬件接口</h1><h2 id="接口的理解">接口的理解</h2><p>正如前面所描述的，在 P7 要完成的不再是 CPU 这个单独的功能模块，而是CPU与多个外设组成的计算机系统，各个模块之间需要进行合作。那么应该如何进行合作呢？</p><p>合作的前提就是“约定”。参与合作的人必须对其他人给出可以让自己完成功能的“约定”。比如说在“老师和学生上课”这个合作关系下，老师需要给出自己的上课时间和下课时间。如果老师并不告诉学生这个信息，这个合作就是进行不下去的。在计算机系统里，我们称这种“约定”为“接口”。</p><h2 id="接口的设计">接口的设计</h2><p>接口设计重要的一个方向就是要<strong>足够简洁</strong>。依然用“老师和学生上课”的例子，“我在8:00 上课，你们需要在这个时刻到达” 和 “我在 7:30 到达食堂吃早餐，然后吃20 分钟烧麦，10 分钟后到达教室给你们上课，你们需要在这个时刻到达”两种“接口”都是可以让学生正常上课，但是学生肯定会更喜欢第一种，因为这种接口的设计简洁，学生并不需要了解老师吃早饭的细节。</p><p>那么是什么带来了这种简洁性呢？并不是因为第一个老师不吃早饭导致的，两个老师都是吃早饭的，但是第一个老师贴心的计算出了自己到达教室的时间，而第二个老师将自己早上的所有细节都暴露了出去。</p><p>同时，这种简洁性并非是功能元件本身的简洁性导致的，而是功能元件在向外界提供接口的时候，隐藏了自己内部的复杂的实现细节，只提供给外界一种简单的接口。这就是著名的<strong>“高内聚，低耦合”</strong>原理。</p><p>这个“隐藏内部实现细节，向外部提供接口”的行为也叫做<strong>“封装”</strong>。需要强调的是，为了实现接口的简洁性，在模块的内部需要进行一些实现。也就是说，为了实现接口的简洁性，需要在模块内部付出额外的努力。</p><h2 id="外设的接口设计-系统桥">外设的接口设计-系统桥</h2><p>外设的种类是无穷无尽的，而 CPU的指令集却是有限的。我们并不能总是因为新加入了一个外设，就专门为这个外设增加新的CPU 指令。我们希望的是，尽管外设多种多样，但是 CPU可以用统一的方法访问它们。为了实现这个目标，我们设计了系统桥。</p><p>系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设。系统桥统一且简化了CPU 的对外接口，CPU不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p><p>在 P7 中，CPU 对于 DM、Timer 和 InterruptGenerator的访问都是需要通过系统桥的。</p><h2 id="cpu-的接口设计-封装成单周期-cpu">CPU 的接口设计-封装成单周期CPU</h2><p>P6 的 CPU 是一个五级流水的设计。也就是说，同一时刻，可能会运行 1~5条指令，这取决于是否阻塞等条件。这些具体的 CPU实现细节，软件是并不关心的。当我们编写汇编语言的时候，是不需要考虑我们的CPU是否会发生阻塞，是否会有转发等实现细节的。而软件之所以可以这么轻松，是因为CPU 实现了一个封装，即<strong>“将复杂的多级流水线 CPU封装成了简单的单周期 CPU”</strong>。在计算机系统中，将 CPU封装成单周期是理解 P7 任务的关键。</p><h1 id="任务清单">任务清单</h1><p>P7 与之前的 project相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7需要的事宜：</p><table><thead><tr class="header"><th style="text-align: left;">任务</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">计时器</td><tdstyle="text-align: left;">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr class="even"><td style="text-align: left;">系统桥</td><td style="text-align: left;">为 CPU提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr class="odd"><td style="text-align: left;">协处理器 CP0</td><td style="text-align: left;">设置 CPU 的异常处理功能，反馈 CPU的异常信息，需要按规格自行实现。</td></tr><tr class="even"><td style="text-align: left;">内部异常检测与流水</td><td style="text-align: left;">CPU需要具有可以检测内部指令执行错误的能力。</td></tr><tr class="odd"><td style="text-align: left;">外部中断响应</td><td style="text-align: left;">CPU需要具有初步响应外部中断信号的能力。</td></tr><tr class="even"><td style="text-align: left;">异常处理指令</td><tdstyle="text-align: left;">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr class="odd"><td style="text-align: left;">单周期 CPU 的封装</td><td style="text-align: left;">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr class="even"><td style="text-align: left;">异常处理程序</td><td style="text-align: left;">利用 MARS编写简单的异常处理程序用于测试。</td></tr></tbody></table><p>最后的架构图如图所示：</p><figure><imgsrc="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/structure.svg"alt="structure" /><figcaption aria-hidden="true">structure</figcaption></figure><h1 id="外设的实现">外设的实现</h1><h2 id="计时器">计时器</h2><p>在 P7 这个简单的 MIPS微系统中，计时器是一种外部设备，其主要功能就是<strong>根据设定的时间来定时产生中断信号</strong>，是我们系统的中断来源之一。</p><p>在今年的教程中，我们向同学们提供已实现的计时器 <ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/P7_standard_timer_2019.v">Verilog源代码</a>。 timer 内部需要定义多个程序员可见寄存器，如<strong>CTRL</strong>、<strong>PRESET</strong>等，也需要定义若干用于完成功能的内部寄存器（程序员不可见），详情请参考设计文档：<ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/COCO定时器设计规范-1.0.0.4.pdf">CO定时器设计规范-1.0.0.4.pdf</a>。</p><h2 id="中断发生器">中断发生器</h2><p>这是课程组抽象简化现实中外设后得到的一种外设，会在不确定的时刻产生一个中断信号（就好像电脑并不知道谁会在什么时候敲击键盘一样），并持续置高。直到微系统做出响应，才变回低位。</p><p>对中断发生器的响应是通过系统桥来实现的，通过 <code>store</code>类指令访问地址 <code>0x7F20</code>，就可以达到响应中断的目的。</p><p>中断发生器的实现并不需要同学们来完成，不同的中断发生器（中断信号产生的规则不一样）都是在测试的tb 上实现的。同学们只需要确保自己的 P7微系统，具有以下两个能力，就可以满足这个方面的测试：</p><ul><li>微系统可以通过外部端口接受外部中断信号（在计时器部分已经实现了）。</li><li>微系统可以通过访问地址 <code>0x7F20</code> 的 <code>store</code>类指令，改变对应的微系统输出信号（<code>m_int_addr</code>，<code>m_int_byteen</code>），即系统桥实现正确。</li></ul><h2 id="系统桥">系统桥</h2><p>怎样使外设与 CPU 进行沟通呢？采用划分地址空间的办法后，与外设沟通和与DM 沟通的方式类似，通过一个 CPU视图下的内存地址，读写相应数据即可达到与外设沟通的目的。而这个所谓的内存，在外设中，实际上只是若干寄存器。系统桥传入对地址的访问请求后，我们通过系统桥内部的转换代码，将请求转变为对相应寄存器的读写操作。</p><p>下表是规定的地址空间设计，测试程序也将以此为根据编写。需要注意的是，P7与《See MIPS Run Linux》和 PPT 中给出的 MIPS 系统地址范围是不同的，而与MARS 相同，这主要是为了能够让你能更好的验证设计。</p><table><thead><tr class="header"><th style="text-align: center;">条目</th><th style="text-align: center;">地址或地址范围</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">数据存储器</td><td style="text-align: center;">0x0000_0000∼0x0000_2FFF</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">指令存储器</td><td style="text-align: center;">0x0000_3000∼0x0000_6FFF</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">PC 初始值</td><td style="text-align: center;">0x0000_3000</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">异常处理程序入口地址</td><td style="text-align: center;">0x0000_4180</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">计时器 0 寄存器地址</td><td style="text-align: center;">0x0000_7F00∼0x0000_7F0B</td><td style="text-align: center;">计时器 0 的 3 个寄存器</td></tr><tr class="even"><td style="text-align: center;">计时器 1 寄存器地址</td><td style="text-align: center;">0x0000_7F10∼0x0000_7F1B</td><td style="text-align: center;">计时器 1 的 3 个寄存器</td></tr><tr class="odd"><td style="text-align: center;">中断发生器响应地址</td><td style="text-align: center;">0x0000_7F20∼0x0000_7F23</td><td style="text-align: center;"></td></tr></tbody></table><p>注意实现系统桥时，其必须作为独立 module 来实现，不能包含在 CPU内部。关于系统桥的具体编写，请大家参考该文件 <ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/L15-支持IO.pdf">L15-支持IO.pdf</a>。</p><p>思考题</p><p>为何与外设通信需要 Bridge？</p><p>思考题</p><p>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><h1 id="异常处理流的实现">异常处理流的实现</h1><h2 id="cp0-的寄存器">CP0 的寄存器</h2><p>CP0 协处理器是 P7新引入的功能模块，我们需要用这个模块完成两个主要功能，一个是对异常进行配置，一个是记录异常的信息。CP0有很多个寄存器用来配置或者记录，我们只需要实现其中的几个，如下所示：</p><table><thead><tr class="header"><th style="text-align: left;">寄存器</th><th style="text-align: left;">编号</th><th style="text-align: left;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">SR</td><td style="text-align: left;">12</td><td style="text-align: left;">配置异常的功能。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">13</td><td style="text-align: left;">记录异常发生的原因和情况。</td></tr><tr class="odd"><td style="text-align: left;">EPC</td><td style="text-align: left;">14</td><td style="text-align: left;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><p>每个寄存器都是 32 位的，我们只需要其中的几位，列表如下：</p><table><thead><tr class="header"><th style="text-align: left;">寄存器</th><th style="text-align: left;">功能域</th><th style="text-align: left;">位域</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">IM（Interrupt Mask）</td><td style="text-align: left;">15:10</td><td style="text-align: left;">分别对应六个外部中断，相应位置 1表示允许中断，置 0 表示禁止中断。这是一个被动的功能，只能通过<code>mtc0</code>这个指令修改，通过修改这个功能域，我们可以屏蔽一些中断。</td></tr><tr class="even"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">EXL（Exception Level）</td><td style="text-align: left;">1</td><tdstyle="text-align: left;">任何异常发生时置位，这会强制进入核心态（也就是进入异常处理程序）并禁止中断。</td></tr><tr class="odd"><td style="text-align: left;">SR（State Register）</td><td style="text-align: left;">IE（Interrupt Enable）</td><td style="text-align: left;">0</td><td style="text-align: left;">全局中断使能，该位置 1 表示允许中断，置 0表示禁止中断。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">BD（Branch Delay）</td><td style="text-align: left;">31</td><td style="text-align: left;">当该位置 1 的时候，EPC指向当前指令的前一条指令（一定为跳转），否则指向当前指令。</td></tr><tr class="odd"><td style="text-align: left;">Cause</td><td style="text-align: left;">IP（Interrupt Pending）</td><td style="text-align: left;">15:10</td><td style="text-align: left;">为 6 位待决的中断位，分别对应 6个外部中断，相应位置 1 表示有中断，置 0表示无中断，将会每个周期被修改一次，修改的内容来自计时器和外部中断。</td></tr><tr class="even"><td style="text-align: left;">Cause</td><td style="text-align: left;">ExcCode</td><td style="text-align: left;">6:2</td><td style="text-align: left;">异常编码，记录当前发生的是什么异常。</td></tr><tr class="odd"><td style="text-align: left;">EPC</td><td style="text-align: left;">-</td><td style="text-align: left;">-</td><td style="text-align: left;">记录异常处理结束后需要返回的 PC。</td></tr></tbody></table><p>当发生异常的时候，CPU 会自动将异常信息写入 CP0 的相应寄存器（如<code>Cause</code> 和<code>EPC</code>）。异常处理程序会访问相应寄存器，来了解异常的信息以进行异常处理。</p><p>同学们可以按规范自行设计 CP0，一个参考的 CP0 的端口声明如下：</p><table><thead><tr class="header"><th style="text-align: left;">端口</th><th style="text-align: left;">方向</th><th style="text-align: left;">位数</th><th style="text-align: left;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">clk</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">时钟信号。</td></tr><tr class="even"><td style="text-align: left;">reset</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">复位信号。</td></tr><tr class="odd"><td style="text-align: left;">en</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">写使能信号。</td></tr><tr class="even"><td style="text-align: left;">CP0Add</td><td style="text-align: left;">IN</td><td style="text-align: left;">5</td><td style="text-align: left;">寄存器地址。</td></tr><tr class="odd"><td style="text-align: left;">CP0In</td><td style="text-align: left;">IN</td><td style="text-align: left;">32</td><td style="text-align: left;">CP0 写入数据。</td></tr><tr class="even"><td style="text-align: left;">CP0Out</td><td style="text-align: left;">OUT</td><td style="text-align: left;">32</td><td style="text-align: left;">CP0 读出数据。</td></tr><tr class="odd"><td style="text-align: left;">VPC</td><td style="text-align: left;">IN</td><td style="text-align: left;">32</td><td style="text-align: left;">受害 PC。</td></tr><tr class="even"><td style="text-align: left;">BDIn</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">是否是延迟槽指令。</td></tr><tr class="odd"><td style="text-align: left;">ExcCodeIn</td><td style="text-align: left;">IN</td><td style="text-align: left;">5</td><td style="text-align: left;">记录异常类型。</td></tr><tr class="even"><td style="text-align: left;">HWInt</td><td style="text-align: left;">IN</td><td style="text-align: left;">6</td><td style="text-align: left;">输入中断信号。</td></tr><tr class="odd"><td style="text-align: left;">EXLClr</td><td style="text-align: left;">IN</td><td style="text-align: left;">1</td><td style="text-align: left;">用来复位 EXL。</td></tr><tr class="even"><td style="text-align: left;">EPCOut</td><td style="text-align: left;">OUT</td><td style="text-align: left;">32</td><td style="text-align: left;">EPC 的值。</td></tr><tr class="odd"><td style="text-align: left;">Req</td><td style="text-align: left;">OUT</td><td style="text-align: left;">1</td><td style="text-align: left;">进入处理程序请求。</td></tr></tbody></table><h2 id="异常码">异常码</h2><p>在异常处理程序中，我们需要通过访问 <code>Cause</code> 寄存器的<code>ExcCode</code> 域来获得异常的原因，在 P7中我们需要实现的异常有这样几种（除此之外，比较常见的还有陷入，断点调试等）：</p><p><strong>ExcCode的编码必须遵守规范，不然在评测的时候可能会出现问题</strong>。</p><table><thead><tr class="header"><th style="text-align: left;">异常与中断码</th><th style="text-align: left;">助记符与名称</th><th style="text-align: left;">指令与指令类型</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;"><code>Int</code> （外部中断）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">中断请求，来源于计时器与外部中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;"><code>AdEL</code> （取指异常）</td><td style="text-align: left;">所有指令</td><td style="text-align: left;">PC 地址未字对齐。</td></tr><tr class="odd"><td style="text-align: left;">PC 地址超过<code>0x3000 ~ 0x6ffc</code>。</td><td style="text-align: left;"></td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>AdEL</code> （取数异常）</td><td style="text-align: left;"><code>lw</code></td><td style="text-align: left;">取数地址未与 4 字节对齐。</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>lh</code></td><td style="text-align: left;">取数地址未与 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>lh</code>, <code>lb</code></td><td style="text-align: left;">取 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">计算地址时加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">load 型指令</td><td style="text-align: left;">取数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;"><code>AdES</code> （存数异常）</td><td style="text-align: left;"><code>sw</code></td><td style="text-align: left;">存数地址未 4 字节对齐。</td></tr><tr class="even"><td style="text-align: left;"><code>sh</code></td><td style="text-align: left;">存数地址未 2 字节对齐。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>sh</code>, <code>sb</code></td><td style="text-align: left;">存 Timer 寄存器的值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">计算地址加法溢出。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">向计时器的 Count 寄存器存值。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;">store 型指令</td><td style="text-align: left;">存数地址超出DM、Timer0、Timer1、中断发生器的范围。</td><td style="text-align: left;"></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">8</td><td style="text-align: left;"><code>Syscall</code> （系统调用）</td><td style="text-align: left;"><code>syscall</code></td><td style="text-align: left;">系统调用。</td></tr><tr class="even"><td style="text-align: left;">10</td><td style="text-align: left;"><code>RI</code>（未知指令）</td><td style="text-align: left;">-</td><td style="text-align: left;">未知的指令码。</td></tr><tr class="odd"><td style="text-align: left;">12</td><td style="text-align: left;"><code>Ov</code>（溢出异常）</td><td style="text-align: left;"><code>add</code>, <code>addi</code>,<code>sub</code></td><td style="text-align: left;">算术溢出。</td></tr></tbody></table><h2 id="参考资料">参考资料</h2><p>CP0 设计及其相关指令的实现，以及硬软件在中断处理上的协同是 P7中最有挑战性的部分。仅阅读教程中的简要介绍远远不够，因此课程组放出一些推荐阅读的资料，希望同学能加以研究，尝试去理解其中的思路。</p><p>推荐资料列表：</p><ol type="1"><li><ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/L13-MIPS系统结构-V1.pdf">L13-MIPS系统结构-V1.pdf</a></li><li><ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/See_MIPS_Run_Linux.pdf">《SeeMIPS Run Linux》中相关章节</a></li><li>《计算机组成与设计：硬件/软件接口》中相关章节</li><li>Google / Bing 等搜索引擎</li><li>讨论区 P7 答疑帖</li></ol><h1 id="封装成单周期-cpu">封装成单周期 CPU</h1><h2 id="宏观-pc">宏观 PC</h2><p>我们的需求是要让我们的 CPU 从外部看上去是一个单周期的CPU（具体的原因在前一章有阐述）。但是实际上，我们的 CPU是一个五级流水的并行 CPU。所以本质上我们要实现一套机制，来让我们的 CPU满足这个需求。</p><p>为了检验同学们的实现效果，我们引入宏观 PC 这一概念。宏观 PC 表示整个CPU“宏观”运行指令所对应的PC地址。所谓“宏观”指令，表示该指令之前的所有指令序列对CPU 的更新已完成，该指令及其之后的指令序列对 CPU的更新未完成。具体实现上，宏观 PC 通常上是以某一个流水级 PC作为界限，作为输出端口输出出来。这个流水级一般是你 CP0所在的流水级。</p><h2 id="精确异常">精确异常</h2><p>对于异常，我们能明确指出是哪条指令导致了异常，并称这条指令为<strong>异常受害指令</strong>。精确异常的特性是，在异常受害指令<strong>前面的所有指令都执行完毕</strong>，而<strong>受害指令及其后续指令都像从来没有开始</strong>（准确说是当异常处理结束后重新执行这些指令，与未发生异常时执行这些指令的效果一样）。这样的处理思路使得从使用者的角度来看，CPU 执行异常处理是顺序执行的，从而隐藏了流水线设计的细节。</p><h3 id="清空流水线">清空流水线</h3><p>为了达到精确异常的效果，我们需要在异常发生的时候清空流水线，以避免宏观PC 之后的指令被执行。清空流水线一方面是要清空宏观 PC之后的指令所在的流水线寄存器，即插入 <code>nop</code>。</p><p>在了解了这点以后，我们可以总结一下我们对于流水线寄存器的控制。流水线寄存器需要接受多种控制信号，如复位信号，阻塞信号，刷新信号，请求信号。所以有可能同时会有多个信号控制同一个寄存器，那么寄存器该展现怎样的行为呢？这是一个需要考虑的事情。</p><p>例如在 D 级处于被阻塞状态时发生 <code>Req</code>，那么 D级流水线寄存器就应该立刻被清空，而不是保持原值；正在 <code>Req</code>的时候发生<code>reset</code>，那么 CPU应该立刻复位，而不是进行异常处理。此处处理不当可能造成评测时缺少中断的情况。实现上，可按如下优先级：</p><table><thead><tr class="header"><th style="text-align: left;">信号</th><th style="text-align: left;">优先级</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">reset</td><td style="text-align: left;">最高，复位大于一切。</td></tr><tr class="even"><td style="text-align: left;">Req</td><td style="text-align: left;">次高，中断请求比内部阻塞重要。</td></tr><tr class="odd"><td style="text-align: left;">flush / stall</td><td style="text-align: left;">最低，流水线信号，外部人员看不到。</td></tr></tbody></table><p>接下来我们考虑，哪些寄存器中的位段需要优先级。只有两个，一个是 PC寄存器，原因之前论述过了；另一个是 CP0 <code>Cause</code> 寄存器的<code>BD</code> 位。它在 flush的时候需要保持原来的信息，因为在外部去看的话，会发现宏观 PC是相同的，但是延迟槽标记是不同的，这显然是不正确的。如果在延迟槽指令被阻塞时产生中断，并且<code>nop</code> 没有流水延迟槽标记，那么 <code>EPC</code>就会被设置错误的值，无法通过评测。</p><p>清空流水线的另一个方面就是避免异常受害指令和其之后的指令产生影响（比如写寄存器，写DM），这一点将在下一小节“确定 CP0 的位置”中讨论。</p><h3 id="确定-cp0-的位置">确定 CP0 的位置</h3><p>CP0 需要放置在某个具体的流水级上，我们认为宏观 PC 所在的流水级就是CP0 的流水级。为了满足宏观 PC 的性质，CP0所处的位置不能够太靠前，比如设置在 F级，那么异常会发生在之后的流水级，那么就检测不到这个异常了（如果宏观 PC就是异常受害指令的话）。但是也不能太靠后，比如在 W级，因为我们需要清除受害指令之后的指令造成的影响，但是此时<code>store</code> 类指令已经修改了外设，清除影响较为困难。</p><p>因此，请根据所学挑选你的 CP0在流水线上的位置，需要强调，没有标准答案或者最优答案。</p><h3 id="流水异常码">流水异常码</h3><p>异常信号 ExcCode 应该流水到 CP0 所在的流水级，而不能直接提交到CP0。</p><p>这是因为 CPU 实际上是并行的，直接提交到 CP0可能会导致后面的指令发生异常的时间比前面指令发生异常的时间要早。例如<code>sw</code> 后接 <code>j</code> 指令。如果这两个都是异常指令，那么<code>j</code> 在 D 级产生异常，<code>sw</code> 在 M级产生异常（假设这个异常是超范围了）时不流水，就将先处理 <code>j</code>异常，显然不符合我们的要求，因为 <code>sw</code>异常被忽略了（<code>sw</code>继续往后流，前面的流水级开始流异常处理程序，等异常返回之后，就会直接到跳转目标指令了，<code>sw</code>的异常没有得到处理）。我们将异常信号流水以后，就可以先处理<code>sw</code> 异常，然后运行到 <code>j</code>，再处理 <code>j</code>异常。</p><h3 id="写入-epc">写入 EPC</h3><p>发生异常的一个重要行为是将中断指令的 PC 写入EPC，就像函数跳转之前，要将返回地址写入<code>$ra</code>。更严谨的说，对于异常情况只要考虑异常指令是不是延迟槽指令，如果是延迟槽指令，那么存的是异常指令的PC - 4，如果不是，那么就存异常指令的 PC。</p><p>这样造成的结果就是，返回的时候将重新执行异常指令（如果异常处理程序不对EPC 进行修改的话）。这里的 PC 指的都是宏观 PC。</p><p>思考题</p><p>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>思考题</p><p>为什么 <code>jalr</code> 指令的两个寄存器不能相同，例如<code>jalr $31, $31</code>？</p><h1 id="异常处理程序">异常处理程序</h1><h2 id="eret-没有延迟槽">eret 没有延迟槽</h2><p><code>eret</code> 承担了跳转功能，但是 <code>eret</code>是没有延迟槽的。也就是说测试数据中可能出现 <code>eret</code>指令后紧跟另一条非 <code>nop</code> 指令的情况。你的设计应该保证<code>eret</code> 的后续指令不被执行。</p><h2 id="异常处理程序的结构">异常处理程序的结构</h2><p>异常处理程序是由软件实现的，我们只需要提供接口而无需自己实现。同时，了解异常处理程序是十分有必要的。</p><p>异常和中断处理流程可以概括成如下步骤（需要强调的是，这些步骤只是为了让同学们更好的理解处理程序的结构，我们在实际测评中并不保证下述的步骤都执行，也不保证不包含在下述步骤里的结构不出现）：</p><ul><li>Step 1：构造异常处理环境，保存现场。</li><li>Step 2：读取 <code>Cause</code> 和 <code>EPC</code>寄存器，判断错误类型。</li><li>Step 3：根据异常类型和其他属性执行对应处理。</li><li>Step 4：恢复现场。</li><li>Step 5：使用 <code>eret</code> 指令从异常处理返回。</li></ul><p>下面列出了一个简要的发生算数溢出时的程序，同学们可以结合源码进行参考和理解。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 程序首先从这里运行</span><br><span class="hljs-meta">.text</span><br>    <span class="hljs-comment"># 只允许外部中断</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1001</span><br>    <span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">t0</span>, $<span class="hljs-number">12</span><br><br>    <span class="hljs-comment"># 算术溢出</span><br>    <span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t0</span>, <span class="hljs-number">0x7fff</span><br>    <span class="hljs-keyword">lui </span>$<span class="hljs-built_in">t1</span>, <span class="hljs-number">0x7fff</span><br>    <span class="hljs-keyword">add </span>$<span class="hljs-built_in">t2</span>, $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t1</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">end:</span><br>    <span class="hljs-keyword">beq </span>$<span class="hljs-number">0</span>, $<span class="hljs-number">0</span>, end<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br>.ktext <span class="hljs-number">0x4180</span><br><span class="hljs-symbol">_entry:</span><br>    <span class="hljs-comment"># 保存上下文</span><br>    <span class="hljs-keyword">j </span>_save_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_main_handler:</span><br>    <span class="hljs-comment"># 取出 ExcCode</span><br>    <span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">13</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k1</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x7c</span><br>    <span class="hljs-keyword">and </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k1</span><br><br>    <span class="hljs-comment"># 如果是中断，直接恢复上下文</span><br>    <span class="hljs-keyword">beq </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">0</span>, _restore_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br>    <span class="hljs-comment"># 将 EPC + 4，即处理异常的方法就是跳过当前指令</span><br>    <span class="hljs-keyword">mfc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">14</span><br>    <span class="hljs-keyword">addu </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">mtc0 </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">14</span><br>    <span class="hljs-keyword">j </span>_restore_context<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_exception_return:</span><br>    <span class="hljs-keyword">eret</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_save_context:</span><br>    <span class="hljs-keyword">ori </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-number">0</span>, <span class="hljs-number">0x1000</span>     <span class="hljs-comment"># 在栈上找一块空间保存现场</span><br>    <span class="hljs-keyword">addiu </span>$<span class="hljs-built_in">k0</span>, $<span class="hljs-built_in">k0</span>, -<span class="hljs-number">256</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">sp</span>, <span class="hljs-number">116</span>($<span class="hljs-built_in">k0</span>)        <span class="hljs-comment"># 最先保存栈指针</span><br>    <span class="hljs-keyword">move </span>$<span class="hljs-built_in">sp</span>, $<span class="hljs-built_in">k0</span><br><br>    <span class="hljs-comment"># 依次保存通用寄存器（注意要跳过 $sp）、HI 和 LO</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">1</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">2</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-number">31</span>, <span class="hljs-number">124</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">k0</span><br>    <span class="hljs-keyword">mflo </span>$<span class="hljs-built_in">k1</span><br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">k0</span>, <span class="hljs-number">128</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">sw </span>$<span class="hljs-built_in">k1</span>, <span class="hljs-number">132</span>($<span class="hljs-built_in">sp</span>)<br><br>    <span class="hljs-keyword">j </span>_main_handler<br>    <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">_restore_context:</span><br>    <span class="hljs-comment"># 依次恢复通用寄存器（注意要跳过 $sp）、 HI 和 LO</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">1</span>, <span class="hljs-number">4</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">2</span>, <span class="hljs-number">8</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-number">31</span>, <span class="hljs-number">124</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">k0</span>, <span class="hljs-number">128</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">k1</span>, <span class="hljs-number">132</span>($<span class="hljs-built_in">sp</span>)<br>    <span class="hljs-keyword">mthi </span>$<span class="hljs-built_in">k0</span><br>    <span class="hljs-keyword">mtlo </span>$<span class="hljs-built_in">k1</span><br><br>    <span class="hljs-comment"># 最后恢复栈指针</span><br>    <span class="hljs-keyword">lw </span>$<span class="hljs-built_in">sp</span>, <span class="hljs-number">116</span>($<span class="hljs-built_in">sp</span>)<br><br>    <span class="hljs-keyword">j </span>_exception_return<br>    <span class="hljs-keyword">nop</span><br></code></pre></td></tr></table></figure><h2 id="利用-mars-验证异常处理框架">利用 MARS 验证异常处理框架</h2><p>尽管在 MARS中，我们只能针对内部异常进行模拟，无法模拟外部中断。但由我们对内部异常与外部中断的了解可以知道，两者的处理是类似的。因此我们可以在MARS中先验证中断/异常处理的框架是否正确（我们可以构造一条产生异常的指令，如溢出，再观察MARS 能否进入 ExceptionHandler），至于我们如何处理这个错误，则是次要问题。</p><h1 id="p7-提交要求">P7 提交要求</h1><h2 id="整体要求">整体要求</h2><ul><li>MIPS 处理器须为流水线设计，MIPS 微系统须支持中断和异常。</li><li>除本文明确的规范和补充声明外，MIPS 微系统设计以《See MIPS RunLinux》（下文简称《SMRL》）作为标准。《SMRL》的标准与 MARS的行为存在一定差异，在测试时不以 MARS 为准。</li><li>P7 较前几个 Project 为同学预留了更多需自主设计的内容，最终 P7的实现因人而异。只要满足所给出的设计约束、行为规范和 MIPS基本设计规范，任何设计都被认为是正确的。</li><li><strong>此章节主要包含实现细节与评测要求，一些基本概念或定义请结合前面的教程理解。</strong></li></ul><h2 id="顶层模块接口">顶层模块接口</h2><ul><li><p>MIPS 微系统接口（请顶层模块严格满足该要求）：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mips(<br>    <span class="hljs-keyword">input</span> clk,                    <span class="hljs-comment">// 时钟信号</span><br>    <span class="hljs-keyword">input</span> reset,                  <span class="hljs-comment">// 同步复位信号</span><br>    <span class="hljs-keyword">input</span> interrupt,              <span class="hljs-comment">// 外部中断信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] macroscopic_pc, <span class="hljs-comment">// 宏观 PC</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_addr,    <span class="hljs-comment">// IM 读取地址（取指 PC）</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] i_inst_rdata,   <span class="hljs-comment">// IM 读取数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_addr,    <span class="hljs-comment">// DM 读写地址</span><br>    <span class="hljs-keyword">input</span>  [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_rdata,   <span class="hljs-comment">// DM 读取数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_data_wdata,   <span class="hljs-comment">// DM 待写入数据</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_data_byteen,  <span class="hljs-comment">// DM 字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_int_addr,     <span class="hljs-comment">// 中断发生器待写入地址</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span> :<span class="hljs-number">0</span>] m_int_byteen,   <span class="hljs-comment">// 中断发生器字节使能信号</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] m_inst_addr,    <span class="hljs-comment">// M 级 PC</span><br><br>    <span class="hljs-keyword">output</span> w_grf_we,              <span class="hljs-comment">// GRF 写使能信号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">4</span> :<span class="hljs-number">0</span>] w_grf_addr,     <span class="hljs-comment">// GRF 待写入寄存器编号</span><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_grf_wdata,    <span class="hljs-comment">// GRF 待写入数据</span><br><br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] w_inst_addr     <span class="hljs-comment">// W 级 PC</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>相较于 P6 的顶层模块新增了以下 4 个接口：</p><ul><li><code>interrupt</code>：外部中断信号。由中断发生器产生，每次中断信号会持续到处理器响应该信号。请注意，处理该中断信号的方式应和处理Timer 产生的中断不完全相同，具体见前面的教程。</li><li><code>macroscopic_pc[31:0]</code>：详细概念见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#pc">宏观PC</a>。我们保证评测过程中宏观 PC仅用于定位指令，作为产生外部中断信号的条件。</li><li><code>m_int_addr[31:0]</code>：中断发生器待写入地址。当该信号命中中断发生器响应地址，且字节使能信号有效时，视为响应外部中断。</li><li><code>m_int_byteen[3:0]</code>：中断发生器字节使能信号，当该信号任意一位置位时视为有效。</li></ul></li></ul><h2 id="硬件约束">硬件约束</h2><ul><li>顶层模块中应该至少包含 CPU、Bridge、Timer0、Timer1四个功能部件。</li><li>地址空间：见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-2/#_4">系统桥</a>。</li><li>主要部件：<ul><li>CPU：在 P6 基础上进行增量开发，增加 CP0协处理器，支持异常和中断等。</li><li>CP0：见<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-6/#cp0">CP0约束</a>。</li><li>Bridge：须作为独立的 module，不包括在 CPU中；访问外设均须通过系统桥。</li><li>IM：容量为 <strong>16KiB</strong>（<strong>4096</strong> ×32bit）。</li><li>DM：容量为 <strong>12KiB</strong>（<strong>3072</strong> ×32bit）。</li><li>Timer：定时器官方源代码已经给出，无需自行设计实现。</li><li>中断发生器：<ul><li>中断信号依据宏观 PC产生，依据相应的待写入地址和字节使能信号关闭，具体实现参考下发的tb。</li><li>由于其内部并没有真正的存储单元，我们规定读出的数据始终保持0，且写入时除了响应中断外不会产生其他影响。</li></ul></li></ul></li></ul><h2 id="cp0-约束">CP0 约束</h2><ul><li>协处理器位置：不作明确要求，自行设计。</li><li>输出要求：写入时无需 display。</li><li>为了支持异常和中断，必须实现的寄存器包括：<strong>SR、CAUSE、EPC</strong>。</li><li>寄存器规范：<ul><li>CP0 寄存器的初始值均为 0，未实现位始终保持 0。</li><li>当进入中断或异常状态时，均需要将 EXL 置为1，用以屏蔽中断信号（注意《SMRL》中并没有指定进入中断时 EXL的值）；当退出中断或异常状态时，也均需要将 EXL 置为0，取消屏蔽中断信号。</li><li>Cause 寄存器的 IP 域每周期写入 HWint 对应位的值。</li><li>当进入中断或异常状态时，需要将受害指令的 PC 写入 EPC。</li></ul></li></ul><h2 id="指令约束">指令约束</h2><ul><li><p>处理器应支持如下指令集：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">nop, </span><span class="hljs-keyword">add, </span><span class="hljs-keyword">sub, </span><span class="hljs-keyword">and, </span><span class="hljs-keyword">or, </span><span class="hljs-keyword">slt, </span><span class="hljs-keyword">sltu, </span><span class="hljs-keyword">lui</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi, </span><span class="hljs-keyword">andi, </span><span class="hljs-keyword">ori</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">lb, </span><span class="hljs-keyword">lh, </span><span class="hljs-keyword">lw, </span><span class="hljs-keyword">sb, </span><span class="hljs-keyword">sh, </span><span class="hljs-keyword">sw</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mult, </span><span class="hljs-keyword">multu, </span><span class="hljs-keyword">div, </span><span class="hljs-keyword">divu, </span><span class="hljs-keyword">mfhi, </span><span class="hljs-keyword">mflo, </span><span class="hljs-keyword">mthi, </span><span class="hljs-keyword">mtlo</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">beq, </span><span class="hljs-keyword">bne, </span><span class="hljs-keyword">jal, </span><span class="hljs-keyword">jr,</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">mfc0, </span><span class="hljs-keyword">mtc0, </span><span class="hljs-keyword">eret, </span><span class="hljs-keyword">syscall</span><br></code></pre></td></tr></table></figure></li><li><p>在 P6 基础上新增了 <code>mfc0, mtc0, eret, syscall</code>四条新指令。</p></li><li><p><code>eret</code> 具有跳转的功能但是没有延迟槽，你的设计应该保证<code>eret</code> 的后续指令不被执行。</p></li><li><p><code>syscall</code> 指令行为与 MARS不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态。</p></li></ul><h2 id="中断异常约束">中断异常约束</h2><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#_1">精确异常</a>的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code>同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><table><thead><tr class="header"><th style="text-align: left;">ExcCode</th><th style="text-align: left;">助记符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">0</td><td style="text-align: left;">Int</td><td style="text-align: left;">中断。</td></tr><tr class="even"><td style="text-align: left;">4</td><td style="text-align: left;">AdEL</td><td style="text-align: left;">取数或取指时地址错误。</td></tr><tr class="odd"><td style="text-align: left;">5</td><td style="text-align: left;">AdES</td><td style="text-align: left;">存数时地址错误。</td></tr><tr class="even"><td style="text-align: left;">8</td><td style="text-align: left;">Syscall</td><td style="text-align: left;">系统调用。</td></tr><tr class="odd"><td style="text-align: left;">10</td><td style="text-align: left;">RI</td><td style="text-align: left;">不认识的（或者非法的）指令码。</td></tr><tr class="even"><td style="text-align: left;">12</td><td style="text-align: left;">Ov</td><td style="text-align: left;">自陷形式的整数算术指令（例如<code>add</code>）导致的溢出。</td></tr></tbody></table></li><li><p>补充说明：</p><ul><li>分支跳转指令无论跳转与否，延迟槽指令为受害指令时 <code>BD</code>均需要置位。</li><li>发生取指异常或 <code>RI</code> 异常后视为 <code>nop</code>直至提交到 CP0。</li><li>跳转到不对齐的地址时，受害指令是 PC 值不正确的指令（即需要向 EPC写入不对齐的地址）。</li><li>对于未知指令的判断仅需考虑 opcode（和 R 型指令的funct），且仅需判断是否出现在 P7要求的指令集中，同时保证未知指令的测试用例中 opcode 和 funct码的组合一定没有在 MARS 的基本指令集中出现。</li></ul></li></ul><h2 id="官方测试说明">官方测试说明</h2><ul><li>为便于进行测试，我们允许从 0x417C 直接前进到 0x4180，此种情况下 CPU行为与 P6 一致，不应有中断响应等其他行为。</li><li>测试数据规范：<ul><li>测试时不会出现跳转到未加载指令的位置的情况。</li><li><code>eret</code> 只会出现在中断处理程序中，后可能紧跟另一条非<code>nop</code> 的指令。</li><li>测试程序保证不会写入 Cause，但可能写入 SR 和 EPC。</li><li>测试程序只会通过指令 <code>sb $0, 0x7f20($0)</code>访问中断发生器（响应中断），且只会在中断处理程序中访问。</li><li>中断处理程序会对寄存器和内存进行读写来验证 CPU 的正确性。</li><li>中断处理程序执行过程中保证不出现异常，且不会产生中断。</li></ul></li><li>官方 tb 示例：<ul><li>外设不给予中断时，使用的 tb 为：<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/tb_norm_demo.v">下载链接</a>。</li><li>评测机通过检测同学们的宏观 PC 给予中断信号并对中断进行测试，例如此<ahref="http://cscore.buaa.edu.cn/tutorial/P7/implement/assets/tb_interrupt_demo.v">下载链接</a>中的tb 会在处理器的宏观 PC 第一次到达 0x3010 时给予 CPU 一个中断信号。</li></ul></li></ul><h2 id="官方-mars">官方 Mars</h2><ul><li>课程组修改了 Mars，增加了输出运行信息等功能，支持课程 P7要求的异常和定时器中断，供同学们本地测试，<ahref="http://cscore.buaa.edu.cn/assets/cscore-assets/Mars_p7.zip">下载链接</a>。</li></ul><h1 id="思考题汇总">思考题汇总</h1><p>思考题</p><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU处理中断异常必须是已经指定好的地址？如果你的 CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成<code>jalr $31, $31</code>？</p><p>思考题</p><p>1、[P7 选做] 请详细描述你的测试方案及测试数据构造策略。</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计组理论</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BB%84%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h3 id="考题">考题</h3><p>10*单选</p><p>简答：逻辑函数化简、内存扩展（译码器生成片选信号、二维地址结构）、页式存储、cache命中率、mips汇编</p><h4 id="概述">概述</h4><p>进制转换</p><h4 id="组合逻辑">组合逻辑</h4><p>逻辑函数化简：吸收律、配项法……</p><p>多路选择器：74151、函数生成器</p><h4 id="时序逻辑">时序逻辑</h4><p>有限状态机：moore、mealy型，状态转换图、表、函数表达式（考试说明再化简）</p><h4 id="主存">主存</h4><p>二维地址结构、译码器生成片选信号</p><h4 id="汇编">汇编</h4><p>指令格式：操作码结构、指令长度（定长快、变长小）</p><p>各种指令：R、I、J</p><p>寻址方式</p><h4 id="mips流水线">mips流水线</h4><p>基本概念</p><p>数据冒险</p><h4 id="cache">cache</h4><p>直接映射：区地址（tag）+区内快递至</p><p>命中率（能否替换）</p><h4 id="中断">中断</h4><p>DMA、中断</p><h4 id="浮点数">浮点数</h4><p>以单精度浮点数为例，浮点数共由以下3部分组成</p><ul><li>1位数符S：0表示正数，1为负数</li><li>8位阶E（双精度为11位）：偏移量为 <spanclass="math inline">\(2^{n-1}-1\)</span></li><li>23位尾数m（双精度为52位）：规格化成小数点左侧为1，且1作为隐含位被忽略，即1.m</li></ul><p><spanclass="math inline">\((178.125)_{10}=(10110010.001)_2=1.0110010001\times2^{111}\)</span>：S=0，E=00000111+01111111=10000110，m=01100100010000000000000</p><p>单精度浮点数的表示约定：</p><table><thead><tr class="header"><th style="text-align: center;">E</th><th style="text-align: center;">M</th><th style="text-align: center;">浮点数N</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1-254</td><td style="text-align: center;">不为0</td><td style="text-align: center;">规范浮点数 <spanclass="math inline">\(N=(-1)^s\times1.m\times2^{E-127}\)</span></td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">不为0</td><td style="text-align: center;">非规范浮点数 <spanclass="math inline">\(N=(-1)^s\times0.m\times2^{-126}\)</span></td></tr><tr class="even"><td style="text-align: center;">255</td><td style="text-align: center;">0</td><td style="text-align: center;">无穷（有正负）</td></tr><tr class="odd"><td style="text-align: center;">255</td><td style="text-align: center;">不为0</td><td style="text-align: center;">NaN（不是一个数）</td></tr></tbody></table><h2 id="组合逻辑-1">组合逻辑</h2><h3 id="基础知识">基础知识</h3><h4 id="晶体管类器件">晶体管类器件</h4><p>P(positive)型半导体掺三价元素，导电以空穴为主；N(negtive)型半导体掺五价元素，导电以电子为主。</p><p>PN结（晶体二极管）P极接正极为正向偏置，导通；反之为反向偏置，截止</p><p>三极管</p><p>集电极C，N型；基极B，P型；发射极E，N型</p><figure><img src="/img/image-20231214213736360.png"alt="image-20231214213736360" /><figcaption aria-hidden="true">image-20231214213736360</figcaption></figure><figure><img src="/img/image-20231216214649868.png"alt="image-20231216214649868" /><figcaption aria-hidden="true">image-20231216214649868</figcaption></figure><p>TTL与非门的两个状态通常称为关态和开态，当输入全为高电平时对应的是关态，此时输出为高电平；当输入有一为低电平时，对应的是开态，此时输出为低电平。</p><h4 id="逻辑电路的符号表示">逻辑电路的符号表示</h4><figure><img src="/img/image-20231210151341113.png"alt="image-20231210151341113" /><figcaption aria-hidden="true">image-20231210151341113</figcaption></figure><h4 id="组合逻辑电路">组合逻辑电路</h4><ol type="1"><li>从结构看，组合逻辑电路由门电路构成，不含<strong>存储电路</strong>，也不含<strong>反馈电路</strong>，信号从输入开始单向传输到输出。对于组合逻辑电路，任何时刻电路的输出仅由当时的<strong>输入信号</strong>决定。</li><li>将加在电路若干输入端中的某一个输入端的信号变换成相应的一组二进制代码输出的过程叫做<strong>编码</strong></li><li>将二进制代码所表示的信息翻译成对应输出的高低电平信号的过程称为译码；n位二进制译码器有n个输入，有2^n个输出，工作时译码器只允许有一个输出有效。</li></ol><h3 id="理论运算">理论运算</h3><h5 id="符号">符号</h5><p>与：<span class="math inline">\(\cdot\)</span> 或 <spanclass="math inline">\(\land\)</span></p><p>或：<span class="math inline">\(+\)</span> 或 <spanclass="math inline">\(\lor\)</span></p><p>非：<span class="math inline">\(\overline{}\)</span> 或 <spanclass="math inline">\(\neg\)</span></p><p>异或：<span class="math inline">\(\oplus\)</span></p><p>同或：<span class="math inline">\(\odot\)</span></p><p>优先级：括号、非、与、异或、或 <spanclass="math inline">\(()&gt;\neg&gt;\cdot&gt;\oplus&gt;+\)</span></p><h5 id="运算律">运算律</h5><p>交换律、结合律、0-1律（与0做运算）、互补律</p><p>重叠率、吸收律、还原律</p><p>吸收律</p><p><span class="math inline">\(A+\bar{A}B=A+B\)</span></p><p>分配律</p><p><span class="math inline">\(A\cdot(B+C)=A\cdot B+A\cdotC\)</span></p><p><span class="math inline">\(A+B\cdot C=(A+B)\cdot(A+C)\)</span></p><p>反演律（德摩根律）</p><p><spanclass="math inline">\(\overline{A+B}=\overline{A}\cdot\overline{B}\)</span></p><p><span class="math inline">\(\overline{A\cdotB}=\overline{A}+\overline{B}\)</span></p><p>包含律</p><p><span class="math inline">\(A\cdot B+\overline{A}\cdot B+B\cdotC=A\cdot B+\overline{A}\cdot B\)</span></p><p><spanclass="math inline">\((A+B)\cdot(\overline{A}+C)\cdot(B+C)=(A+B)\cdot(\overline{A}+C)\)</span></p><h5 id="规则">规则</h5><p>代入规则、反演规则、对偶规则</p><h5 id="逻辑函数的标准表达式">逻辑函数的标准表达式</h5><h6 id="最小项">最小项</h6><ul><li><p>最小项：由n个变量组成的 “与”项中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个与项称为最小项。n个变量有<span class="math inline">\(2^n\)</span> 个最小项</p></li><li><p>最小项编号：按照变量顺序将最小项中的原变量用1表示、反变量用0表示，得到一个二进制数，与其对应的十进制数，即该最小项的编号i</p></li><li><p>性质：</p></li></ul><ol type="1"><li><p>对于任何一个最小项，只有对应的一组变量取值，使其值为1，其余情况下均为0</p></li><li><p>全体最小项之和为1</p></li><li><p>任意两个最小项的乘积为0</p></li><li><p>相邻最小项：除一个变量互为相反外，其余变量都分别相同的两个最小项。</p><p>具有相邻性的两个最小项之和，可以合并为一个乘积项，消去一个以原变量和反变量形式出现的变量，保留由没有变化的变量构成的乘积项。</p><p>例：<spanclass="math inline">\(\bar{A}\bar{B}\bar{C}+\bar{A}\bar{B}C=\bar{A}\bar{B}\)</span></p></li></ol><ul><li>最小项推导法（从真值表推出表达式）：把输出为1的输入组合写成乘积项的形式，其中取值为1 的输入用原变量表示，取值为 0的输入用反变量表示，然后把这些乘积项加起来</li></ul><p><spanclass="math inline">\(F=\bar{A}BC+A\bar{B}C+AB\bar{C}+ABC\)</span></p><p><span class="math inline">\(F(A,B,C)=m_3+m_5+m_6+m_7\)</span></p><p><span class="math inline">\(F(A,B,C)=\sum m(3,5,6,7)\)</span></p><h6 id="最大项">最大项</h6><ul><li><p>最大项：设有n个变量，它们所组成的具有n个变量的“或”项（和项）中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个和项称为最大项。n个变量有2n个最大项</p></li><li><p>最大项编号：按照变量顺序将最大项中的原变量用0表示、反变量用1表示，得到一个二进制数，与其对应的十进制数即该最大项的编号i</p></li><li><p>性质：</p><ol type="1"><li><p>对于任何一个最大项，只有对应的一组变量取值，使其值为0，其余情况下均为1</p></li><li><p>全体最大项之积为0</p></li><li><p>任意两个最大项之和为1</p></li><li><p>相邻最大项：若2个最大项中只有1个变量分别以原变量和反变量的形式出现，其余的变量分别相同，则称这2个变量具有相邻性，或相邻最大项。具有相邻性的两个最大项之积可以合并为一个和项，消去一个以原变量和反变量形式出现的变量，保留由没有变化的变量构成的和项。</p><p>例：<spanclass="math inline">\((\bar{A}+B+\bar{C})(A+B+\bar{C})=[\bar{A}+(B+\bar{C})][A+(B+\bar{C})]=B+\bar{C}\)</span></p></li></ol></li><li><p>1</p></li></ul><h6 id="化简">化简</h6><p>一般由EDA工具完成</p><p>“与或”表达式化简：</p><ol type="1"><li><p>乘积项最少（与门最少）</p></li><li><p>乘积中变量最少</p></li><li><p>用最少的门、门的输入也最少</p></li></ol><p>方法：</p><ol type="1"><li><p>合并乘积项（互补律）</p></li><li><p>吸收项法（吸收律、包含律）</p></li><li><p>配项法（利用互补律）</p></li></ol><p><strong>卡诺图化简</strong></p><h3 id="常见器件">常见器件</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">输入</th><th style="text-align: center;">输出</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">7485四位比较器</td><td style="text-align: center;">A3-A0,B3-B0,I0-I2</td><td style="text-align: center;">F&gt;,F&lt;,F=</td><td style="text-align: center;">比较4位二进制数的大小</td></tr><tr class="even"><td style="text-align: center;">8线-3线编码器</td><td style="text-align: center;">Y0,Y1...Y7</td><td style="text-align: center;">C,B,A</td><td style="text-align: center;">用3位二进制代码对8个信号进行编码</td></tr><tr class="odd"><td style="text-align: center;">8421BCD编码器</td><td style="text-align: center;">Y0,Y1...Y9</td><td style="text-align: center;">D,C,B,A</td><tdstyle="text-align: center;">用4位二进制代码对10个十进制数字进行编码</td></tr><tr class="even"><td style="text-align: center;">74LS148优先编码器</td><td style="text-align: center;">低电平有效</td><td style="text-align: center;">反码</td><td style="text-align: center;">同8-3，优先编码7</td></tr><tr class="odd"><td style="text-align: center;">74LS147优先编码器</td><td style="text-align: center;">低电平有效</td><td style="text-align: center;">反码</td><td style="text-align: center;">同8421，优先编码9</td></tr><tr class="even"><td style="text-align: center;">3线-8线译码器(74138)</td><td style="text-align: center;">A2,A1,A0,S2,S1,S0</td><td style="text-align: center;">Y7-Y0，低电平输出有效</td><td style="text-align: center;">S0,S1,S2为100时使能，3-8</td></tr><tr class="odd"><td style="text-align: center;">BCD译码器</td><td style="text-align: center;">DCBA</td><td style="text-align: center;">Y9-Y0，低电平输出有效</td><td style="text-align: center;">10-4</td></tr><tr class="even"><td style="text-align: center;">74151多选器</td><td style="text-align: center;">D7-D0,A2-A1,~en</td><td style="text-align: center;">Y,~Y</td><td style="text-align: center;">8选1数据选择器</td></tr></tbody></table><h2 id="时序逻辑-1">时序逻辑</h2><h3 id="基础知识-1">基础知识</h3><ol type="1"><li><p>时序逻辑电路由组合逻辑电路和存储电路两部分组成</p></li><li><p>时序逻辑电路按触发器时钟端的连接方式不同可以分为同步时序逻辑和异步时序逻辑两类。</p></li></ol><h3 id="锁存器">锁存器</h3><h6 id="基本rs锁存器">基本RS锁存器</h6><figure><img src="/img/image-20230925142055279.png"alt="image-20230925142055279" /><figcaption aria-hidden="true">image-20230925142055279</figcaption></figure><p>功能：</p><ol type="1"><li><p>保持原来状态： <spanclass="math inline">\(\overline{R_D}=1,\overline{S_D}=1\)</span></p></li><li><p>置0（次态变0）：<spanclass="math inline">\(\overline{R_D}=0,\overline{S_D}=1\)</span></p></li><li><p>置1：<spanclass="math inline">\(\overline{R_D}=1,\overline{S_D}=0\)</span></p></li></ol><p>约束条件：<spanclass="math inline">\(\overline{R_D}+\overline{S_D}=1\)</span></p><p>特性方程：<spanclass="math inline">\(Q^{n+1}=S_D+\overline{R_D}Q^n\)</span></p><h6 id="钟控rs锁存器">钟控RS锁存器</h6><figure><img src="/img/image-20230925142436000.png"alt="image-20230925142436000" /><figcaption aria-hidden="true">image-20230925142436000</figcaption></figure><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> 时，保持状态</p></li><li><p><span class="math inline">\(CP=1\)</span>时，具有RS锁存器的功能</p></li></ol><p>约束条件：<span class="math inline">\(S*R=0\)</span></p><p>特性方程：<spanclass="math inline">\(Q^{n+1}=S+\overline{R}Q^n\)</span></p><h6 id="钟控d锁存器">钟控D锁存器</h6><p><img src="/img/image-20230925143251215.png" alt="image-20230925143251215" style="zoom:50%;" /></p><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> ，保持</p></li><li><p><span class="math inline">\(CP=1\)</span> ，<spanclass="math inline">\(Q=D\)</span></p></li></ol><p>特性方程：<span class="math inline">\(Q^{n+1}=D\)</span></p><h6 id="d触发器">D触发器</h6><p><img src="/img/image-20230925143754522.png" alt="image-20230925143754522" style="zoom:50%;" /></p><p>功能：CP（clk）上升沿更新Q，Q=D</p><p>可带使能端、复位</p><p>多个D触发器可以组成寄存器</p><h6 id="jk触发器">JK触发器</h6><p><img src="/img/image-20230925144127337.png" alt="image-20230925144127337" style="zoom:50%;" /></p><p>功能：</p><ol type="1"><li><p><span class="math inline">\(CP=0\)</span> ，保持</p></li><li><p><span class="math inline">\(CP=1\)</span> ，RS锁存器功能，且<span class="math inline">\(J=K=1\)</span> 时翻转</p></li></ol><p>特性方程：<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span></p><h6 id="t触发器">T触发器</h6><p>功能：</p><ol type="1"><li><p><span class="math inline">\(T=0\)</span> ，保持</p></li><li><p><span class="math inline">\(T=1\)</span> ，翻转</p></li></ol><p>特性方程：<span class="math inline">\(Q_{n+1}=T\oplusQ_n\)</span></p><h3 id="有限状态机">有限状态机</h3><h6 id="相关概念">相关概念</h6><p>概念：可描述有限个状态以及这些状态之间的转移及引起转移的动作等的离散数学模型。</p><p>次态逻辑：组合逻辑，根据当前状态和输入计算下一状态。</p><p>状态寄存器：在时钟沿到来之前，保持现态，并为输出逻辑和次态逻辑提供稳定输入；在时钟沿到来时，锁存次态逻辑输出的状态值。</p><p>输出逻辑：组合逻辑，根据现态形成输出信号。</p><p><img src="/img/image-20230925145703517.png" alt="image-20230925145703517" style="zoom: 50%;" /></p><p>分类：Moore型状态机：输出状态仅与当前状态有关</p><p>Mealy型状态机：输出信号与当前状态和输入信号有关</p><h6 id="建立方法">建立方法</h6><ol type="1"><li><p>确定输入、输出、状态</p></li><li><p>画出状态转换图，进而得到状态转换表、次态与输出逻辑表达式</p></li></ol><h6 id="时序问题">时序问题</h6><p><spanclass="math inline">\(T_c&gt;=T_{ctq}+T_{cd}+T_{setup}+时钟偏移\)</span></p><p><span class="math inline">\(T_c\)</span> ：时钟周期</p><p><span class="math inline">\(T_{ctq}\)</span>：稳定时间（clock-to-Q）：——从触发时钟边沿到输出稳定的时间</p><p><span class="math inline">\(T_{cd}\)</span>：组合逻辑电路最长时延</p><p><span class="math inline">\(T_{setup}\)</span>：建立时间——触发时钟沿之前，输入需稳定的时间</p><p><span class="math inline">\(T_{hold}\)</span>：保持时间：触发时钟沿之后，输入仍需稳定的时间</p><p>保持约束：<span class="math inline">\(T_{ctq}+T_{cd}\geqslantT_{hold}\)</span></p><h3 id="寄存器">寄存器</h3><p>数据寄存器：多个边沿触发器组成</p><p>数据锁存器：多位电位触发器组成</p><p>移位寄存器：</p><p>4位双向移位寄存器(CT74194)</p><figure><img src="/img/image-20231215222541935.png"alt="image-20231215222541935" /><figcaption aria-hidden="true">image-20231215222541935</figcaption></figure><p>同步计数器：所有触发器的时钟端并在一起</p><p>异步计数器：时钟脉冲只作用于最低位</p><h2 id="主存储器">主存储器</h2><h3 id="分类">分类</h3><p>RAM（随机访问存储器）、ROM（只读存储器）</p><p>RAM可分为SRAM（静态存储器，Cache）、DRAM（主存）</p><p>ROM可分为Flash（闪存，可擦写）、不可在线更改的等等</p><h3 id="描述">描述</h3><p>存取时间：读或写操作所用的时间</p><p>存取周期：两次访问存储单元的最小时间间隔</p><p>存储器带宽：单位时间访问的存储量</p><p>存储芯片容量=字单元数*字单元的位数，即 <spanclass="math inline">\(2^n\times m\)</span> 。其中 <spanclass="math inline">\(2^n\)</span>为字单元数量，n为地址线数量，m为数据线数量（字单元位数）</p><p>地址线=log2(字单元数)，（按字寻址）</p><p>数据线=字单元位数</p><h3 id="扩展">扩展</h3><p>位扩展：字单元位数不够</p><p>字扩展：字单元数不够</p><h3 id="dram刷新">DRAM刷新</h3><p>刷新间隔：同一行两次被刷新之间的时间</p><p>刷新周期：所有行被刷新一次的时间</p><p>集中式：间隔=刷新周期</p><p>分散式：间隔=刷新行数*存储周期</p><p>分布式（异步）：间隔=刷新周期</p><h2 id="mips汇编">MIPS汇编</h2><h3 id="指令格式">指令格式</h3><p>操作码+操作数（操作数地址，0123）</p><p>定长/变长</p><h3 id="寻址">寻址</h3><p>立即寻址：机器码中给出立即数</p><p>直接寻址：操作数在寄存器中，机器码里有寄存器编号</p><p>间接寻址：操作数在内存中，机器码里有存储着内存地址的寄存器的编号</p><p>基址寻址/变址寻址：间接寻址+立即数（<code>lw $s1,100($s2)</code>）</p><p>相对寻址：PC作为基址寄存器+立即数</p><p>堆栈寻址</p><h4 id="mips中的寻址">mips中的寻址</h4><p>立即寻址：ori中的立即数</p><p>寄存器寻址：add中操作数在寄存器里</p><p>基址寻址：lw，根据寄存器中的数据+偏移量得出内存地址，取数</p><p>PC相对寻址：beq</p><p>伪直接寻址：j</p><h3 id="一些指令">一些指令</h3><h4 id="跳转相关">跳转相关</h4><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">位数</th><th style="text-align: center;">跳转空间</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">beq</td><td style="text-align: center;">16位立即数+左移2</td><td style="text-align: center;">256K</td></tr><tr class="even"><td style="text-align: center;">j</td><td style="text-align: center;">26位立即数+左移2</td><td style="text-align: center;">256M</td></tr><tr class="odd"><td style="text-align: center;">jr</td><td style="text-align: center;">寄存器，32位</td><td style="text-align: center;">4G</td></tr></tbody></table><h4 id="罕见指令">罕见指令</h4><p>bgez：大于等于0跳转 bgtz：大于0跳转 blez：小于等于……bgeal：大于等于0，则跳转+写入ra</p><p>lbu：加载无符号数……lhu、lwu、sbu</p><p>sll：逻辑左移，5位立即数 sllv：寄存器代替立即数 srl：逻辑右移sra：算数右移……</p><p>slti：小于立即数置1 sltiu：小于无符号立即数置1</p><h2 id="流水线cpu">流水线CPU</h2><figure><img src="/img/image-20231231103906887.png"alt="image-20231231103906887" /><figcaption aria-hidden="true">image-20231231103906887</figcaption></figure><p>数据相关性：设指令i在指令j前面</p><ol type="1"><li>写读相关（RAW）：指令i将数据写入寄存器后，指令j才能读取</li><li>读写相关（WAR）：指令i读出数据后，指令j才能写寄存器</li><li>写写相关（WAW）：指令i写入后，指令j才能写入，否则寄存器内容不是最新值</li></ol><p>冒险类型：</p><ul><li>数据冒险：数据存在相关性，可用转发、暂停解决</li><li>控制冒险：分支跳转指令“撤回”等问题，可用延迟槽、分支比较前移解决</li><li>结构冒险：两条指令使用同一部件如同时读写寄存器堆，可通过把指令寄存器和数据寄存器分开解决</li></ul><h2 id="cache-1">Cache</h2><p><strong>注意主存地址位数（多少字节）、字节、字之间的换算！！！</strong></p><h3 id="cache结构">Cache结构</h3><p>SRAM组成，以数据块为单位。块大小与主存相同</p><p>数据块（block）：主存与cache交换数据的最小单位，多个字节组成</p><p>标记（tag）：保存该数据块对应的主存数据块的地址信息</p><p>有效位（valid bit）：该数据块中是否包含有效数据</p><p>行：1行=数据块+标记+有效位</p><p>组：若干块构成一组</p><p>实际Cache容量=行数*(tag+有效位等+数据块字节数)</p><h3 id="cache映射机制">Cache映射机制</h3><h4 id="全相联">全相联</h4><p>主存中某一数据块可以映射到Cache中的任意一数据块</p><p>Cache的tag内容：与该数据块对应的主存的数据块的块地址</p><p>主存地址格式：块地址+块内地址</p><h4 id="直接映射">直接映射</h4><p>主存中某一块J映射到Cache中的固定块K，<spanclass="math inline">\(K=J\mod M\)</span> ，M是Cache包含的块数</p><p>Cache的tag内容：主存中与该数据块对应的区地址，即第几个能映射到Cache中该块的数据块</p><p>主存地址格式：区地址+区内块地址+块内地址</p><h4 id="组相联">组相联</h4><p>Cache分成K组，每组L块，主存的块J映射到Cache中组I的任意一块，其中$I=JK$</p><p>实际上，主存与Cache都分为K组，但组内块数不同，组内任意映射</p><p>Cache的tag内容：主存中与该数据块对应的组内块地址</p><p>主存地址格式：组内块地址+组地址+块内地址</p><h3 id="缺失损失与替换策略">缺失损失与替换策略</h3><h4 id="缺失损失">缺失损失</h4><p>缺失时，CPU等待数据装入Cache后才能访问</p><p>取出块的时间：第一个字的延迟时间（存储器访问）+块的剩余部分的传送时间</p><p>计算方法1：访问Cache发现缺失的时间+访问DRAM的时间*字数+传输时间*字数</p><p>传输时间可能会因为并行数而改变</p><h4 id="缺失处理">缺失处理</h4><ul><li>块装入后访问</li><li>尽早重启：块中各字按顺序装入Cache，一旦所请求的字装入Cache，CPU立刻访问</li><li>请求字优先：先把所请求的字装入Cache，再装入其他字</li></ul><h4 id="替换策略">替换策略</h4><p>最近最少使用法（LRU）：最近没有被使用的块被替换。替换的块计数清零，其他计数器+1；访问命中时，计数值小于等于命中块计数值的+1，然后命中块清零；替换时选择计数值最大的块来替换</p><p>先进先出法（FIFO）：最先装入数据的块被替换</p><p>最小使用频率法（LFU）：使用次数最少的块被替换</p><p>随机法（RAND）</p><h2 id="辅助存储与虚拟存储">辅助存储与虚拟存储</h2><h3 id="辅助存储">辅助存储</h3><h4 id="磁介质">磁介质</h4><p>磁记录编码方式：</p><figure><img src="/img/image-20231231113943254.png"alt="image-20231231113943254" /><figcaption aria-hidden="true">image-20231231113943254</figcaption></figure><p>编码效率：记录一位信息的最大磁化翻转次数的倒数，调频、调相为0.5，不归零制为1</p><p>自同步能力：从读出的信号中提取同步信号。PM、FM有</p><p>可靠性：归零制低，调相制高</p><h5 id="磁盘">磁盘</h5><p>RPM：每分钟转多少圈</p><p>容量：盘面数*每面磁道数*每磁道扇区数*扇区容量</p><p>访问时间=寻道时间+寻区时间</p><p>数据传输率：单位时间传输的数据位数</p><p>RAID：廉价磁盘冗余阵列，多个物理磁盘构成，但被操作系统当成一个逻辑磁盘，数据分布在不同的物理磁盘上，冗余磁盘用于保存数据校验信息，校验信息保证在出现磁盘损坏时能够有效地恢复数据。</p><ul><li>RAID0：每一数据条带分布在不同物理磁盘上，改善数据传输性能，但完全没有冗余</li><li>RAID1：简单镜像磁盘冗余，利用率50%。写操作性能不高（同时写两组）</li><li>RAID2：海明校验，完整的并行访问技术</li><li>RAID3：奇偶校验的并行传送，校验码保存在独立的冗余磁盘对应位置</li><li>RAID4：奇偶校验吗的独立磁盘结构</li><li>RAID5：分布式奇偶校验的独立磁盘结构。校验信息保存在磁盘组的不同磁盘中</li></ul><h5 id="mips存储管理">MIPS存储管理</h5><p>从低到高32位：用户2G，KSeg0（有MMU的操作系统内核）512M，KSeg1512M，KSeg2 1G</p><p>PC初始值：0x00400000</p><p>$gp：0x10008000，静态数据区为0x10000000-0x1000FFFF</p><p>$sp：0x7FFFFFFF</p><h3 id="虚拟存储">虚拟存储</h3><p>虚地址：编写程序时使用的地址，地址格式为虚页号+页内地址</p><p>实地址：物理内存的访问地址，地址格式为实页号+页内地址</p><p>页表：每道程序一个，以虚页号为索引，实页号、有效位为页表项，存储在内存中</p><p>快表（TLB）：用Cache存储部分活跃的页表项，内容为虚页号、对应实页号、有效位、修改位</p><p>调度方式：页式调度、段式调度、段页式调度</p><h2 id="总线与io接口">总线与I/O接口</h2><h3 id="总线">总线</h3><p>分类：片内总线、系统总线、通信总线。其中系统总线可分为数据总线、地址总线、控制总线</p><p>总线的信息传送：请求总线、总线仲裁、寻址、信息传送、状态返回</p><p>总线仲裁方式（分布式、集中式）：链式查询、计数器定时查询、独立请求</p><p>总线通信方式：同步、异步（不互锁、半互锁、全互锁）</p><h3 id="io接口">I/O接口</h3><p>分类：串行/并行、同步/异步、程序查询/中断/DMA/通道控制接口</p><p>I/O操作过程：</p><ol type="1"><li>CPU查询接口状态</li><li>I/O回送设备状态</li><li>CPU发出命令，请求传送</li><li>I/O获得来自外设的数据</li><li>数据从I/O接口传送至CPU</li></ol><p>编址方式：独立编址、统一编址（存储器与I/O地址统一考虑）</p><p>程序查询I/O：I/O操作全部由CPU直接完成，与CPU串行，效率低</p><p>中断I/O：当前指令执行完毕后，响应中断。外设准备阶段可认为是并行的。目前最主要的方式。</p><p>DMA：CPU不再介入具体的I/O操作，DMA控制总线，数据传送效率更高。周期窃取方式（单字、一个总线周期），停止CPU访问内存（成组传送方式）。指令周期的任一存取周期结束时响应</p><p>通道I/O：有自己指令系统的专业控制器，CPU基本不需要管理I/O。选择通道的数据传输率=一台设备的数据传输率，字节多通道、数组多通道数据传输率=各设备数据传输率之和</p><h3 id="dma与中断">DMA与中断</h3><p>响应时机：中断在一条指令结束后响应；DMA在指令周期内任一存储周期结束时响应</p><p>现场保护：中断要中断现有程序，保护现场；DMA不中断现有程序，无须保护现场</p><p>适应场合：中断适于处理紧急或异常事件；DMA适合传送大批数据（如磁盘、网卡等）</p><p>传送方式：中断靠程序传送数据；DMA靠硬件</p>]]></content>
    
    
    <categories>
      
      <category>CO</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>离散2笔记</title>
    <link href="/2024/01/14/%E7%A6%BB%E6%95%A32%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E7%A6%BB%E6%95%A32%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h3 id="考前要看的几点">考前要看的几点</h3><h4 id="判断题">判断题</h4><p>连通无向图：欧拉图 <spanclass="math inline">\(\Leftrightarrow\)</span>有欧拉闭路；非连通无向图：欧拉图 <spanclass="math inline">\(\Leftrightarrow\)</span> 每个分支都有欧拉闭路</p><p>字典序不一定保证有极小元（ab,aab,aaab,...）</p><p>n阶二叉树有(n+1)/2个叶节点，(n-1)/2个分支节点</p><p>任何图都有偶数个奇结点</p><p>三个集合间的交、并关系仔细看！</p><h4 id="证明题">证明题</h4><p>最优叶加权路径</p><p>n阶非循环无向图有n-1条边，求证连通</p><p>n阶连通无向图有n-1条边，求证非循环</p><p>n阶连通无向图G非循环，求证有n-1条边</p><p><span class="math inline">\(t(R)=R^{+}\)</span></p><p>基础图是完全无向图的n阶有向图必有哈密顿路径</p><h2 id="集合">集合</h2><p>罗素悖论：<span class="math inline">\(T=\{x|x\notinx\}\)</span>，则推理 <span class="math inline">\(T\in T\)</span> 与<span class="math inline">\(T\notin T\)</span> 过程中均产生矛盾</p><p>幂集：集合A的全部子集构成的集合，即 <spanclass="math inline">\(\mathcal{P}(A)=\{X|X\subseteq A\}\)</span></p><p>A有穷，则 <spanclass="math inline">\(\#\mathcal{P}(A)=2^{\#A}\)</span></p><h4 id="集合的运算">集合的运算</h4><p><span class="math inline">\(A-B=A\cap \sim B\)</span></p><p><span class="math inline">\(A\oplus B=(A-B)\cup(B-A)\)</span></p><p>证明某式成立：元素分析法、集合运算</p><h4 id="广义交广义并">广义交、广义并</h4><p>集类：某集合的所有元素都是集合</p><p>广义并：设 <span class="math inline">\(\mathcal{B}\)</span>是任意集类，称集合 <span class="math inline">\(\{x|\existsX(X\in\mathcal{B}\land x\in X)\}\)</span> 为 <spanclass="math inline">\(\mathcal{B}\)</span> 的广义并，记为 <spanclass="math inline">\(\cup\mathcal{B}\)</span></p><p>广义交：设 <span class="math inline">\(\mathcal{B}\)</span>是任意集类，且 <spanclass="math inline">\(\mathcal{B}\ne\emptyset\)</span>，称集合 <spanclass="math inline">\(\{x|\forall X(X\in\mathcal{B}\rightarrow x\inX)\}\)</span> 为 <span class="math inline">\(\mathcal{B}\)</span>的广义交，记为 <span class="math inline">\(\cap\mathcal{B}\)</span></p><p>有穷集的计数原理：<span class="math inline">\(\#(A\cupB)=\#A+\#B-\#(A\cap B)\)</span></p><h4 id="集合的归纳定义字符串集合">集合的归纳定义、字符串集合</h4><h5 id="归纳定义法">归纳定义法</h5><ol type="1"><li>基本项：非空集 <span class="math inline">\(S_0\subseteqA\)</span></li><li>归纳项：一组规则，使得从A中元素出发，按照规则所获得的元素仍然是A中元素</li><li>极小化：A中每个元素都是通过有限次使用1或2获得的，如果集合 <spanclass="math inline">\(S\subseteq A\)</span> 也满足1和2，则 <spanclass="math inline">\(S=A\)</span></li></ol><h5 id="字符串集合">字符串集合</h5><p>字母表 <spanclass="math inline">\(\Sigma\)</span>：字母或符号的非空有限集合</p><p>字符串：由 <span class="math inline">\(\Sigma\)</span>中字母组成的有穷序列</p><p>字符串长度：字符串 <span class="math inline">\(x\)</span>所含字母的个数，记作 <span class="math inline">\(|x|\)</span></p><p>空串：若 <span class="math inline">\(|x|=0\)</span>，称 <spanclass="math inline">\(x\)</span> 为空串，记作 <spanclass="math inline">\(\varepsilon\)</span></p><p>字符串连接：设 <span class="math inline">\(\Sigma\)</span>是一字母表，<span class="math inline">\(x,y\)</span> 是 <spanclass="math inline">\(\Sigma\)</span> 上字符串，<spanclass="math inline">\(x=a_1a_2...a_n,y=b_1b_2...b_m\)</span> ，则 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 的连接记作 <spanclass="math inline">\(xy\)</span>，<spanclass="math inline">\(xy=a_1a_2...a_nb_1b_2...b_m\)</span>。另外规定：</p><ul><li><span class="math inline">\(x\varepsilon=\varepsilonx=x\)</span></li><li>n个 <span class="math inline">\(x\)</span> 的连接记作 <spanclass="math inline">\(x^n,x^0=\varepsilon,x^{n+1}=x^nx\)</span></li><li><span class="math inline">\(|x+y|=|x|+|y|\)</span></li></ul><p>字符串集合 <span class="math inline">\(\Sigma^*\)</span>：<spanclass="math inline">\(\Sigma\)</span>上的所有字符串构成的集合，其中非空字符串的集合记为 <spanclass="math inline">\(\Sigma^+\)</span>，<spanclass="math inline">\(\Sigma^*\)</span> 归纳定义如下</p><ol type="1"><li><spanclass="math inline">\(\{\varepsilon\}\cup\Sigma\subseteq\Sigma^*\)</span></li><li>若 <span class="math inline">\(x\in\Sigma^*\)</span> 且 <spanclass="math inline">\(a\in\Sigma\)</span>，则 <spanclass="math inline">\(xa\in\Sigma^*\)</span></li><li><span class="math inline">\(\Sigma^*\)</span>中的每一个元素都可以通过有限次应用上述1、2规则得到</li></ol><h4 id="语言">语言</h4><p><span class="math inline">\(\Sigma^*\)</span> 的子集称 <spanclass="math inline">\(\Sigma\)</span> 上的语言</p><p>语言的乘积：设A、B是 <span class="math inline">\(\Sigma\)</span>上的语言，则A与B的乘积记作 <span class="math inline">\(AB=\{xy|x\inA\land y\in B\}\)</span></p><p>语言的幂运算：<spanclass="math inline">\(A^0=\{\varepsilon\},A^{n+1}=A^nA\)</span></p><p>语言的闭包：<span class="math inline">\(A^*={\varepsilon\cup A\cupA^2\cup......}\)</span>，正闭包 <span class="math inline">\(A^+\)</span>没有 <span class="math inline">\(\varepsilon\)</span></p><h3 id="有序偶与笛卡尔积">有序偶与笛卡尔积</h3><p>有序偶：<spanclass="math inline">\(&lt;x,y&gt;=\{\{x\},\{x,y\}\}\)</span></p><p>笛卡尔积：<span class="math inline">\(A\times B=\{&lt;x,y&gt;|x\inA\land y\in B\}\)</span></p><p>笛卡尔积无交换律，但是对交、并、差满足分配律</p><h2 id="关系">关系</h2><h3 id="定义与性质">定义与性质</h3><p>设 <span class="math inline">\(n\in I^+\)</span>，且 <spanclass="math inline">\(A_1,A_2,...A_n\)</span> 为n个任意的集合，<spanclass="math inline">\(R\subseteq A_1\times A_2\times...\timesA_n\)</span>，称R为 <span class="math inline">\(A_1,A_2,...A_n\)</span>间的n元关系。<span class="math inline">\(&lt;x,y&gt;\inR\)</span>，则可表示成 <span class="math inline">\(xRy\)</span> ；<spanclass="math inline">\(&lt;x,y&gt;\notin R\)</span>，则可表示成 <spanclass="math inline">\(x\bar{R}y\)</span></p><p>全关系：<span class="math inline">\(R= A_1\times A_2\times...\timesA_n\)</span></p><p>A<strong>上</strong>的关系：<spanclass="math inline">\(A_1=A_2=...=A_n=A\)</span></p><p>恒等关系（X上的二元关系）：<spanclass="math inline">\(I_X=\{&lt;x,x&gt;|x\in X\}\)</span></p><p>从有限集到有限集的二元关系可用关系图、关系矩阵表示</p><p>设R是集合X上的二元关系：</p><ul><li>自反性：<span class="math inline">\(\forall x(x\inX\rightarrow&lt;x,x&gt;\in R)\Leftrightarrow I_X\subseteq R\)</span>，对角线元素为1、所有节点有自环</li><li>反自反：<span class="math inline">\(\forall x(x\inX\rightarrow&lt;x,x&gt;\notin R)\Leftrightarrow I_X\capR=\emptyset\)</span> ，对角线元素为0、所有节点无自环</li><li>对称性：<span class="math inline">\(\forall x\forall y(x\in X\landy\in X\land&lt;x,y&gt;\in R\rightarrow&lt;y,x&gt;\in R)\LeftrightarrowR=R^{-1}\)</span>， 对称矩阵、边成对出现</li><li>反对称：<span class="math inline">\(\forall x\forall y(x\in X\landy\in X\land&lt;x,y&gt;\in R\land&lt;y,x&gt;\in R\rightarrowx=y)\Leftrightarrow R\cap R^{-1}\subseteq I_X\)</span></li><li>传递性：<span class="math inline">\(\forall x\forall y \forallz(x\in X\land y\in X\land z\in X\land&lt;x,y&gt;\in R\land&lt;y,z&gt;\inR\rightarrow&lt;x,z&gt;\in R)\Leftrightarrow R\circ R\subseteqR\)</span>， x到y有路径，则x到y有边</li></ul><p>非空集上的空关系没有自反性，空集上的空关系具有全部性质</p><p>含有3个元素的集合A上的反对称关系共有216个（用矩阵考虑，且三角阵里是<span class="math inline">\(3^3\)</span>）</p><h3 id="关系的运算">关系的运算</h3><h4 id="交并补异或差">交并补、异或、差</h4><p>定义域与值域：</p><ul><li><span class="math inline">\(dom(R)=\{x\in A|\exists y\inB使得&lt;x,y&gt;\in R\}\)</span></li><li><span class="math inline">\(ran(R)=\{y\in B|\exists x\inA使得&lt;x,y&gt;\in R\}\)</span></li><li><span class="math inline">\(dom(R_1\cup R_2)=dom(R_1)\cupdom(R_2)\)</span></li><li><span class="math inline">\(ran(R_1\cap R_2)\subseteq ran(R_1)\capran(R_2)\)</span> （<strong>注意交集的情况下不会相等</strong>）</li></ul><table><thead><tr class="header"><th style="text-align: center;">R,S</th><th style="text-align: center;"><span class="math inline">\(R\capS\)</span></th><th style="text-align: center;"><span class="math inline">\(R\cupS\)</span></th><th style="text-align: center;"><spanclass="math inline">\(R-S\)</span></th><th style="text-align: center;"><span class="math inline">\(R\oplusS\)</span></th><th style="text-align: center;"><span class="math inline">\(\simR\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">自反</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">反自反</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">对称</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="even"><td style="text-align: center;">反对称</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">传递</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>逆关系相当于矩阵转置，保持原有关系的5个性质</p><h4 id="复合运算">复合运算</h4><p><span class="math inline">\(R\circ S=\{&lt;x,z&gt;|\exists y\inY使得xRy\land ySz\}\)</span></p><p>若R是A上的关系，则 <span class="math inline">\(R^0=I_A\)</span> ，<span class="math inline">\(R^{n+1}=R^n\circ R\)</span></p><p>有时也记 <spanclass="math inline">\(R^{+}=\cup_{i=1}^{\infty}R^i\)</span></p><p>无交换律，有结合律</p><p>设 <span class="math inline">\(R_1\subseteq A\times B,\R_2,R_3\subseteq B\times C，R_4\subseteq C\times D\)</span>，则</p><ul><li><p><span class="math inline">\(R_1\circ(R_2\cup R_3)=(R_1\circR_2)\cup(R_1\circ R_3)\)</span></p></li><li><p><span class="math inline">\(R_1\circ(R_2\capR_3)\subseteq(R_1\circ R_2)\cap(R_1\circR_3)\)</span>（<strong>注意交集的情况下可能不会相等</strong>）</p></li><li><p><span class="math inline">\((R_1\circ R_2)^{-1}=R_2^{-1}\circR_1^{-1}\)</span></p></li></ul><p>复合运算仅能保持5个性质中的自反性</p><h4 id="闭包">闭包</h4><p>定义：设R是集合A上的关系，称R‘是R的自反（对称、传递）闭包，当且仅当</p><ol type="1"><li>R'是自反（对称、传递）的</li><li><span class="math inline">\(R\subseteq R&#39;\)</span></li><li>对于A上的任何自反（对称、传递）关系R''，如果 <spanclass="math inline">\(R\subseteq R&#39;&#39;\)</span> ，则 <spanclass="math inline">\(R&#39;\subseteq R&#39;&#39;\)</span></li></ol><p>R的自反（对称、传递）闭包即包含R的最小自反（对称、传递）关系</p><ul><li>R自反：<span class="math inline">\(r(R)=R=R\cup I_A\)</span></li><li>R对称：<span class="math inline">\(s(R)=R=R\cup R^{-1}\)</span></li><li>R传递：<spanclass="math inline">\(t(R)=R=\cup_{n=1}^{\infty}R^n\)</span></li><li><span class="math inline">\(t(R)=\cup_{i=1}^{\#A}R^i\)</span></li></ul><p>闭包运算保持集合上的包含关系，但传递闭包不保持关系的并</p><ul><li><span class="math inline">\(r(R_1\cup R_2)=r(R_1)\cupr(R_2)\)</span></li><li><span class="math inline">\(s(R_1\cup R_2)=s(R_1)\cups(R_2)\)</span></li><li><span class="math inline">\(t(R_1)\cup t(R_2)\subseteq t(R_1\cupR_2)\)</span></li></ul><table><thead><tr class="header"><th style="text-align: center;">R</th><th style="text-align: center;">r(R)</th><th style="text-align: center;">s(R)</th><th style="text-align: center;">t(R)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">自反性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="even"><td style="text-align: center;">对称性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr><tr class="odd"><td style="text-align: center;">传递性</td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(\checkmark\)</span></td></tr></tbody></table><h3 id="次序">次序</h3><h4 id="各种序">各种序</h4><ul><li><p>偏序关系：A上二元关系R，且R自反、反对称、传递。用 <spanclass="math inline">\(&lt;A,\le&gt;\)</span> 表示偏序结构</p></li><li><p>全序关系：<span class="math inline">\(&lt;A,\le&gt;\)</span>是一个偏序结构，若 <span class="math inline">\((\forall xy)(x\in A\landy\in A\rightarrow x\le y\lor y\le x)\)</span>，则称 <spanclass="math inline">\(\le\)</span> 为A上的全序（线序），并称 <spanclass="math inline">\(&lt;A,\le&gt;\)</span> 为全序结构（链）</p></li><li><p>严格偏序关系：A上二元关系R，且R反自反、传递</p></li><li><p>覆盖：y是x的覆盖 <span class="math inline">\(\Leftrightarrowx&lt;y\land\neg\exists z(z\in A\land x&lt;z\landz&lt;y)\)</span></p></li><li><p>良序：偏序结构 <spanclass="math inline">\(&lt;A,\le&gt;\)</span>，若A的每一个非空子集都有一个最小元，则称<span class="math inline">\(\le\)</span> 为良序关系，<spanclass="math inline">\(&lt;A,\le&gt;\)</span> 为良序结构</p></li></ul><p>良序的充要条件：全序+非空子集有极小元；全序+不存在A中元素的无穷递降序列</p><h4 id="特殊元素">特殊元素</h4><p><span class="math inline">\(&lt;A,\le&gt;\)</span> 是偏序结构，并且<span class="math inline">\(S\subseteq A,S\ne\emptyset\)</span></p><ul><li>S的最大元：<span class="math inline">\(b\in S\land\forall x(x\inS\rightarrow x\le b)\)</span></li><li>S的最小元：<span class="math inline">\(b\in S\land\forall x(x\inS\rightarrow b\le x)\)</span></li><li>S的极大元：<span class="math inline">\(b\in S\land\forall x(x\inS\land b\le x\rightarrow x=b)\)</span></li><li>S的极小元：<span class="math inline">\(b\in S\land\forall x(x\inS\land x\le b\rightarrow x=b)\)</span></li><li>S的上界：<span class="math inline">\(b\in A\land\forall x(x\inS\rightarrow x\le b)\)</span></li><li>S的下界：<span class="math inline">\(b\in A\land\forall x(x\inS\rightarrow b\le x)\)</span></li></ul><p>注意S的上下界可能不在S中</p><h3 id="等价关系">等价关系</h3><ul><li><p>相容关系：A上关系R自反、对称</p></li><li><p>等价关系：A上关系R自反、对称、传递<spanclass="math inline">\(\Leftrightarrow r(R)=s(R)=t(R)=R\)</span></p></li></ul><p>R是A上二元关系，则 <spanclass="math inline">\(tsr(R)、trs(R)、rts(R)\)</span>都是A上的等价关系（t在s之后）</p><p>设R是A上等价关系</p><ul><li><p>等价类：<span class="math inline">\([x]_R=\{y|y\in A\landxRy\}\)</span></p></li><li><p>商集：<span class="math inline">\(A/R=\{[x]_R|x\in A\}\)</span>，称 <span class="math inline">\(n(A/R)\)</span> 为R的秩</p></li></ul><h4 id="划分">划分</h4><p>定义：设 <spanclass="math inline">\(\Pi\subseteq\mathcal{P}(A)\)</span> ，且有</p><ol type="1"><li>若 <span class="math inline">\(S\in\Pi\)</span> ，则 <spanclass="math inline">\(S\ne\emptyset\)</span></li><li><span class="math inline">\(\cup\Pi=A\)</span></li><li>若<span class="math inline">\(S_1,S_2\in\Pi\)</span> ，且 <spanclass="math inline">\(S_1\cap S_2\ne\emptyset\)</span>，则 <spanclass="math inline">\(S_1=S_2\)</span></li></ol><p>若R为A上的等价关系，则商集 <spanclass="math inline">\(A/R=\{[x]_R|x\in A\}\)</span> 为A的一个划分</p><p>若 <span class="math inline">\(\Pi\)</span> 为A的一个划分，则 <spanclass="math inline">\(R_{\Pi}=\{&lt;x,y&gt;|\exists S\in\Pi,使x,y\inS\}\)</span> 为A上的等价关系，且 <spanclass="math inline">\(A/R_{\Pi}=\Pi\)</span></p><h2 id="函数">函数</h2><h3 id="部分函数相关概念">部分函数相关概念</h3><p>部分函数：从X到Y的二元关系f满足 <spanclass="math inline">\(&lt;x,y_1&gt;\in f\land&lt;x,y_2&gt;\inf\rightarrow y_1=y_2\)</span> ，记作 <spanclass="math inline">\(y=f(x)\)</span></p><p>定义域：<span class="math inline">\(dom(f)=\{x\in X|\exists y\inY使y=f(x)\}\)</span> 。<span class="math inline">\(x\in dom(f)\)</span>称f在x处有定义，记为 <span class="math inline">\(f(x)\uparrow\)</span>，反之记为 <span class="math inline">\(f(x)\downarrow\)</span></p><p>值域：<span class="math inline">\(ran(f)=\{y\in Y|\exists x\inX使y=f(x)\}\)</span></p><p><span class="math inline">\(dom(g\circ f)=f^{-1}[dom\ g],ran(g\circf)=g[ran\ f]\)</span></p><p>严格部分函数：<span class="math inline">\(dom f\subset X\)</span></p><p>从X到Y<strong>上</strong>的部分函数：<span class="math inline">\(ranf=Y\)</span></p><p>从X到Y<strong>内</strong>的部分函数：<span class="math inline">\(ranf\subset Y\)</span></p><p>1-1部分函数：<span class="math inline">\(\forall x_1,x_2\in domf,当x_1\ne x_2时,均有f(x_1)\ne f(x_2)\)</span></p><p><span class="math inline">\(A\subseteq X,B\subseteq Y\)</span>像：<span class="math inline">\(f[A]=\{y\in Y|\exists x\inA使y=f(x)\}\)</span> 源像：<span class="math inline">\(f^{-1}[B]=\{x\inX|\exists y\in B使y=f(x)\}\)</span></p><h3 id="函数相关概念">函数相关概念</h3><ul><li>函数（全函数）：<span class="math inline">\(dom f=X\)</span>，记为<span class="math inline">\(f:X\rightarrow Y\)</span></li><li>限制：<span class="math inline">\(f:X\rightarrow Y,A\subseteqX\)</span>，称 <span class="math inline">\(f\cap(A\times Y)\)</span>是从A到Y的函数，f在A上的限制，记作 <spanclass="math inline">\(f|_A\)</span>。f为 <spanclass="math inline">\(f|_A\)</span> 到X的延拓</li><li>记A到B的函数的集合为 <spanclass="math inline">\(B^A=\{f|f:A\rightarrow B\}\)</span> ，则有 <spanclass="math inline">\(n(B^A)=(n(B))^{n(A)}\)</span></li><li>单射（内射）：<span class="math inline">\(\forall x_1\forallx_2(x_1\in X\land x_2\in X\land f(x_1)=f(x_2)\rightarrowx_1=x_2)\)</span></li><li>满射：<span class="math inline">\(ranf=Y\)</span></li><li>双射：单射+满射</li><li>*自然映射/正则映射：设R是集合A上的等价关系，<spanclass="math inline">\(\varphi=\{&lt;x,[x]_R&gt;|x\in A\}\)</span></li></ul><p><strong>注意空关系！</strong></p><p>设X是任意集合、f和g都是X到R的函数</p><p><span class="math inline">\(f\leqslant g:\forall x\in X\rightarrowf(x)\leqslant g(x)\)</span></p><p><span class="math inline">\(f+g:\forall x\in X\rightarrow(f+g)(x)=f(x)+g(x)\)</span> ，称 <spanclass="math inline">\(f+g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的和</p><p><span class="math inline">\(f-g:\forall x\in X\rightarrow(f-g)(x)=f(x)-g(x)\)</span> ，称 <spanclass="math inline">\(f-g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的差</p><p><span class="math inline">\(f*g:\forall x\in X\rightarrow(f*g)(x)=f(x)*g(x)\)</span> ，称 <spanclass="math inline">\(f*g\)</span> 为 <spanclass="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的积</p><h3 id="函数的复合">函数的复合</h3><p>设f是从X到Y的（部分）函数，g为从Y到Z的（部分）函数，则复合关系 <spanclass="math inline">\(f\circ g\)</span> 是从X到Y的（部分）函数，记为<span class="math inline">\(g\circ f=\{&lt;x,z&gt;|x\in X\land z\inZ\land \exists y(y\in Y\land y=f(x)\land z=g(y))\}\)</span></p><p><span class="math inline">\(f:X\rightarrow X\)</span>，则f的n次幂记为<span class="math inline">\(f^n=f\circ f^{n-1}\)</span> ……</p><p><span class="math inline">\(g\circ f\)</span>可以传递满射、单射、双射的性质（f与g均满足时）</p><p>逆向推导“左满右单”（<span class="math inline">\(f:X\rightarrowY,g:Y\rightarrow Z\)</span>）：</p><ul><li>若 <span class="math inline">\(g\circ f\)</span> 是满射，则 <spanclass="math inline">\(g\)</span> 是满射</li><li>若 <span class="math inline">\(g\circ f\)</span> 是单射，则 <spanclass="math inline">\(f\)</span> 是单射</li><li>若 <span class="math inline">\(g\circ f\)</span> 是双射，则 <spanclass="math inline">\(g\)</span> 是满射且 <spanclass="math inline">\(f\)</span> 是单射</li></ul><h3 id="逆函数">逆函数</h3><h4 id="定义">定义</h4><p><span class="math inline">\(f:X\rightarrow Y\)</span></p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(g\circ f=I_X\)</span>，称f为左可逆，g为f的一个左逆函数（左逆）</p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(f\circ g=I_Y\)</span>，称f为右可逆，g为f的一个右逆函数（右逆）</p><p>若有 <span class="math inline">\(g:Y\rightarrow X\)</span> 使 <spanclass="math inline">\(g\circ f=I_X\)</span> 且 <spanclass="math inline">\(f\circ g=I_Y\)</span>，称f可逆，g为f的一个逆函数（逆）</p><h4 id="充要条件">充要条件</h4><p>设 <span class="math inline">\(X\ne \emptyset\)</span> ，若 <spanclass="math inline">\(f:X\rightarrow Y\)</span> ，则以下条件等价</p><ul><li>f为单射</li><li>f左可逆</li><li>f可左消去，即对任意Z、任意 <spanclass="math inline">\(g:Z\rightarrow X\)</span> 和 <spanclass="math inline">\(h:Z\rightarrow X\)</span>，当 <spanclass="math inline">\(f\circ g=f\circ h\)</span> 时，都有 <spanclass="math inline">\(g=h\)</span></li></ul><p>设 <span class="math inline">\(f:X\rightarrow Y\)</span>，则以下条件等价</p><ul><li>f为满射</li><li>f右可逆</li><li>f可右消去，即对任意Z、任意 <spanclass="math inline">\(g:Y\rightarrow Z\)</span> 和 <spanclass="math inline">\(h:Y\rightarrow Z\)</span>，当 <spanclass="math inline">\(g\circ f=h\circ f\)</span> 时，都有 <spanclass="math inline">\(g=h\)</span></li></ul><p><span class="math inline">\(f:X\rightarrow Y\)</span>，则 <spanclass="math inline">\(f\)</span> 是双射 <spanclass="math inline">\(\Leftrightarrow f\)</span> 可逆</p><p><span class="math inline">\(f:X\rightarrow Y,g:Y\rightarrowZ\)</span> 都可逆，则 <span class="math inline">\(g\circ f\)</span>可逆，且 <span class="math inline">\((g\circ f)^{-1}=f^{-1}\circg^{-1}\)</span></p><h3 id="特征函数">特征函数</h3><h4 id="定义-1">定义</h4><p>设 <span class="math inline">\(U\)</span> 是全集，<spanclass="math inline">\(A\)</span> 是 <spanclass="math inline">\(U\)</span> 的子集，<spanclass="math inline">\(A\)</span> 的特征函数为 <spanclass="math inline">\(\chi_A(x):U\rightarrow R\)</span> <spanclass="math display">\[\chi_A(x)=\begin{cases} 1,x\in A\\0,x\notin A \end{cases}\]</span></p><h4 id="性质">性质</h4><p><span class="math inline">\(\forall x(\chi_A(x)=0)\LeftrightarrowA=\emptyset\)</span></p><p><span class="math inline">\(\forall x(\chi_A(x)=1)\LeftrightarrowA=U\)</span></p><p><span class="math inline">\(\forallx(\chi_A(x)\leqslant\chi_B(x))\Leftrightarrow A\subseteq B\)</span></p><p><span class="math inline">\(\forallx(\chi_A(x)=\chi_B(x))\Leftrightarrow A=B\)</span></p><h4 id="运算">运算</h4><p><span class="math inline">\(\chi_A*\chi_A=\chi_A\)</span></p><p><span class="math inline">\(\chi_A*\chi_B=\chi_A\LeftrightarrowA\subseteq B\)</span></p><p>交：<span class="math inline">\(\chi_{A\capB}=\chi_A*\chi_B\)</span></p><p>并：<span class="math inline">\(\chi_{A\cupB}=\chi_A+\chi_B-\chi_A*\chi_B\)</span></p><p>补：<span class="math inline">\(\chi_{\sim A}=1-\chi_A\)</span></p><p>差：<spanclass="math inline">\(\chi_{A-B}=\chi_A-\chi_A*\chi_B\)</span></p><h2 id="自然数基数与归纳法">自然数、基数与归纳法</h2><h3 id="自然数与归纳法">自然数与归纳法</h3><p>后继：A的后继 <span class="math inline">\(A^{+}=A\cup\{A\}\)</span>，每个集合的后继唯一</p><h4 id="自然数的归纳定义">自然数的归纳定义：</h4><ol type="1"><li><p><span class="math inline">\(0\in N\)</span> ，此处 <spanclass="math inline">\(0=\emptyset\)</span></p></li><li><p>若 <span class="math inline">\(n\in N\)</span>，则 <spanclass="math inline">\(n^{+}\in N\)</span></p></li><li><p>若 <span class="math inline">\(S\subseteq N\)</span>，且满足</p><p>a.<span class="math inline">\(0\in S\)</span></p><p>b.如果 <span class="math inline">\(n\in S\)</span> ，则 <spanclass="math inline">\(n^{+}\in S\)</span></p><p>则 <span class="math inline">\(S=N\)</span></p></li></ol><h4 id="自然数的运算">自然数的运算</h4><p>对于每个自然数n，都有 <span class="math inline">\(n\in n^{+}\)</span>且 <span class="math inline">\(n\subseteq n^{+}\)</span> ，<spanclass="math inline">\(\cup n^{+}=n\)</span></p><p><span class="math inline">\(m&lt;n\)</span>：<spanclass="math inline">\(m,n\in N,m\in n\)</span></p><p>+：<span class="math inline">\(m+0=m,m+n^{+}=(m+n)^{+}\)</span></p><p><span class="math inline">\(\cdot\)</span>：<spanclass="math inline">\(m\cdot0=0,m\cdot n^{+}=m\cdot n+m\)</span></p><h4 id="自然数系统与皮亚诺公理">自然数系统与皮亚诺公理</h4><p>定义加法与乘法后，得到自然数系统 <spanclass="math inline">\(&lt;N,+,\cdot&gt;\)</span></p><p>这样构造的自然数系统满足以下皮亚诺公理：</p><ol type="1"><li><span class="math inline">\(0\in N\)</span></li><li>若 <span class="math inline">\(n\in N\)</span> ，则有唯一后继 <spanclass="math inline">\(n^{+}\in N\)</span></li><li>若 <span class="math inline">\(n\in N\)</span> ，则有 <spanclass="math inline">\(n^{+}\ne0\)</span></li><li>若 <span class="math inline">\(n,m\in N\)</span> 且 <spanclass="math inline">\(n^{+}=m^{+}\)</span> ，则 <spanclass="math inline">\(n=m\)</span></li><li>若 <span class="math inline">\(S\subseteq N\)</span> 满足 <spanclass="math inline">\(0\in S\)</span>、如果 <spanclass="math inline">\(n\in S\)</span> 则 <spanclass="math inline">\(n^{+}\in S\)</span> ，则 <spanclass="math inline">\(S=N\)</span></li></ol><p>作为集合的自然数满足</p><ul><li>传递性：若 <span class="math inline">\(n_1\in n_2\)</span> 且 <spanclass="math inline">\(n_2\in n_3\)</span> ，则 <spanclass="math inline">\(n_1\in n_3\)</span></li><li>三歧性：对于任意两个自然数 <spanclass="math inline">\(n_1,n_2\)</span> ，下式恰有一个成立：<spanclass="math inline">\(n_1\in n_2,n_1=n_2,n_2\in n_1\)</span></li><li>良基性：不存在一个自然数的无穷递降序列</li></ul><h4 id="数学归纳法">数学归纳法</h4><h5 id="第一种">第一种</h5><p>设 <span class="math inline">\(N_n=\{0,1,...,n-1\}\)</span> ，<spanclass="math inline">\(\bar{N}_n=N-N_n={n,n+1,...}\)</span> ， <spanclass="math inline">\(n_0\in N\)</span></p><p>若对每个 <span class="math inline">\(n\in \bar{N}_{n0}\)</span>，命题 <span class="math inline">\(P(n)\)</span> 满足：</p><ol type="1"><li><span class="math inline">\(P(n_0)\)</span> 真</li><li>对任意 <span class="math inline">\(n\in \bar{N}_{n0}\)</span> ，若<span class="math inline">\(P(n)\)</span> 为真，则 <spanclass="math inline">\(P(n^{+})\)</span> 也为真</li></ol><p>则对所有 <span class="math inline">\(n\in\bar{N}_{n0}\)</span>，<span class="math inline">\(P(n)\)</span> 都为真</p><h5 id="第二种">第二种</h5><p>设 <span class="math inline">\(n_0\in N\)</span> ，若对每个 <spanclass="math inline">\(n\in \bar{N}_{n0}\)</span> ，<spanclass="math inline">\(P(n)\)</span> 满足：</p><ol type="1"><li><span class="math inline">\(P(n_0)\)</span> 为真</li><li>对任何自然数 <span class="math inline">\(n&gt;n_0\)</span> ，若当<span class="math inline">\(k\in N\)</span> ，且 <spanclass="math inline">\(n_0\leqslant k&lt;n\)</span> 时 <spanclass="math inline">\(P(k)\)</span> 为真，则 <spanclass="math inline">\(P(n)\)</span> 也为真</li></ol><p>则对所有 <span class="math inline">\(n\in\bar{N}_{n0}\)</span>，<span class="math inline">\(P(n)\)</span> 都为真</p><h5 id="二重归纳">二重归纳</h5><p>设 <span class="math inline">\(i_0,j_0\in N\)</span> ，对任意自然数<span class="math inline">\(i\geqslant i_0,j\geqslant j_0\)</span>，都有命题 <span class="math inline">\(P(i,j)\)</span> 满足</p><ol type="1"><li><span class="math inline">\(P(i_0,j_0)\)</span> 为真</li><li>对任意自然数 <span class="math inline">\(k\geqslant i_0,l\geqslantj_0\)</span> ，若 <span class="math inline">\(P(k,l)\)</span> 为真，则<span class="math inline">\(P(k+1,l)\)</span> 和 <spanclass="math inline">\(P(k,l+1)\)</span> 都为真</li></ol><p>则对任意自然数 <span class="math inline">\(i\geqslant i_0,j\geqslantj_0\)</span> ，<span class="math inline">\(P(i,j)\)</span> 都为真</p><h3 id="基数">基数</h3><h4 id="概念">概念</h4><p>等势：若存在从集合A到集合B的双射，则称A、B等势，记为 <spanclass="math inline">\(A\sim B\)</span></p><p>有穷与无穷：设 <span class="math inline">\(n={0,1,...n-1}\)</span>，若存在 <span class="math inline">\(n\in N\)</span> 使 <spanclass="math inline">\(A\sim N\)</span> ，称A为有穷集，否则为无穷集</p><p>有穷集的基数：即元素个数，表示为 <spanclass="math inline">\(\#(A),card(A),n(A)或|A|\)</span> ，且若 <spanclass="math inline">\(A\sim n\)</span>，则 <spanclass="math inline">\(\#(A)=n\)</span></p><p>无穷集的基数：<span class="math inline">\(\#(N)=\aleph_0\)</span></p><p>可数集：可数无穷集合+有穷集</p><p>可数无穷集合：任何与自然数集等势的集合</p><p>不可数集：无穷且不可数</p><h4 id="基数的大小">基数的大小</h4><p><span class="math inline">\(A\sim B\)</span> ，则基数相等，记为 <spanclass="math inline">\(\#(A)=\#(B)\)</span></p><p>存在从A到B的<strong>单射</strong>，则 <spanclass="math inline">\(\#(A)\leqslant\#(B)\)</span></p><p>若 <span class="math inline">\(\#(A)\leqslant\#(B)\)</span> 且 <spanclass="math inline">\(\#(A)\ne\#(B)\)</span> ，则 <spanclass="math inline">\(\#(A)&lt;\#(B)\)</span></p><p>对每个集合A，<spanclass="math inline">\(\#A&lt;\#\mathcal{P}(A)\)</span> ，且 <spanclass="math inline">\(\#(R)=\#\mathcal{P}(N)=\aleph\)</span>（二进制+特征函数证明）</p><p>定义 <spanclass="math inline">\(f:\mathcal{P}(N)\rightarrow[0,1]\)</span> <spanclass="math display">\[f(A)=\begin{cases}0,A=\emptyset\\1,A=N\\\sum\limits_{i=0}^{\infty}\dfrac{\chi_A(i)}{2^{i+1}}\end{cases}\]</span> 可证</p><h2 id="图论">图论</h2><h3 id="基础概念">基础概念</h3><h4 id="定义-2">定义</h4><p>设V、E是有限集合且V非空</p><p><strong>无向图</strong>：如果 <spanclass="math inline">\(\Psi:E\rightarrow\{\{v_1,v_2\}|v_1\in V且v_2\inV\}\)</span> ，则称 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> 为无向图</p><p><strong>有向图</strong>：<spanclass="math inline">\(\Psi:E\rightarrow V\times V\)</span>，则G为有向图</p><p>称V为<strong>结点集</strong>，E为<strong>边集</strong>，结点数目称<strong>阶</strong></p><p>若有 <span class="math inline">\(\Psi(e)=\{v_1,v_2\}\)</span> 或<span class="math inline">\(\Psi(e)=&lt;v_1,v_2&gt;\)</span> ，称e与<span class="math inline">\(v_1\)</span>互相<strong>关联</strong>，<span class="math inline">\(v_1\)</span> 与<span class="math inline">\(v_2\)</span> <strong>临接</strong>，无向图中<span class="math inline">\(v_1,v_2\)</span> 既是起点又是终点，有向图中<span class="math inline">\(v_1\)</span> 为起点，<spanclass="math inline">\(v_2\)</span> 为终点</p><p>若 <span class="math inline">\(e\)</span>关联的两个结点相同，则e为<strong>自圈</strong>（自环）。若 <spanclass="math inline">\(\Psi(e_1)=\Psi(e_2)\)</span> ，称 <spanclass="math inline">\(e_1\)</span> 与 <spanclass="math inline">\(e_2\)</span> <strong>平行</strong>（重边）</p><p><strong>简单图</strong>：G无自圈，无平行边</p><p>无向图中与v关联的边的数目之和称<strong>度</strong>，记为 <spanclass="math inline">\(d_G(v)\)</span></p><p>有向图中以v为起点的边的数目为v的<strong>出度</strong>，记为 <spanclass="math inline">\(d_G^{+}(v)\)</span>；以v为终点的边的数目为v的<strong>入度</strong>，记为<span class="math inline">\(d_G^{-}(v)\)</span> ；出度+入度=度，记为<span class="math inline">\(d_G(v)\)</span></p><p>度为奇数称<strong>奇结点</strong>，偶数为<strong>偶结点</strong>，0为<strong>孤立点</strong>，1为<strong>端点</strong>。</p><h4 id="定理">定理</h4><p>握手定理：设图G中有m条边，则 <span class="math inline">\(\sum_{v\inV}d_G(v)=2m\)</span></p><p>任何图中都有偶数个奇结点</p><h4 id="特殊的图">特殊的图</h4><p><strong>零图</strong>：结点都是孤立点的图</p><p><strong>平凡图</strong>：一阶零图</p><p><strong>d度正则图</strong>：所有结点的度均为自然数d的无向图</p><p><strong>完全无向图</strong>：n阶简单无向图G是n-1度正则图，则是完全无向图，记为<span class="math inline">\(K_n\)</span></p><p><strong>完全有向图</strong>：每个结点的出度与入度均为n-1的n阶简单有向图</p><p>零图也是正则图，正则图不一定是完全图</p><p><strong>圈图</strong>：结点恰形成一圈的n阶简单无向图（<spanclass="math inline">\(n\geqslant3\)</span>）</p><p><strong>轮图</strong>：n-1个结点形成一个圈图，且第n个结点与圈图上的每个结点邻接的n阶简单无向图（<spanclass="math inline">\(n\geqslant3\)</span>）</p><p><strong>立方图</strong>：</p><h3 id="图的运算">图的运算</h3><h4 id="同构">同构</h4><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span>，如果存在双射 <span class="math inline">\(f:V\rightarrowV&#39;,g:E\rightarrow E&#39;\)</span> 使得任意 <spanclass="math inline">\(e\in E\)</span> 及 <spanclass="math inline">\(v_1,v_2\in V\)</span> 都有 <spanclass="math inline">\(\Psi&#39;(g(e))=\{f(v_1),f(v_2)\}\)</span> 或<span class="math inline">\(&lt;f(v_1),f(v_2)&gt;\)</span>，则称G与G‘同构，记作 <span class="math inline">\(G\congG&#39;\)</span>，称f与g为G与G’间的同构映射。</p><p>必要条件：结点个数、边数、结点度数相同</p><p>相互同构的图的补图仍相互同构</p><p>当不要求f、g是双射时，称<strong>同态</strong></p><h4 id="子图">子图</h4><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span></p><p><strong>子图</strong>：<span class="math inline">\(V&#39;\subseteqV,E&#39;\subseteq E,\Psi\subseteq\Psi\)</span> ，记为 <spanclass="math inline">\(G&#39;\subseteq G\)</span></p><p><strong>真子图</strong>：<span class="math inline">\(V&#39;\subseteqV,E&#39;\subset E,\Psi\subset\Psi\)</span> ，记为 <spanclass="math inline">\(G&#39;\subset G\)</span></p><p><strong>生成子图</strong>：<spanclass="math inline">\(V&#39;=V,E&#39;\subseteqE,\Psi\subseteq\Psi\)</span></p><p><strong>结点导出子图</strong>： <spanclass="math inline">\(V&#39;\subseteq V,V&#39;\ne\emptyset\)</span>，以V'为结点集合，以所有起点和终点均在V'中的边的全体为边集的G的子图，记为<span class="math inline">\(G[V&#39;]\)</span> 。当 <spanclass="math inline">\(V&#39;\subset V\)</span> 时，导出子图 <spanclass="math inline">\(G[V-V&#39;]\)</span> 记为 <spanclass="math inline">\(G-V&#39;\)</span></p><p><strong>边导出子图</strong>：<spanclass="math inline">\(E&#39;\subseteqE,E&#39;\ne\emptyset,V&#39;=\{v|v\in V且\exists e\inE&#39;使v与e关联\}\)</span> ，记为 <spanclass="math inline">\(G[E&#39;]\)</span></p><h4 id="一些运算">一些运算</h4><h5 id="可运算">可运算</h5><p>设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V&#39;,E&#39;,\Psi&#39;&gt;\)</span>同为无向图或有向图</p><p>若对任意 <span class="math inline">\(e\in E\cap E&#39;\)</span> 均有<span class="math inline">\(\Psi(e)=\Psi&#39;(e)\)</span>，则称G和G‘可运算</p><p>若 <span class="math inline">\(V\cap V&#39;=E\capE&#39;=\emptyset\)</span> ，则称G和G’不相交</p><p>若 <span class="math inline">\(E\cap E&#39;=\emptyset\)</span>，则称G和G’边不相交</p><h5 id="交并环和">交、并、环和</h5><p>设图 <spanclass="math inline">\(G_1=&lt;V_1,E_1,\Psi_1&gt;,G_2=&lt;V_2,E_2,\Psi_2&gt;\)</span>可运算</p><p>交：<span class="math inline">\(G_1\cap G_2=&lt;V_1\cap V_2,E_1\capE_2,\Psi_1\cap\Psi_2&gt;\)</span> 。以 <spanclass="math inline">\(V_1\cap V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\cap E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1,G_2\)</span> 的公共子图。</p><p>并：<span class="math inline">\(G_1\cup G_2=&lt;V_1\cup V_2,E_1\cupE_2,\Psi_1\cup\Psi_2&gt;\)</span> 。以 <spanclass="math inline">\(V_1\cup V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\cup E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1,G_2\)</span> 的公共母图。</p><p>环和：<span class="math inline">\(G_1\oplus G_2=&lt;V_1\cupV_2,E_1\oplus E_2,\Psi_1\cup\Psi_{2E_1\oplus E_2}&gt;\)</span> 。以<span class="math inline">\(V_1\cup V_2\)</span> 为节点集合、<spanclass="math inline">\(E_1\oplus E_2\)</span> 为边集合的 <spanclass="math inline">\(G_1\cup G_2\)</span> 的子图。</p><h5 id="边的增删">边的增删</h5><p>删边：设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,E&#39;\subseteq E\)</span> ，记<spanclass="math inline">\(&lt;V,E-E&#39;,\Psi|_{(E-E&#39;)}&gt;\)</span> 为<span class="math inline">\(G-E&#39;\)</span></p><p>增边：设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;,G&#39;=&lt;V,E&#39;,\Psi&#39;&gt;\)</span>同为无向图或有向图，若两图边不想交，且G‘无孤立点，则记 <spanclass="math inline">\(G\cup G&#39;\)</span> 为 <spanclass="math inline">\(G+E&#39;_{\Psi&#39;}\)</span></p><h5 id="补图">补图</h5><p>设n阶无向图 <span class="math inline">\(G=&lt;V,E,\Psi&gt;\)</span>是n阶完全无向图 <span class="math inline">\(K_n\)</span>的生成子图，则称 <span class="math inline">\(K_n-E\)</span>为G的补图，记为 <span class="math inline">\(\bar{G}\)</span></p><p><strong>自补图</strong>：与其补图同构的简单无向图图</p><h3 id="路径">路径</h3><h4 id="基本概念">基本概念</h4><p>设 <span class="math inline">\(n\inN；v_0,v_1,...,v_n；e_1,e_2,...,e_n\)</span> 是图G的结点、边，并且 <spanclass="math inline">\(v_{i-1}\)</span> 和 <spanclass="math inline">\(v_i\)</span> 分别是 <spanclass="math inline">\(e_i\)</span> 的起点和终点，则称序列 <spanclass="math inline">\(v_0e_1v_1e_2...v_{n-1}e_nv_n\)</span> 为图G中从<span class="math inline">\(v_0\)</span> 至 <spanclass="math inline">\(v_n\)</span> 的<strong>路径（链）</strong>， <spanclass="math inline">\(n\)</span> 称该路径的<strong>长度</strong></p><p><span class="math inline">\(v_0=v_n\)</span>，称该路径为<strong>闭</strong>的，否则是<strong>开</strong>的</p><p>边互不相同称<strong>简单路径（迹）</strong>，结点互不相同称<strong>基本路径（路径）</strong></p><p>图中存在从 <span class="math inline">\(v\)</span> 至 <spanclass="math inline">\(v&#39;\)</span> 的路径，则存在从 <spanclass="math inline">\(v\)</span> 至 <spanclass="math inline">\(v&#39;\)</span> 的基本路径</p><p>n阶图中的基本路径长度小于n</p><p>若图G中存在从 <span class="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的路径，则称在G中从 <spanclass="math inline">\(v_1\)</span> <strong>可达</strong> <spanclass="math inline">\(v_2\)</span> ，用 <spanclass="math inline">\(R(v)\)</span> 表示从v可达的全体结点的集合</p><p>若从 <span class="math inline">\(v_1\)</span> 可达 <spanclass="math inline">\(v_2\)</span> ，则称从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的路径中长度最短者为从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span>的<strong>测地线</strong>，该测地线的长度为从 <spanclass="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的<strong>距离</strong>，记作 <spanclass="math inline">\(d(v_1,v_2)\)</span> 。不可达则 <spanclass="math inline">\(d(v_1,v_2)=\infty\)</span></p><p>图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>的<strong>直径</strong>定义为 <spanclass="math inline">\(\max_{v,v&#39;\in V}d(v,v&#39;)\)</span></p><p><strong>加权图</strong>：设图 <spanclass="math inline">\(G&lt;V,E,\Psi&gt;\)</span> ，若 <spanclass="math inline">\(W:E\rightarrow R_{+}\)</span> ，则称 <spanclass="math inline">\(&lt;G,W&gt;\)</span> 为加权图。</p><p>边 <span class="math inline">\(e\in E\)</span> ，称 <spanclass="math inline">\(W(e)\)</span>为e的<strong>加权长度</strong>，路径中所有边的加权长度之和为该路径的加权长度，类似有最短路径、加权距离</p><h4 id="连通性">连通性</h4><h6 id="无向图">无向图</h6><p>若图G的任意两个结点都相互可达，则称G是<strong>连通</strong>的</p><p>连通的充分条件：n阶简单无向图任意两个结点的度数之和大于等于n-1</p><p><strong>极大子图</strong>：设G‘是图G的具有某性质P的子图，并且对于G的具有该性质的任意子图G’‘，只要有<span class="math inline">\(G&#39;\subseteq G&#39;&#39;\)</span> ，就有<span class="math inline">\(G&#39;=G&#39;&#39;\)</span>，则称G'相对于该性质是G的极大子图</p><p>无向图G的极大连通子图称G的<strong>连通分支</strong>，简称<strong>分支</strong></p><h6 id="有向图">有向图</h6><p><strong>基础图</strong>：设有向图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> ，定义 <spanclass="math inline">\(\Psi&#39;:E\rightarrow\{\{v_1,v_2\}|v_1\in V\landv_2\in V\}\)</span> 使得对任意 <span class="math inline">\(e\inE\)</span> 和 <span class="math inline">\(v_1,v_2\in V\)</span> ，若<span class="math inline">\(\Psi(e)=&lt;v_1,v_2&gt;\)</span> ，则 <spanclass="math inline">\(\Psi&#39;(e)=\{v_1,v_2\}\)</span> 。称 <spanclass="math inline">\(G&#39;=&lt;V,E,\Psi&#39;&gt;\)</span>为有向图G的基础图</p><p>若有向图G中任意两个结点都相互可达，则称G是<strong>强连通</strong>的</p><p>若对于G任意两结点，必有一结点可达另一结点，则称G是<strong>单向连通</strong>的</p><p>若G的基础图是连通的，则称G是<strong>弱连通</strong>的</p><p>G的极大强/单向/弱连通子图称G的<strong>强/单向/弱分支</strong></p><h4 id="回路">回路</h4><p>设G’是有向图G的基础图，则G‘中的路径称G中的<strong>半路径</strong></p><p>设 <span class="math inline">\(v_0e_1v_1...v_{m-1}e_mv_m\)</span>是G中的半路径，对每个 <span class="math inline">\(i(1\leqslanti\leqslant m)\)</span> ，若 <spanclass="math inline">\(\Psi(e_i)=&lt;v_{i-1},v_i&gt;\)</span> 则称 <spanclass="math inline">\(e_i\)</span>是该半路径中的<strong>正向边</strong>，若 <spanclass="math inline">\(\Psi(e_i)=&lt;v_i,v_{i-1}&gt;\)</span> 则称 <spanclass="math inline">\(e_i\)</span>是该半路径中的<strong>反向边</strong></p><p><strong>回路</strong>：连通2度正则图</p><p><strong>半回路</strong>：基础图是回路的有向图</p><p><strong>有向回路</strong>：每个结点的出度和入度均为1的弱连通有向图</p><p>回路中边的数目称为回路的<strong>长度</strong></p><p>若回路（有向回路，半回路）C是图G的子图，则称G有回路C</p><p>有向图G有有向回路的充分条件：图G有子图G’使得对G‘的任意结点v，都有<span class="math inline">\(d_{G&#39;}^{+}&gt;0\)</span> 或都有 <spanclass="math inline">\(d_{G&#39;}^{+}&lt;0\)</span></p><p><strong>非循环图</strong>：没有回路的无向图和没有半回路的有向图</p><p>图G不是非循环图 <span class="math inline">\(\Leftrightarrow\)</span>G有子图G‘使得对于G'的任意结点v，都有 <spanclass="math inline">\(d_{G&#39;}(v)&gt;1\)</span></p><h4 id="割集与连通度">割集与连通度</h4><p>设无向图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>为连通图，若有点集 <span class="math inline">\(V_1\subset V\)</span>使得</p><ol type="1"><li>图G删除了 <span class="math inline">\(V_1\)</span>的所有结点后，所得子图是不连通图</li><li>图G删除了 <span class="math inline">\(V_1\)</span>的任意真子集后，所得子图仍是连通图</li></ol><p>则称 <span class="math inline">\(V_1\)</span>是G的一个<strong>点割集</strong>，某点构成一个点割集则称该点为<strong>割点</strong></p><p><span class="math inline">\(k(G)=\min\{|V_1|V_1是G的点割集\}\)</span>是G的<strong>（点）连通度</strong></p><p>设无向图 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>为连通图，若有边集 <span class="math inline">\(E_1\subset E\)</span>使得</p><ol type="1"><li>图G删除了 <span class="math inline">\(E_1\)</span>的所有边后，所得子图是不连通图</li><li>图G删除了 <span class="math inline">\(E_1\)</span>的任意真子集后，所得子图仍是连通图</li></ol><p>则称 <span class="math inline">\(E_1\)</span>是G的一个<strong>边割集</strong>，某边构成一个边割集则称该点为<strong>割边（桥）</strong></p><p><spanclass="math inline">\(\lambda(G)=\min\{|E_1|E_1是G的边割集\}\)</span>是G的<strong>边连通度</strong></p><h3 id="欧拉图">欧拉图</h3><p>图G中包含其所有边的简单开路径成为G的<strong>欧拉路径</strong>，简单闭路径为<strong>欧拉闭路</strong></p><p><strong>欧拉图</strong>：每个结点都是偶节点的无向图</p><p><strong>欧拉有向图</strong>：每个结点的出度与入度都相等的有向图</p><p>若G是连通无向图，则G是欧拉图当且仅当G有欧拉闭路；若G不连通，则G是欧拉图当且仅当G的每个分支都有欧拉闭路。</p><p>连通无向图有一条从 <span class="math inline">\(v_1\)</span> 至 <spanclass="math inline">\(v_2\)</span> 的欧拉路径当且仅当G恰有两个奇结点<span class="math inline">\(v_1\)</span> 和 <spanclass="math inline">\(v_2\)</span></p><p>若 <span class="math inline">\(G_1\)</span> 和 <spanclass="math inline">\(G_2\)</span> 是可运算欧拉图，则 <spanclass="math inline">\(G_1\oplus G_2\)</span>是欧拉图。但有向欧拉图的环和不一定是欧拉图</p><h3 id="哈密顿图">哈密顿图</h3><p>图G中包含它的所有结点的基本路径成为G的<strong>哈密顿路径</strong>，若回路（有向回路）C是图G的生成子图，则称C为G的<strong>哈密顿回路</strong></p><p><strong>哈密顿图（哈密顿有向图）</strong>：有哈密顿回路的图</p><p>有哈密顿回路的必要条件：</p><ol type="1"><li>用黑白两种颜色给图中点着色，使相邻点颜色不同，若能染色且黑白结点个数不同，则无哈密顿回路。数目相差大于1，则无哈密顿路径</li><li>设 <span class="math inline">\(G&lt;V,E,\Psi&gt;\)</span>是哈密顿图，则对V的任意非空真子集 <spanclass="math inline">\(v_1\)</span> 有 <spanclass="math inline">\(W(G-V_1)\leqslant|V_1|\)</span> 。其中 <spanclass="math inline">\(W(G-V_1)\)</span> 为 <spanclass="math inline">\(G-V_1\)</span>的分支个数。即删掉的点的个数应当大于等于剩下部分的分支数。</li><li>哈密顿图不存在悬挂边或孤立点</li></ol><p>哈密顿图的充分条件：</p><ol type="1"><li>欧尔定理：设G是一个n阶简单图(n&gt;1)，若G中任意一对顶点u和v，都满足<span class="math inline">\(d_G(u)+d_G(v)\geqslant n-1\)</span>，则G中存在哈密顿路径</li><li>设G是一个n阶简单图(n&gt;2)，若G中任意一对顶点u和v，都满足 <spanclass="math inline">\(d_G(u)+d_G(v)\geqslant n\)</span>，则是哈密顿图</li></ol><p>中国邮递员问题：给定一个连通图G，每边有非负权，求一条回路经过每条边至少一次且总权最小</p><h3 id="图的表示">图的表示</h3><h4 id="邻接矩阵">邻接矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> ，定义G的邻接矩阵<span class="math inline">\(X(G)\)</span> 为 <spanclass="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\((x_{ij})\)</span> ，其中 <spanclass="math inline">\(x_{ij}\)</span> 为分别以 <spanclass="math inline">\(v_i\)</span> 和 <spanclass="math inline">\(v_j\)</span> 为起点和终点的边的数目。</p><p>若两图同构，则边边互换、对应列再互换后，邻接矩阵相同</p><ul><li>无向图的邻接矩阵对称</li><li>简单图元素均为0或1，对角线元素为0</li><li>零图即零矩阵</li><li>无向图有k个分支则可矩阵分块后对角线有k个1矩阵？</li><li>记图G的邻接矩阵X的m次幂后的元素为 <spanclass="math inline">\(x_{ij}^{(m)}\)</span> ，则它表示 <spanclass="math inline">\(v_i\)</span> 到 <spanclass="math inline">\(v_j\)</span> 的长度为m的路径数</li></ul><h4 id="路径矩阵">路径矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span>，定义G的路径矩阵（可达性矩阵） <spanclass="math inline">\(X(G)\)</span> 为 <spanclass="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\(P=(p_{ij})\)</span> ，其中 <spanclass="math inline">\(p_{ij}=\begin{cases}1\ \ 从v_i可达v_j\\0\ \从v_i不可达v_j\end{cases}\)</span></p><h4 id="距离矩阵">距离矩阵</h4><p>设n阶图G的结点集为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> ，定义G的邻接矩阵为<span class="math inline">\(n\times n\)</span> 矩阵 <spanclass="math inline">\(D=(d_{ij})\)</span> ，其中 <spanclass="math inline">\(d_{ij}\)</span> 为分别从 <spanclass="math inline">\(v_i\)</span> 至 <spanclass="math inline">\(v_j\)</span> 的距离。</p><h4 id="关联矩阵">关联矩阵</h4><p>设无自圈的n阶<strong>无向图</strong>G的结点集和边集分别为为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> 和 <spanclass="math inline">\(\{e_1,e_2,...,e_m\}\)</span> ，定义G的关联矩阵<span class="math inline">\(A(G)\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 矩阵 <spanclass="math inline">\((a_{ij})\)</span> ，其中 <spanclass="math inline">\(a_{ij}=\begin{cases}1,\ e_j与v_i关联\\0,\e_j与v_i不关联\end{cases}\)</span></p><p>设无自圈的n阶<strong>有向图</strong>G的结点集和边集分别为为 <spanclass="math inline">\(\{v_1,v_2,...,v_n\}\)</span> 和 <spanclass="math inline">\(\{e_1,e_2,...,e_m\}\)</span> ，定义G的关联矩阵<span class="math inline">\(A(G)\)</span> 为 <spanclass="math inline">\(n\times m\)</span> 矩阵 <spanclass="math inline">\((a_{ij})\)</span> ，其中 <spanclass="math inline">\(a_{ij}=\begin{cases}1,\ v_i是e_j的起点\\-1,\v_i是e_j的终点\\0,\ e_j与v_i不关联\end{cases}\)</span></p><h2 id="树">树</h2><h3 id="无向树">无向树</h3><p><strong>树</strong>：非循环连通无向图</p><p><strong>平凡树</strong>：只有一个顶点的平凡图</p><p>树T中，度数为1的结点称<strong>叶子结点</strong>，度数大于1的结点称<strong>分支结点</strong></p><p>树定义的等价条件（设图 <spanclass="math inline">\(G=&lt;V,E,\Psi&gt;\)</span> 是n阶无向图）：</p><ol type="1"><li>G连通且非循环</li><li>G连通且 <span class="math inline">\(G-e\)</span> 非连通</li><li>G连通且 <span class="math inline">\(|E|=n-1\)</span></li><li>G非循环且 <span class="math inline">\(|E|=n-1\)</span></li></ol><p><strong>森林</strong>：每个分支都是树的无向图</p><p>若森林F有n个结点，m条边，k个分支，则 <spanclass="math inline">\(m=n-k\)</span></p><p>若树T是无向图G的生成子图，则称T为G的<strong>生成树</strong>。若森林F是无向图G的生成子图，则称F为G的<strong>生成森林</strong></p><p>每个无向图均有生成森林，若连通才有生成树</p><p>生成树构造方法：破圈法、</p><p><strong>最小生成树</strong>：连通无向加权图的加权长度最小的生成树</p><p>设T是连通无向图G的生成树，称T的边为<strong>枝</strong>，G的不属于T的边称<strong>弦</strong></p><p>对n阶无向图G，有m条边，任何生成树T，都有 <spanclass="math inline">\(n-1\)</span> 条枝，<spanclass="math inline">\(m-n+1\)</span> 条弦</p><p>若n阶无向图G有m条边和k个分支，则G的<strong>余圈秩</strong> <spanclass="math inline">\(r=n-k\)</span> ，<strong>圈秩</strong> <spanclass="math inline">\(\mu=m-n+k\)</span></p><p>G的只包含一条弦的回路称<strong>基本回路</strong></p><p>设T是连通无向图G的任意生成树，则</p><ol type="1"><li>基本回路的数目等于G的圈秩</li><li>对G的任意回路C，总可以找到若干个基本回路 <spanclass="math inline">\(C_1,C_2,...C_k\)</span> ，使C与 <spanclass="math inline">\(C_1\oplus C_2\oplus...\oplus C_k\)</span>的差别仅在于孤立点</li></ol><h3 id="有向树">有向树</h3><p><strong>有向树</strong>：一个结点的入度为0，其余结点的入度为1的弱连通有向图</p><p>有向树中入度为0的结点称为<strong>根</strong>，出度为0的结点称<strong>叶</strong>，出度大于0为<strong>分支结点</strong>。从根至任意结点的距离称为该结点的<strong>级</strong>，所有结点的级的最大值称有向树的<strong>高度</strong></p><p>设 <span class="math inline">\(v_0\)</span> 是有向图G的结点，则D是以<span class="math inline">\(v_0\)</span> 为根的有向树当且仅当从 <spanclass="math inline">\(v_0\)</span> 到D的任意结点恰有一条路径</p><p><strong>有向森林</strong>：每个弱分支都是有向树的有向图</p><p>若有向树的结点出度的最大值m，则称D为<strong>m元有向树</strong>。每个结点出度均为m或0，则称D为<strong>完全m有向树</strong>。</p><h3 id="二叉树">二叉树</h3><p><strong>二叉树</strong>：完全二元有向树</p><p><strong>叶加权二叉树</strong>：设V是二叉树D的叶的集合， <spanclass="math inline">\(W:V\rightarrow R_{+}\)</span> ，则称 <spanclass="math inline">\(&lt;D,W&gt;\)</span></p><p>对于D的任意v，称W(v)为v的权， <span class="math inline">\(\sum_{v\inV}(W(v)L(v))\)</span>称叶加权二叉树的<strong>叶加全路径长度</strong>，其中 L(v)为v的级</p><p><strong>最优二叉树</strong>：设 <spanclass="math inline">\(&lt;D,W&gt;\)</span>是叶加权二叉树，如果对任一叶加权二叉树 <spanclass="math inline">\(&lt;D&#39;,W’&gt;\)</span>，只要对于任意正实数r，D和D‘中权等于r的叶的数目相同，就有 <spanclass="math inline">\(&lt;D,W&gt;\)</span> 的叶加权路径长度不大于 <spanclass="math inline">\(&lt;D&#39;,W’&gt;\)</span> 的叶加权路径长度，则称<span class="math inline">\(&lt;D,W&gt;\)</span> 为最优的</p><p>哈夫曼的最优二叉树的求解</p><h3 id="有序树">有序树</h3><p><strong>有序树</strong>：每一级上的结点规定了次序的有向树</p><p><strong>有序森林</strong>：有向森林中每个弱分支都规定了次序</p><p><strong>定位有序树</strong>：为每个分支结点的儿子规定了位置的有序树</p><p>若用空字符串表示根，a0表示分支节点a的左儿子，a1表示a的右儿子，则每个结点都有了唯一的编码表示，并且不同结点的编码表示不同。</p><p>定位二元有序树的全体叶的编码表示集合称为它的<strong>前缀编码</strong></p>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大物2笔记</title>
    <link href="/2024/01/14/%E5%A4%A7%E7%89%A92%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E5%A4%A7%E7%89%A92%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h4 id="物理常数">物理常数</h4><p>电子电荷 <span class="math inline">\(e=1.6\times10^{-19}C\)</span>电子质量 <span class="math inline">\(m_e=9.1\times10^{-31}kg\)</span></p><p>普适气体常量 <span class="math inline">\(R=8.31J/(mol·K)\)</span>玻尔兹曼常数 <spanclass="math inline">\(k=\dfrac{R}{N_A}=1.38\times10^{-23}J/K\)</span></p><p>普朗克常数 <span class="math inline">\(h=6.63\times10^{-34}J\cdots\)</span> 约化普朗克常数 <spanclass="math inline">\(\hbar=\dfrac{h}{2\pi}=1.0546\times10^{-34}J\cdots\)</span></p><p>真空介电常数 <spanclass="math inline">\(\varepsilon_0=8.854\times10^{-12}F/m\)</span>真空磁导率 <spanclass="math inline">\(\mu_0=4\pi\times10^{-7}N/A^2\)</span></p><p>万有引力常量 <spanclass="math inline">\(G=6.67\times10^{-11}m^3/(kg\cdot s^2)\)</span></p><h2 id="热学">热学</h2><p>热力学第零定律：分别与第三个系统处于热平衡的两个系统彼此也处于热平衡</p><h3 id="理想气体的参量">理想气体的参量</h3><p>理想气体状态方程：<spanclass="math inline">\(pV=\frac{m}{M}RT\)</span></p><p>*范德瓦尔斯方程：<spanclass="math inline">\((p+\frac{a}{V_m^2})(V_m-b)=RT\)</span></p><p>普适气体常量 <spanclass="math inline">\(R=8.31J/(mol·K)\)</span>，玻尔兹曼常数 <spanclass="math inline">\(k=\dfrac{R}{N_A}=1.38\times10^{-23}J/K\)</span></p><p><strong>压缩气体需要力，不说明分子间存在斥力</strong></p><p>理想气体压强：<spanclass="math inline">\(p=\frac{1}{3}nm\bar{v^2}=\frac{2}{3}n\bar{E_k}=nkT\)</span>，其中<spanclass="math inline">\(\bar{E_k}=\frac{1}{2}m\bar{v^2}\)</span>，n为分子数密度</p><p>理想气体温度：<spanclass="math inline">\(\bar{E_k}=\frac{3}{2}kT\)</span></p><p>能量按自由度均分定理：温度为T的平衡态下，物质分子的每一自由度都具有相同的平均动能<span class="math inline">\(E_k=\frac{1}{2}kT\)</span>，一个分子的平均平动动能为 <spanclass="math inline">\(\bar{E_k}=\frac{1}{2}m\bar{v^2}\)</span></p><p>理想气体的内能：<spanclass="math inline">\(E=\dfrac{m}{M}\dfrac{i}{2}RT\)</span></p><h3 id="麦克斯韦速率分布律">麦克斯韦速率分布律</h3><p>速率分布函数（可类比概率密度函数）：<spanclass="math inline">\(f(v)=\lim\limits_{\Delta v\to0}\dfrac{\DeltaN}{N\Delta v}=\dfrac{dN}{Ndv}=4\pi(\dfrac{m}{2\pikT})^{\frac{3}{2}}e^{-\tfrac{mv^2}{2kT}}v^2\)</span></p><p>另有：v附近 <span class="math inline">\(\Delta v\)</span>范围内分子占分子总数的比例 <span class="math inline">\(\dfrac{\DeltaN}{N}=f(v)\Deltav=\dfrac{4}{\sqrt{\pi}}\dfrac{v^2}{v_p^3}e^{-\tfrac{v^2}{v_p^2}}\Deltav\)</span></p><p>归一化条件：<spanclass="math inline">\(\int_0^{\infty}f(v)dv=1\)</span></p><p>最概然速率：<spanclass="math inline">\(v_p=\sqrt{\dfrac{2kT}{m_0}}\)</span></p><p>方均根速率：<spanclass="math inline">\(\sqrt{\bar{v^2}}=\sqrt{\dfrac{3kT}{m_0}}=\sqrt{\dfrac{3RT}{M}}\)</span></p><p>平均速率：<spanclass="math inline">\(\bar{v}=\int_0^{\infty}vf(v)dv=\sqrt{\dfrac{8kT}{\pim_0}}\)</span></p><p>平均碰撞频率：<span class="math inline">\(\bar{Z}=Vn=\pid^2\bar{v_r}n=\sqrt{2}\pi d^2\bar{v}n\)</span>，其中 <spanclass="math inline">\(\bar{v_r}\)</span>是平均相对速率，d是分子碰撞时中心间距，n是分子数密度</p><p>分子平均自由程：<spanclass="math inline">\(\bar{\lambda}=\dfrac{\bar{v}}{\bar{Z}}=\dfrac{1}{\sqrt{2}\pid^2n}=\dfrac{kT}{\sqrt{2}\pi d^2p}\)</span></p><p><strong>速率在v1和v2之间的分子的平均速率不是 <spanclass="math inline">\(\int_{v_1}^{v_2}vf(v)dv\)</span>，而是 <spanclass="math inline">\(\dfrac{\int_{v_1}^{v_2}vf(v)dv}{\int_{v_1}^{v_2}f(v)dv}\)</span></strong></p><p>分子数密度按势能分布： <spanclass="math inline">\(n=n_0e^{-\tfrac{E_p}{kT}}\)</span></p><p>等温气压公式：<spanclass="math inline">\(p=p_0e^{-\tfrac{mgh}{kT}}\)</span></p><h3 id="近平衡态的运输现象">*近平衡态的运输现象</h3><p>粘滞力：<span class="math inline">\(f=\pm \eta\frac{dv}{dx}\DeltaS\)</span>，其中 <span class="math inline">\(\frac{dv}{dx}\)</span>为速度梯度，动力粘度 <spanclass="math inline">\(\eta=\frac{1}{3}\rho\bar{v}\bar{\lambda}\)</span></p><p>热传导：<span class="math inline">\(\frac{\Delta Q}{\Deltat}=-\kappa\frac{dT}{dx}\Delta S\)</span> ，热导率 <spanclass="math inline">\(\kappa=\frac{1}{3}\frac{C_{v,m}}{M}\rho\bar{v}\bar{\lambda}\)</span></p><p>扩散现象：<span class="math inline">\(\frac{\Delta m}{\Deltat}=-D\frac{d\rho}{dx}\Delta S\)</span>，扩散系数 <spanclass="math inline">\(D=\frac{1}{3}\bar{v}\bar{\lambda}\)</span></p><h3 id="热力学过程">热力学过程</h3><p>热力学第一定律：设外界对系统传递热量Q，系统对外做功A，系统内能为E，则<span class="math inline">\(Q=E_2-E_1+A\)</span></p><p>摩尔热容 <spanclass="math inline">\(C_m=\dfrac{dQ}{\frac{m}{M}dT}\)</span>，即一摩尔物质变化单位温度所需的热量</p><p>计算思路：气体做功可用 <span class="math inline">\(\int pdV\)</span>，内能变化可用 <span class="math inline">\(\DeltaE=\dfrac{i}{2}\dfrac{m}{M}R\Delta T\)</span> ，热量可用 <spanclass="math inline">\(\Delta Q=C_m\dfrac{m}{M}\Delta T\)</span>。除此之外还可利用热力学第一定律间接计算</p><h4 id="等体过程">等体过程</h4><p>条件：<span class="math inline">\(dV=0\RightarrowA=0,Q=E_2-E_1\)</span></p><p>摩尔定容热容：<span class="math inline">\(C_{v,m}=\dfrac{\deltaQ_v}{\frac{m}{M}dT}=\dfrac{i}{2}R\)</span></p><p><span class="math inline">\(dE=\frac{m}{M}C_{v,m}dT\)</span></p><h4 id="等压过程">等压过程</h4><p><span class="math inline">\(dp=0\Rightarrow A=p\DeltaV,Q_p=E_2-E_1+\frac{m}{M}R(T_2-T_1)\)</span></p><p>摩尔定压热容：<span class="math inline">\(C_{p,m}=\dfrac{\deltaQ_p}{\frac{m}{M}dT}=C_{v,m}+R\)</span></p><p>摩尔热容比：<spanclass="math inline">\(\gamma=\dfrac{C_{p,m}}{C_{v,m}}=\dfrac{i+2}{i}\)</span></p><h4 id="等温过程">等温过程</h4><p><span class="math inline">\(dT=0\Rightarrow \DeltaE=0,Q_T=A=\int_{V_1}^{V_2}pdV=p_1V_1\ln\frac{p_1}{p_2}=p_1V_1\ln\frac{V_2}{V_1}\)</span></p><h4 id="绝热过程">绝热过程</h4><p><span class="math inline">\(\delta Q=0\RightarrowdE+pdV=0\)</span>，据此可推出绝热过程方程：</p><p><spanclass="math inline">\(pV^{\gamma}=C_1,V^{\gamma-1}T=C_2,p^{\gamma-1}T^{-\gamma}=C_3\)</span></p><p>其中 <span class="math inline">\(C_1,C_2,C_3\)</span> 均为常量，<spanclass="math inline">\(\gamma\)</span> 为摩尔热容比</p><h3 id="循环过程">循环过程</h3><p>系统经某一过程后又回到初始状态称循环过程，若循环过程每一分过程均为准静态，则可用p-V图表示且为一闭合曲线。曲线方向顺时针为正循环、热机，逆时针为逆循环、制冷机</p><p>热机效率：<spanclass="math inline">\(\eta=\dfrac{A}{Q_1}=\dfrac{Q_1-Q_2}{Q_1}=1-\dfrac{Q_2}{Q_1}\)</span></p><p>一般的热机效率 <spanclass="math inline">\(\eta=\dfrac{W_{循环}}{Q_{总吸}}\)</span></p><p>制冷系数：<spanclass="math inline">\(w=\dfrac{Q_2}{A}=\dfrac{Q_2}{Q_1-Q_2}\)</span></p><p>其中 <span class="math inline">\(Q_1\)</span>是从高温热源吸收的热量， <span class="math inline">\(Q_2\)</span>是向低温热源放出的热量， <span class="math inline">\(A\)</span>是对外界做的功</p><p>热力学第三定律：不可能通过有限的过程使物体冷却到绝对零度</p><h4 id="卡诺循环">卡诺循环</h4><p>在两温度恒定的热源之间工作的循环过程，工质只与热源交换能量</p><p><spanclass="math inline">\(\eta_c=1-\dfrac{T_2}{T_1},w_c=\dfrac{T_2}{T_1-T_2}\)</span></p><h3 id="熵">熵</h3><p>热力学第二定律：</p><ul><li><p>开尔文表述：不可能从单一热源取热，把它全部变为功而不产生其他任何影响</p></li><li><p>克劳修斯表述：热不可能自发地从低温物体传至高温物体</p></li></ul><p>可逆过程：若过程 <span class="math inline">\(A\rightarrowB\)</span>，存在另一过程 <span class="math inline">\(B\rightarrowA\)</span>，且周围一切各自回复原状，称可逆过程</p><p>卡诺定理：</p><ol type="1"><li><p>同样高低温热源之间工作的一切可逆机，效率都等于 <spanclass="math inline">\(1-\dfrac{T_2}{T_1}\)</span></p></li><li><p>同样高低温热源之间工作的不可逆机效率 <spanclass="math inline">\(\eta\leqslant1-\dfrac{T_2}{T_1}\)</span></p></li></ol><p>熵：<span class="math inline">\(S_2-S_1=\int_1^2\dfrac{\deltaQ}{T},\delta S=\dfrac{\delta Q}{T}\)</span> ，可逆过程熵变为0 <spanclass="math inline">\(\oint\dfrac{\delta Q}{T}=0\)</span></p><p>设系统状态所包含的微观状态数为W，则有 <spanclass="math inline">\(S=k\ln W\)</span>，其中k为玻尔兹曼常量</p><h2 id="振动">振动</h2><h3 id="简谐振动">简谐振动</h3><p>方程：<spanclass="math inline">\(\dfrac{d^2x}{dt^2}=\dfrac{F}{m}=-\dfrac{k}{m}x\)</span>，设<span class="math inline">\(\omega^2=\dfrac{k}{m}\)</span>，则有 <spanclass="math inline">\(\dfrac{d^2x}{dt^2}=-\omega^2x\)</span>，解得 <spanclass="math inline">\(x=A\cos(\omega t+\phi_0)\)</span></p><p>特征量：</p><ul><li><p>振幅 <spanclass="math inline">\(|A|=\sqrt{x_0^2+\dfrac{v_0^2}{\omega^2}}\)</span></p></li><li><p>初相 <spanclass="math inline">\(\phi_0=\arctan(-\dfrac{v_0}{\omegax_0})\)</span></p></li><li><p>周期 <spanclass="math inline">\(T=\dfrac{2\pi}{\omega}=2\pi\sqrt{\dfrac{m}{k}}\)</span></p></li><li><p>总能量 <spanclass="math inline">\(E=\frac{1}{2}kA^2\)</span></p></li></ul><p>常见举例：</p><ul><li><p>单摆：<span class="math inline">\(\theta=\theta_m\cos(\omegat+\phi_0)\)</span> <spanclass="math inline">\(T=2\pi\sqrt{\dfrac{l}{g}}\)</span> <spanclass="math inline">\(-mg\sin\theta=ml\dfrac{d^2\theta}{dt^2}\)</span></p></li><li><p>复摆：<span class="math inline">\(\theta=\theta_m\cos(\omegat+\phi_0)\)</span> <spanclass="math inline">\(T=2\pi\sqrt{\dfrac{J}{mgh}}\)</span> <spanclass="math inline">\(-mgh\theta=J\dfrac{d^2\theta}{dt^2}\)</span>，其中h是质心到定轴的距离</p></li></ul><h3 id="其他振动">其他振动</h3><h4 id="阻尼振动">阻尼振动</h4><p><span class="math inline">\(f=-\mu v\)</span> ，<spanclass="math inline">\(\mu\)</span> 为阻力系数。设 <spanclass="math inline">\(\dfrac{\mu}{m}=2\delta\)</span> （<spanclass="math inline">\(\delta\)</span>为阻尼系数），则有</p><p>弱阻尼：<spanclass="math inline">\(\delta^2&lt;\omega_0^2,x=Ae^{-\deltat}\cos(\sqrt{\omega_0^2-\delta^2}t+\phi)\)</span></p><p>临界阻尼：<spanclass="math inline">\(\delta^2=\omega_0^2,x=(A+Bt)e^{-\deltat}\)</span></p><p>过阻尼：<spanclass="math inline">\(\delta^2&gt;\omega_0^2,x=Ce^{-(\delta-\sqrt{\delta^2-\omega_0^2})t}+De^{-(\delta+\sqrt{\delta^2-\omega_0^2})t}\)</span></p><h4 id="受迫振动">受迫振动</h4><p><span class="math inline">\(F=F_0\cos wt\)</span></p><p><span class="math inline">\(x=A_0e^{-\deltat}\cos(\sqrt{\omega_0^2-\delta^2}t+\phi_0^{&#39;})+A\cos(\omegat+\phi)\)</span> ，一段时间后为 <spanclass="math inline">\(x=A\cos(\omega t+\phi)\)</span> ，其中 <spanclass="math inline">\(A=\dfrac{F_0}{m\sqrt{(\omega_0^2-\omega^2)^2+4\delta^2\omega^2}}\)</span>，<spanclass="math inline">\(\tan\phi=-\dfrac{2\delta\omega}{\omega_0^2-\omega^2}\)</span></p><h4 id="电磁震荡">*电磁震荡</h4><h3 id="一维振动的合成">一维振动的合成</h3><p>同频率：</p><ol type="1"><li><p><span class="math inline">\(x_1=A_1\cos(\omegat+\phi_{01}),x_2=A_2\cos(\omega t+\phi_{02})\Rightarrow x=A\cos(\omegat+\phi_0)\)</span> ，其中</p><p><spanclass="math inline">\(A=\sqrt{A_1^2+A_2^2+2A_1A_2\cos(\phi_{01}-\phi_{02})},\tan\phi_0=\dfrac{A_1\sin\phi_{01}+A_2\sin\phi_{02}}{A_1\cos\phi_{01}+A_2\cos\phi_{02}}\)</span></p></li><li><p><span class="math inline">\(x_i=A\cos[\omegat+(i-1)\phi_0]\Rightarrow\sum\limits_{i=1}^nx_i=A\dfrac{\sin{\frac{n\phi_0}{2}}}{\sin{\frac{\phi_0}{2}}}\cos(\omegat+\frac{n-1}{2}\phi_0)\)</span></p></li></ol><p>不同频率：</p><p><span class="math inline">\(x_1=A_1\cos(\omegat+\phi_{01}),x_2=A_2\cos(\omega t+\phi_{02})\)</span></p><p>当 <spanclass="math inline">\(A_1=A_2=A,\phi_{01}=\phi_{02}=\phi_0\)</span>，有<spanclass="math inline">\(x=2A\cos(\dfrac{\omega_2-\omega_1}{2}t)\cos(\dfrac{\omega_2+\omega_1}{2}t+\phi_0)\)</span></p><p>当上式满足 <spanclass="math inline">\(|\omega_1-\omega_2|&lt;&lt;\omega_1或\omega_2\)</span>，振幅随时间缓慢变化，变化频率即拍频<spanclass="math inline">\(=|\dfrac{\omega_1-\omega_2}{2\pi}|=|\nu_1-\nu_2|\)</span>称拍频</p><h2 id="波">波</h2><h3 id="介质的形变及其模量">介质的形变及其模量</h3><ol type="1"><li><p>线变：设柱体长l，截面面积S，两端受力F，则 <spanclass="math inline">\(\dfrac{F}{S}=E\dfrac{\Deltal}{l}\)</span>。即线应变正比于正应力，其中 <spanclass="math inline">\(E\)</span> 称为弹性模量（杨氏模量）</p></li><li><p>体变：设体积V，压强p，则有 <span class="math inline">\(\Deltap=-K\dfrac{\Delta V}{V}\)</span> ，其中K为体积模量</p></li><li><p>切变：<span class="math inline">\(\dfrac{F}{S}=G\theta\)</span>，其中G为切变模量</p></li></ol><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">绳索</th><th style="text-align: center;">固体（横波）</th><th style="text-align: center;">固体（纵波）</th><th style="text-align: center;">流体（纵波）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">波速</td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{F}{\rho_1}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{G}{\rho}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{E}{\rho}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sqrt{\dfrac{K}{\rho}}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(\rho_1\)</span> 是线密度，<spanclass="math inline">\(\rho\)</span> 为密度</p><h3 id="波的特征描述与波函数">波的特征描述与波函数</h3><p>波长 <spanclass="math inline">\(\lambda\)</span>：同一波线上两个相邻的、相位差为<span class="math inline">\(2\pi\)</span> 的质元之间的距离</p><p>周期 <span class="math inline">\(T\)</span>：波前进一个波长的时间</p><p>波速 <spanclass="math inline">\(u\)</span>：单位时间内振动状态传播的距离</p><p>角频率 <spanclass="math inline">\(\omega=2\pi\nu=\dfrac{2\pi}{T}\)</span></p><p>角波数、空间角频率：<spanclass="math inline">\(k=\dfrac{2\pi}{\lambda}\)</span>，表示单位长度上波的相位的变化</p><p>满足 <spanclass="math inline">\(u=\dfrac{\lambda}{T}=\nu\lambda\)</span></p><p>波函数：<spanclass="math inline">\(\xi(\vec{r},t)=f(\vec{r},t)=f(x,y,z,t)\)</span></p><p>平面简谐波：<spanclass="math inline">\(y(x,t)=A\cos[\omega(t-\frac{x}{u})+\phi_0]\)</span>，表示振幅为A、波速为u、波源初相 <spanclass="math inline">\(\phi_0\)</span>、波线上距原点为x、时间t时的振动方程</p><p>平面波的波动方程：<spanclass="math inline">\(\dfrac{\partial^2y}{\partialx^2}=\dfrac{1}{u^2}\dfrac{\partial^2y}{\partial t^2}\)</span></p><p>球面波：<spanclass="math inline">\(\xi=\dfrac{A_0r_0}{r}\cos[\omega(t-\frac{r}{u})-\phi_0]\)</span>，振幅和离开波源的距离成反比</p><h3id="波的能量与强度声压声强与分贝">波的能量与强度、声压声强与分贝</h3><p>在弦线中 <span class="math inline">\(x\)</span> 处取线元 <spanclass="math inline">\(\Delta x\)</span> 、线密度 <spanclass="math inline">\(\rho_l\)</span> 、张力 <spanclass="math inline">\(F\)</span>，则有</p>$$<span class="math display">\[\begin{aligned}\Delta E_k&amp;=\frac{1}{2}\rho_l\Delta x(\frac{\partial y}{\partialt})^2\\\Delta E_p&amp;=\frac{1}{2}F\Delta x(\frac{\partial y}{\partial x})^2\end{aligned}\]</span><p>$$</p><p>代入 <span class="math inline">\(u=\sqrt{\dfrac{F}{\rho_l}}\)</span>得 <span class="math inline">\(\Delta E_k=\DeltaE_p=\frac{1}{2}\rho_lA^2\omega^2\Deltax\sin^2[\omega(t-\frac{x}{u})+\phi_0]\)</span>，即质元的动能与势能相等且同相位变化（<strong>与单一的简谐振动不同！</strong>）</p><p>波的能量密度 <span class="math inline">\(w=\dfrac{\Delta E}{S\Deltax}=\rho_lA^2\omega^2\sin^2[\omega(t-\frac{x}{u})+\phi_0]\)</span></p><p>平均能量密度 <span class="math inline">\(\bar{w}=\frac{1}{2}\rhoA^2\omega^2\)</span></p><p>平均能流（单位时间内通过介质中某截面S的波动能量）：<spanclass="math inline">\(\bar{P}=\bar{w}uS\)</span></p><p>平均能流密度（声强）：<spanclass="math inline">\(I=\bar{w}u=\frac{1}{2}\rho_lu\omega^2A^2=\frac{1}{2}Z\omega^2A^2\)</span>，单位 <span class="math inline">\(W/m^2\)</span> ，其中 <spanclass="math inline">\(Z=\rho_lu\)</span> 称特性阻抗</p><p>声压：<span class="math inline">\(p=-\rho\omegauA\sin[\omega(t-\frac{x}{u})+\phi_0]\)</span> ，记 <spanclass="math inline">\(p_m=\rho u\omega A\)</span> ，称声压振幅</p><p>声强级（分贝）：<spanclass="math inline">\(I_L=10\lg\dfrac{I}{I_0}\)</span> ，其中 <spanclass="math inline">\(I_0=10^{-12}W/m^2\)</span> ，是人类听觉下限</p><h3 id="电磁波">*电磁波</h3><h3 id="波的谜之操作">波的谜之操作</h3><h4 id="理论基础">理论基础</h4><p>惠更斯原理：介质中任一波面上的各点，都可看成是产生球面子波的波源；在其后的任一时刻，这些子波的包络面构成新的波面。</p><p>波的叠加原理：在几列波相遇的区域内，任一质元振动的位移是各列波单独传播时在该点引起的位移的矢量和。</p><h4 id="反射与折射">反射与折射</h4><p>类似光</p><h4 id="衍射">衍射</h4><p>波传播过程中当遇到障碍物时，能绕过障碍物发生偏折的现象</p><h4 id="干涉">干涉</h4><p>两列波在空间相遇叠加，结果在空间的某些地方振动始终加强，而在空间的另一些地方振动始终减弱或完全消失的现象。</p><p>相干波：能产生干涉现象的波</p><p>相干条件：两列波频率相同、振动方向相同、相位差恒定</p><p>设有两相干源 <span class="math inline">\(S_1\)</span> ，<spanclass="math inline">\(S_2\)</span> ，波在距波源为 <spanclass="math inline">\(r_1\)</span> ，<spanclass="math inline">\(r_2\)</span> 的 <spanclass="math inline">\(P\)</span> 点相遇，波动方程分别为</p>$$<span class="math display">\[\begin{aligned}y_1&amp;=A_1\cos(\omega t+\phi_{01}-\frac{2\pi r_1}{\lambda})\\y_2&amp;=A_2\cos(\omega t+\phi_{02}-\frac{2\pi r_2}{\lambda})\end{aligned}\]</span><p>$$</p><p>则有</p>$$<span class="math display">\[\begin{aligned}y_1+y_2&amp;=A\cos(\omega t+\phi_0)\\\Delta\phi&amp;=\phi_{02}-\phi_{01}-2\pi\frac{r_2-r_1}{\lambda}\\A&amp;=\sqrt{A_1^2+A_2^2+2A_1A_2\cos\Delta\phi}\\\tan\phi_0&amp;=\dfrac{A_1\sin(\phi_{01}-\frac{2\pir_1}{\lambda})+A_2\sin(\phi_{02}-\frac{2\pir_2}{\lambda})}{A_1\cos(\phi_{01}-\frac{2\pir_1}{\lambda})+A_2\cos(\phi_{02}-\frac{2\pi r_2}{\lambda})}\\I&amp;=I_1+I_2+2\sqrt{I_1I_2}\cos\Delta\phi\end{aligned}\]</span><p>$$</p><h4 id="驻波">驻波</h4><p>两列振幅相同的相干波沿相反方向传播叠加而成</p>$$<span class="math display">\[\begin{aligned}y_1&amp;=A\cos[2\pi(\frac{t}{T}-\frac{x}{\lambda})]\\y_2&amp;=A\cos[2\pi(\frac{t}{T}+\frac{x}{\lambda})]\\y_1+y_2&amp;=2A\cos\frac{2\pi}{\lambda}x\cos\frac{2\pi}{T}t\end{aligned}\]</span><p>$$</p><p>振幅：每个点振幅不变，但不同位置振幅不同。不动的质元称波节，振幅最大的称波腹。相邻的波节、波腹相距<span class="math inline">\(\dfrac{\lambda}{2}\)</span></p><p>相位：同一分段内各点振动相位相同，一个波节的两侧相邻分段内的各振动点反相位</p><p>能量：波节处只有势能，波腹处只有动能</p><h4 id="半波损失">半波损失</h4><p><span class="math inline">\(\rho u\)</span>较大称波密介质，较小称波疏介质。当波从波疏介质向波密介质传播时，入射波在反射点反射时有相位<span class="math inline">\(\pi\)</span> 的突变，称之为半波损失。</p><h3 id="多普勒效应">多普勒效应</h3><p>设观测者相对介质运动速度为 <span class="math inline">\(v_R\)</span>，向波源方向运动取正；波源相对于介质运动速度为 <spanclass="math inline">\(v_S\)</span> ，向观测者方向运动为正；波速为 <spanclass="math inline">\(u\)</span></p><p>设波源的频率为 <span class="math inline">\(\nu_S\)</span>，观测者收到的频率为 <span class="math inline">\(\nu_R\)</span></p><p>则有 <spanclass="math inline">\(\nu_R=\dfrac{u+v_R}{u-v_S}\nu_S\)</span></p><p>*电磁波则化为 <spanclass="math inline">\(\nu_R=\sqrt{\dfrac{c+v}{c-v}}\nu_S\)</span></p><p>*冲击波：波源速度超过波速，马赫数即 <spanclass="math inline">\(\dfrac{u_S}{u}\)</span> ，<spanclass="math inline">\(\sin\alpha=\dfrac{u}{u_S}\)</span></p><h2 id="光学">光学</h2><h3 id="几何光学简介">*几何光学简介</h3><p>直线传播、独立传播、折射与反射定律</p><p><spanclass="math inline">\(\dfrac{1}{u}+\dfrac{1}{v}=\dfrac{1}{f}\)</span></p><h3 id="光的相干">光的相干</h3><p>光的叠加：<spanclass="math inline">\(I=\dfrac{1}{2}\sqrt{\dfrac{\varepsilon}{\mu}}E_0^2\propto\vec{E}^2,I_P=I_1+I_1+2\sqrt{I_1I_2}\cos[(\phi_1-\phi_2)-\dfrac{\omega(r_1-r_2)}{c}]\)</span></p><p>相干条件：同频率、相位差恒定、光矢量振动方向平行且振幅相差不大</p><p>获得方法：分波阵面法、分振幅法</p><p>光程：真空中为光走过的距离，介质中为发生相同相变需要在真空中走过的距离，即<span class="math inline">\(r&#39;=nr\)</span></p><p>光程差：<span class="math inline">\(\delta\)</span> ，则相位差 <spanclass="math inline">\(\Delta\phi=\dfrac{2\pi}{\lambda}\delta\)</span>，且透镜不改变光程差</p><p>干涉条纹的可见度：<spanclass="math inline">\(V=\dfrac{I_{\max}-I_{\min}}{I_{\max}+I_{\min}}=\dfrac{2\sqrt{\frac{I_2}{I_1}}}{1+\frac{I_2}{I_1}}\)</span></p><h4 id="杨氏干涉实验">杨氏干涉实验</h4><figure><img src="/img/image-20231218094602706.png"alt="image-20231218094602706" /><figcaption aria-hidden="true">image-20231218094602706</figcaption></figure><p><span class="math inline">\(\delta=r_2-r_1\approx d\sin\theta\approxd\dfrac{x}{D},\Delta\phi=\dfrac{2\pi}{\lambda}\delta\)</span></p><p>明纹：<span class="math inline">\(x_{\pm k}=\pmk\dfrac{D}{d}\lambda,k=0,1,2...\)</span></p><p>暗纹：<span class="math inline">\(x_{\pm 2k+1}=\pm(2k+1)\dfrac{D}{d}\lambda,k=0,1,2...\)</span></p><p>相邻明暗条纹间距：<span class="math inline">\(\Deltax=\dfrac{D}{d}\lambda\)</span></p><p>光源线度的约束条件：<spanclass="math inline">\(b&lt;\dfrac{B}{d}\lambda\)</span> ，<spanclass="math inline">\(B\)</span> 是光源到2小孔的板之间的距离</p><h4 id="劳埃德镜实验">劳埃德镜实验</h4><figure><img src="/img/image-20231218105005487.png"alt="image-20231218105005487" /><figcaption aria-hidden="true">image-20231218105005487</figcaption></figure><h4 id="薄膜干涉">薄膜干涉</h4><figure><img src="/img/image-20231218105606726.png"alt="image-20231218105606726" /><figcaption aria-hidden="true">image-20231218105606726</figcaption></figure><p><strong>注意是否有半波损失</strong></p><h4 id="劈尖干涉">劈尖干涉</h4><figure><img src="/img/image-20231218105845796.png"alt="image-20231218105845796" /><figcaption aria-hidden="true">image-20231218105845796</figcaption></figure><p>两相邻明条纹对应的厚度差 <span class="math inline">\(\Deltad=\dfrac{\lambda}{2n_2}\)</span> ，间距 <spanclass="math inline">\(l=\dfrac{\lambda}{2n_2\theta}\)</span></p><h4 id="牛顿环">牛顿环</h4><figure><img src="/img/image-20231218192505501.png"alt="image-20231218192505501" /><figcaption aria-hidden="true">image-20231218192505501</figcaption></figure><p>明纹：<spanclass="math inline">\(r=\sqrt{(2k-1)\dfrac{R\lambda}{2}},k=1,2,3...\)</span></p><p>暗纹：<span class="math inline">\(r=\sqrt{k\lambdaR},k=0,1,2\)</span></p><h4 id="迈克耳孙干涉仪">迈克耳孙干涉仪</h4><figure><img src="/img/image-20231218194701314.png"alt="image-20231218194701314" /><figcaption aria-hidden="true">image-20231218194701314</figcaption></figure><p><span class="math inline">\(M_1\)</span> 平移 <spanclass="math inline">\(\Delta d\)</span> 时，干涉条纹移过N条，则 <spanclass="math inline">\(\lambda=\dfrac{2\Delta d}{N}\)</span></p><h3 id="光的衍射">光的衍射</h3><p>光在传播过程中遇到大小与波长近似的障碍物时，能绕过障碍物，偏离直线传播的现象</p><p>菲涅尔衍射：光源与衍射屏、衍射屏与接收屏为有限远</p><p>夫琅禾费衍射：均为无限远</p><p>惠更斯-菲涅尔原理：从同一波阵面上各点发出的子波都是相干波，在空间某点相遇时，将进行相干叠加</p><figure><img src="/img/image-20231218195431717.png"alt="image-20231218195431717" /><figcaption aria-hidden="true">image-20231218195431717</figcaption></figure><h4 id="夫琅禾费衍射">夫琅禾费衍射</h4><figure><img src="/img/image-20231218195526995.png"alt="image-20231218195526995" /><figcaption aria-hidden="true">image-20231218195526995</figcaption></figure><p>半波带法：若通过缝的光恰能分为偶数个半波带，则全部干涉相消（暗纹），否则为明纹</p><p>暗纹：<spanclass="math inline">\(a\sin\varphi=\pm2k\dfrac{\lambda}{2},k=1,2,3...\)</span>（倾斜入射时为 <spanclass="math inline">\(a(\sin\varphi\pm\sin\theta)\)</span> ）</p><p>明纹：<spanclass="math inline">\(a\sin\varphi=\pm(2k+1)\dfrac{\lambda}{2},k=1,2,3...\)</span></p><p>中央明纹：<span class="math inline">\(\varphi=0\)</span></p><p>角宽度：<spanclass="math inline">\(\Delta\varphi=\dfrac{\lambda}{a}\)</span>，线宽度：<span class="math inline">\(\Deltax_0=f\tan\varphi=f\dfrac{\lambda}{a}\)</span>。中央明纹角宽度、线宽度均为2倍</p><p>光强分布：<spanclass="math inline">\(I_\varphi=I_m(\dfrac{\sin\alpha}{\alpha})^2\)</span>，<span class="math inline">\(I_m\)</span> 为中央明纹中心处的光强，<spanclass="math inline">\(\alpha=\dfrac{\pia\sin\varphi}{\lambda}\)</span></p><h4 id="分辨功能">分辨功能</h4><figure><img src="/img/image-20231218202254866.png"alt="image-20231218202254866" /><figcaption aria-hidden="true">image-20231218202254866</figcaption></figure><h4 id="光栅衍射">光栅衍射</h4><p>光栅：大量等宽等间距的平行狭缝（或反射面）</p><p>a是透光部分的宽度，b是不透光部分的宽度，则光栅常数 <spanclass="math inline">\(d=a+b\)</span></p><p>光栅的夫琅禾费衍射=单缝衍射+多光束干涉</p><p>光栅方程：<span class="math inline">\(d\sin\varphi=\pmk\lambda,k=0,1,2,...\)</span> 主极大明纹</p><p>暗纹：<spanclass="math inline">\(d\sin\varphi=\pm\dfrac{m\lambda}{N},m\nekN\)</span></p><p>明纹缺级：干涉极大但衍射极小，<spanclass="math inline">\(\dfrac{d}{a}=\dfrac{k}{k&#39;}\)</span></p><p>光强：</p><p><span class="math inline">\(\alpha=\dfrac{\beta}{2}=\dfrac{\pia\sin\varphi}{\lambda},\Delta\varphi=\dfrac{2\pi}{\lambda}(a+b)\sin\varphi\)</span>其中 <span class="math inline">\(\varphi\)</span> 含义与单缝衍射相同</p><p>则 <spanclass="math inline">\(I_0=I_m(\dfrac{\sin\alpha}{\alpha})^2(\dfrac{\sin\frac{N\Delta\varphi}{2}}{\sin\frac{\Delta\varphi}{2}})^2\)</span></p><p>光栅的分辨本领：</p><p>把 <span class="math inline">\(\lambda\)</span> 和 <spanclass="math inline">\(\lambda+\Delta\lambda\)</span> 分开的能力，定义为<span class="math inline">\(R=\dfrac{\lambda}{\Delta\lambda}\)</span>，计算得 <span class="math inline">\(R=kN\)</span>，k为主极大级次，N为总缝数</p><h4 id="x射线衍射">X射线衍射</h4><p>布拉格公式 <spanclass="math inline">\(2d\sin\varphi=k\lambda\)</span></p><h3 id="光的偏振">光的偏振</h3><h4 id="原理与分类">原理与分类</h4><p>原理：光矢量 <span class="math inline">\(\vec{E}\)</span>与光的传播方向垂直，但 <span class="math inline">\(\vec{E}\)</span>在与传播方向垂直的平面内可有不同振动方向、状态</p><ul><li><p>线偏振光：光矢量始终沿某一方向振动</p></li><li><p>自然光：各个方向都有大小、前后不同的光矢量的振动，是对称的</p></li><li><p>部分偏振光：自然光的振动可分解为垂直的两个方向，部分移去其中一个矢量</p></li><li><p>圆（椭圆）偏振光：光矢量绕着光的传播方向旋转，旋转角速度对应于光的角频率。可看成2个振动相互垂直、相位差为<span class="math inline">\(\dfrac{\pi}{2}\)</span>的线偏振光的合成</p></li></ul><p>表示方法：</p><figure><img src="/img/image-20231219222339407.png"alt="image-20231219222339407" /><figcaption aria-hidden="true">image-20231219222339407</figcaption></figure><figure><img src="/img/image-20231219222349776.png"alt="image-20231219222349776" /><figcaption aria-hidden="true">image-20231219222349776</figcaption></figure><figure><img src="/img/image-20231219222358180.png"alt="image-20231219222358180" /><figcaption aria-hidden="true">image-20231219222358180</figcaption></figure><h4 id="起偏与检偏">起偏与检偏</h4><h5 id="概念">概念</h5><p>起偏：用起偏器（如偏振片）从自然光获得偏振光</p><p>偏振片：只允许沿某个方向振动的光矢量透过，此方向称偏振化方向</p><p>检偏：分析光的偏振态</p><h5 id="两大定律">两大定律</h5><p>马吕斯定律：</p><p>强度为 <span class="math inline">\(I_0\)</span>的线偏振光，通过检偏振器后，透射光的强度为 <spanclass="math inline">\(I=I_0\cos^2\alpha\)</span> 。其中 <spanclass="math inline">\(\alpha\)</span>为线偏振光的光振动方向与检偏器的偏振化方向的夹角。自然光通过后强度减半。</p><p>自然光反射、折射后产生部分偏振光</p><p>布儒斯特定律：</p><p>当入射角 <span class="math inline">\(i_B\)</span> 与折射角 <spanclass="math inline">\(\gamma\)</span> 满足 <spanclass="math inline">\(i_B+\gamma=90^\circ\)</span>时，反射光为振动方向垂直于入射面的线偏振光。此时入射角称布儒斯特角或起偏角，且有<span class="math inline">\(\tan i_B=\dfrac{n_2}{n_1}\)</span></p><h5 id="产生方法">产生方法</h5><p>玻璃片堆，多次反射、折射后，可使反射光强度较高，且折射光的偏振度足够高</p><h4 id="双折射">双折射</h4><h5 id="概念-1">概念</h5><p>一束光入射到各向异性介质后，出现两束折射光：寻常光（o光）与非常光（e光）。其中o光遵循折射定律而e光不遵循。o光的光矢量振动方向与o光主平面垂直，e光的光矢量振动方向与e光主平面平行，光轴在入射面时，振动方向相互垂直</p><p>光轴：当光沿此方向入射传播时，不发生双折射。可分为单轴晶体、双轴晶体</p><p>主平面：晶体中光的传播方向与光轴构成的平面</p><p>惠更斯解释：光在晶体中的传播速度与光的传播方向（e光）和偏振状态有关。</p><p><span class="math inline">\(n_e&gt;n_o\)</span>称正晶体，反之称负晶体</p><h5 id="一些镜子">一些镜子</h5><p>尼科耳棱镜：方解石切半+加拿大树胶，射出一束振动方向在纸面内的线偏振光</p><p>沃拉斯顿棱镜：两块方解石、光轴方向垂直、斜向拼接，射出两束分开的、振动方向垂直的线偏振光</p><p>波晶片：表面与晶体光轴平行。当线偏振光垂直表面入射时，设 <spanclass="math inline">\(\alpha\)</span> 为振动方向与光轴的夹角，则 <spanclass="math inline">\(E_o=E\sin\alpha,E_e=E\cos\alpha,\delta=|n_o-n_e|d\)</span>。射出两束传播方向相同、振动方向相互垂直、频率相等、相位差恒定的线偏振光。</p><p>光程差为 <span class="math inline">\(\dfrac{1}{4}\lambda\)</span>的称 <span class="math inline">\(\dfrac{1}{4}\)</span>波片，类推有半波片、全波片</p><h5 id="偏振光的干涉">*偏振光的干涉</h5><figure><img src="/img/image-20231221143642279.png"alt="image-20231221143642279" /><figcaption aria-hidden="true">image-20231221143642279</figcaption></figure><p>光强分布：</p><ol type="1"><li><p>自然光到线偏振光，光强变为 <spanclass="math inline">\(\dfrac{1}{2}I_0\)</span> ，振幅为 <spanclass="math inline">\(A_1\)</span></p></li><li><p>波晶片中 <spanclass="math inline">\(A_{1o}=A_1\cos\alpha,A_{1e}=A_1\sin\alpha,\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d\)</span></p></li><li><p>偏振片P2中 <spanclass="math inline">\(A_{2o}=A_{1o}\sin\beta,A_{2e}=A_{1e}\cos\beta,\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi\)</span></p></li></ol><figure><img src="/img/image-20231221144529306.png"alt="image-20231221144529306" /><figcaption aria-hidden="true">image-20231221144529306</figcaption></figure><p>此例中有附加相位差的原因为 <spanclass="math inline">\(\vec{A_{2e}}\)</span> 和 <spanclass="math inline">\(\vec{A_{2o}}\)</span> 方向相反</p><p>屏幕上光强 <span class="math inline">\(I\proptoA^2=A_{2o}^2+A_{2e}^2+2A_{2o}A_{2e}\cos\Delta\varphi\)</span></p><p>干涉相长：<spanclass="math inline">\(\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi=2k\pi\)</span>，其中 <span class="math inline">\(k=1,2,3,...\)</span></p><p>干涉相消：<spanclass="math inline">\(\Delta\varphi=\dfrac{2\pi}{\lambda}|n_o-n_e|d+\pi=(2k+1)\pi\)</span>，其中 <span class="math inline">\(k=0,1,2,3,...\)</span></p><h5 id="人为双折射">*人为双折射</h5><p>光弹效应：<span class="math inline">\(|n_o-n_e|=cp\)</span>，c是与材料有关的常数，p为样品材料中的应力</p><p>电光效应：<span class="math inline">\(|n_o-n_e|=kE^2\)</span>，k为液体的克尔常数，E为外加电场的电场强度</p><h5 id="旋光性">*旋光性</h5><p>线偏振光通过某些透明物质时，振动面将以光的传播方向为轴线旋转一定角度<span class="math inline">\(\theta=ad\)</span>。a（旋光率）与物质性质、波长有关，d为厚度</p><h2 id="量子物理">量子物理</h2><h3 id="热辐射与量子假设">热辐射与量子假设</h3><h4 id="辐出度基尔霍夫辐射定律">辐出度、基尔霍夫辐射定律</h4><p>辐出度：物体在温度T下单位表面在单位时间内发出的各种波长的总辐射能，记为<span class="math inline">\(M(T)\)</span> ，单位 <spanclass="math inline">\(W/m^2\)</span></p><p>单色辐出度：一定温度T下，单位时间内从物体表面单位面元上发射的波长在<span class="math inline">\(\lambda\sim\lambda+d\lambda\)</span>内的辐射能 <span class="math inline">\(dM_{\lambda}\)</span> 与波长间隔<span class="math inline">\(d\lambda\)</span> 的比值。<spanclass="math inline">\(M_\lambda(T)=\dfrac{dM_\lambda}{d\lambda}\)</span></p><p>单色吸收比：温度T时，物体吸收波长在 <spanclass="math inline">\(\lambda\sim\lambda+d\lambda\)</span>内的辐射能与相应范围内的入射能之比，介于0和1之间，记为 <spanclass="math inline">\(\alpha(\lambda,T)\)</span>。当值为1时，为黑体。</p><p>热辐射是连续的，频谱分布随温度变化，辐射本领强吸收本领也强</p><p>基尔霍夫辐射定律：处于热辐射平衡态的物体，单色辐出度与单色吸收系数的比值都相等，且等于同温度下黑体的单色辐出度</p><p><spanclass="math inline">\(\dfrac{M_{1\lambda}(T)}{\alpha_1(\lambda,T)}=\dfrac{M_{2\lambda}(T)}{\alpha_2(\lambda,T)}=...=M_{B\lambda}(T)\)</span></p><h4 id="黑体辐射定律">黑体辐射定律</h4><p>斯特藩-玻耳兹曼定律： <spanclass="math inline">\(M_B(T)=\int_0^{\infty}M_{B\lambda}(T)d\lambda=\sigmaT^4\)</span> ，其中 <spanclass="math inline">\(\sigma\approx5.67\times10^{-8}W/(m^2\cdotK^4)\)</span> ，称斯特藩常量</p><p>维恩位移定律：峰值波长 <span class="math inline">\(\lambda_m\)</span>满足 <span class="math inline">\(T\lambda_m=b\)</span>，其中b为维恩常量， <span class="math inline">\(b\approx2.898\times10^{-3}m\cdot K\)</span></p><p>普朗克公式：<span class="math inline">\(M_{B\lambda}(T)=\dfrac{2\pic^2h}{\lambda^5}\dfrac{1}{e^{\tfrac{hc}{\lambda kT}}-1}\)</span>，其中k为玻尔兹曼常量</p><p>量子假说：电磁辐射的能量交换只能是量子化的</p><h3 id="光的粒子性">光的粒子性</h3><h4 id="光电效应">光电效应</h4><p>光电效应：光照射某些金属时，能从表面释放出电子</p><p>遏止电压 <span class="math inline">\(U_a\)</span> ：<spanclass="math inline">\(\dfrac{1}{2}mv_m^2=eU_a\)</span></p><p>遏制频率（红限）：<span class="math inline">\(h\nu_0=W_0\)</span></p><p>爱因斯坦光电效应方程：<spanclass="math inline">\(h\nu=\dfrac{1}{2}mv_m^2+A\)</span></p><h4 id="康普顿散射">康普顿散射</h4><figure><img src="/img/image-20231221182623231.png"alt="image-20231221182623231" /><figcaption aria-hidden="true">image-20231221182623231</figcaption></figure><p><spanclass="math inline">\(\Delta\lambda=\dfrac{h}{m_0c}(1-\cos\varphi)=2\lambda_c\sin^2\dfrac{\varphi}{2}\)</span>，其中 <span class="math inline">\(\lambda_c=\dfrac{h}{m_0c}\)</span>称康普顿波长</p><p>对于光： <spanclass="math inline">\(E=h\nu,p=\dfrac{h}{\lambda},m=\dfrac{h}{c\lambda}\)</span></p><h3 id="波尔氢原子理论">波尔氢原子理论</h3><p>氢原子光谱线系：<spanclass="math inline">\(\dfrac{1}{\lambda}=R(\dfrac{1}{k^2}-\dfrac{1}{n^2}),n=k+1,k+2,...\)</span>其中 <spanclass="math inline">\(R=\dfrac{me^4}{8\varepsilon_0^2h^3c}=1.097373\times10^7m^{-1}\)</span>称里德伯常数，k=2时是巴尔末线系</p><p>波尔理论的基本假设：</p><ol type="1"><li><p>定态假设。原子只能处于一系列不连续的能量状态中</p></li><li><p>频率条件。跃迁时，吸收 <spanclass="math inline">\(\nu_{kn}=\dfrac{|E_n-E_k|}{h}\)</span>能量</p></li><li><p>量子化条件。电子绕核作圆周运动时的角动量L是量子化的，只能取 <spanclass="math inline">\(\hbar=\dfrac{h}{2\pi}\)</span> 的整数倍，其中<span class="math inline">\(\hbar\)</span> 是约化普朗克常量</p></li></ol><p>轨道半径 <spanclass="math inline">\(r_n=n^2\dfrac{\varepsilon_0h^2}{\pime^2}=n^2r_1,n=1,2,3...\)</span></p><p>原子能量 <spanclass="math inline">\(E_n=-\dfrac{e^2}{8\pi\varepsilon_0r_n}=-\dfrac{1}{n^2}\dfrac{me^4}{8\varepsilon_0^2h^2},n=1,2,3...\)</span>，其中 <span class="math inline">\(E_1=-13.6eV\)</span></p><h3 id="德布罗意波不确定性原理">德布罗意波、不确定性原理</h3><p>物质波 <spanclass="math inline">\(\lambda=\dfrac{h}{p}=\dfrac{h}{m_0v}\sqrt{1-\dfrac{v^2}{c^2}}\)</span></p><p>动量-坐标不确定关系 <span class="math inline">\(\Delta x\Deltap_x\geqslant\dfrac{\hbar}{2}\)</span></p><p>能量-时间不确定关系 <span class="math inline">\(\Delta E\Deltat\geqslant\dfrac{\hbar}{2}\)</span>，如原子能级宽度和原子在该能级的平均寿命之间的关系</p><h3 id="波函数与薛定谔方程">波函数与薛定谔方程</h3><h4 id="一堆方程">一堆方程</h4><p>物质波的波函数 <span class="math inline">\(\Psi\)</span> 的模的平方<span class="math inline">\(|\Psi(\vec{r},t)|^2\)</span>代表t时刻，r端点处单位体积中发现一个粒子的概率，称概率密度</p><p>波函数应满足以下要求：</p><ol type="1"><li>有限性：概率为有限值</li><li>归一性：<spanclass="math inline">\(\iiint\limits_\Omega|\Psi(\vec{r},t)|^2dV=1\)</span></li><li>单值性：概率密度在任意位置、时刻都是确定的</li><li>连续性：势场性质与边界条件要求波函数及其一阶导数连续</li></ol><p>状态叠加原理：若体系具有一些列互异的可能状态 <spanclass="math inline">\(\{\Psi_1,\Psi_2...\}\)</span> ，则其线性组合 <spanclass="math inline">\(\Psi=\sum C_n\Psi_n\)</span>也是该体系的一个可能状态</p><p>一维自由粒子的波函数： <spanclass="math inline">\(\Psi(x,t)=\Psi_0e^{-i\frac{1}{\hbar}(Et-px)}\)</span>三维：<spanclass="math inline">\(\Psi(\vec{r},t)=\Psi_0e^{-\frac{i}{\hbar}(Et-\vec{p}\vec{x})}\)</span></p><p>一维自由粒子波函数满足的微分方程：<spanclass="math inline">\(i\hbar\dfrac{\partial\Psi}{\partialt}=-\dfrac{\hbar^2}{2m}\dfrac{\partial^2\Psi}{\partial x^2}\)</span></p><p>势场中 <span class="math inline">\(E=\dfrac{p^2}{2m}+V(x,t)\)</span>，有 <span class="math inline">\(i\hbar\dfrac{\partial\Psi}{\partialt}=-\dfrac{\hbar^2}{2m}\dfrac{\partial^2\Psi}{\partialx^2}+V\Psi\)</span></p><p>当势场与时间无关、粒子能量取定值时，有定态波函数 <spanclass="math inline">\(\Psi(x,t)=\Psi(x)e^{-\frac{i}{\hbar}Et}\)</span>，一维定态薛定谔方程 <spanclass="math inline">\(\dfrac{d^2\psi(x)}{dx^2}+\dfrac{2m}{\hbar^2}(E-V)\psi(x)=0\)</span></p><p>三维定态薛定谔方程 <spanclass="math inline">\(\nabla^2\psi(\vec{r})+\dfrac{2m}{\hbar^2}(E-V)\psi(\vec{r})=0\)</span></p><h4 id="一维无限深势阱">一维无限深势阱</h4><p>势能函数满足 <span class="math inline">\(V(x)=\begin{cases}0,\0&lt;x&lt;a \\ \infty,\ 其他\end{cases}\)</span>，类似金属内部自由电子的运动</p><p>解一维定态薛定谔方程得 <spanclass="math inline">\(E_n=\dfrac{h^2}{8ma^2}n^2,\ n=1,2,3,...\)</span>其中 <span class="math inline">\(E_1\)</span> 称零点能。波长 <spanclass="math inline">\(\lambda_n=\dfrac{2a}{n}\)</span></p><p>波函数为 <spanclass="math inline">\(\Psi_n(x,t)=\pm\sqrt{\dfrac{2}{a}}\sin\dfrac{n\pi}{a}xe^{-\tfrac{i}{\hbar}E_nt}\)</span></p><h4 id="势垒穿透">*势垒穿透</h4><p>势能函数满足 <span class="math inline">\(V(x)=\begin{cases}0,\x\leqslant0 \\ U_0,\ x&gt;0\end{cases}\)</span></p><p>粒子从 <span class="math inline">\(-\infty\)</span> 处以能量E入射，<span class="math inline">\(E&lt;U_0\)</span>，类似金属或半导体接触处</p><p>解一维定态薛定谔方程得</p><p>入射波、反射波： <spanclass="math inline">\(\Psi_1(x)=Ae^{ik_1x}+Be^{-ik_1x},k_1=\sqrt{\dfrac{2mE}{\hbar^2}}\)</span></p><p>透射波： <spanclass="math inline">\(\Psi_2(x)=Ce^{-k_2x}=Ce^{-\tfrac{1}{\hbar}\sqrt{2m(U_0-E)}x}\)</span></p><p>若势垒有限宽，即 <span class="math inline">\(V(x)=\begin{cases}0,\x\leqslant0 \\ U_0,\ 0&lt;x&lt;a\\ 0,x\geqslant a\end{cases}\)</span>，则波穿过后以平面波的形式继续前进，振幅为 <spanclass="math inline">\(\Psi_2(a)=Ce^{-\tfrac{a}{\hbar}\sqrt{2m(U_0-E)}}\)</span></p><h4 id="一维谐振子">*一维谐振子</h4><p>势能 <spanclass="math inline">\(V(x)=\dfrac{1}{2}kx^2=\dfrac{1}{2}m\omega^2x^2\)</span></p><p>谐振子的定态薛定谔方程 <spanclass="math inline">\(\dfrac{d^2\psi(x)}{dx^2}+\dfrac{2m}{\hbar^2}(E-\dfrac{1}{2}m\omega^2x^2)\psi(x)=0\)</span></p><p>解得 <spanclass="math inline">\(E_n=(n+\dfrac{1}{2})\hbar\omega=(n+\dfrac{1}{2})h\nu,n=0,1,2...\)</span></p><h4 id="氢原子">*氢原子</h4><p><spanclass="math inline">\(\nabla^2\psi(\vec{r})+\dfrac{2m}{\hbar^2}(E-V)\psi(\vec{r})=0\)</span>，<spanclass="math inline">\(V(r)=-\dfrac{e^2}{4\pi\varepsilon_0r}\)</span></p><p><spanclass="math inline">\(E_n=-\dfrac{me^4}{8h^2\varepsilon_0^2}\dfrac{1}{n^2}=-\dfrac{13.6}{n^2}(eV),n=1,2,3...\)</span><span class="math inline">\(n\)</span> 为主量子数</p><p><spanclass="math inline">\(L=\sqrt{l(l+1)}\hbar,l=0,1,...n-1\)</span> ，其中<span class="math inline">\(l\)</span> 称角（副）量子数</p><p>角动量在空间的取向也是量子化的，<spanclass="math inline">\(L_z=m_l\hbar,m_l=0,\pm1,...\pm l\)</span> ，<spanclass="math inline">\(m_l\)</span> 称磁量子数</p><p>波函数 <spanclass="math inline">\(\Psi_{n,l,m_l}(r,\theta,\varphi)=R_{nl}(r)Y_{lm_l}(\theta,\varphi)\)</span>，可分为镜像波函数、角向波函数</p><h3 id="原子中的电子">原子中的电子</h3><h4 id="电子自旋与四个量子数">电子自旋与四个量子数</h4><p>自旋量子数s，自旋磁量子数 <span class="math inline">\(m_S\)</span>，自旋角动量 <span class="math inline">\(S=\sqrt{s(s+1)}\hbar\)</span>自旋角动量在外磁场方向的投影 <spanclass="math inline">\(S_z=m_S\hbar\)</span></p><p>原子中的电子运动由4个量子数决定</p><ol type="1"><li>主量子数 <span class="math inline">\(n=1,2,3...\)</span>，大体决定原子中电子的能量</li><li>角量子数 <span class="math inline">\(l=0,1,2...(n-1)\)</span>，决定电子轨道角动量大小 <spanclass="math inline">\(L=\sqrt{l(l+1)}\hbar\)</span></li><li>磁量子数 <span class="math inline">\(m_l=0,\pm1,\pm2,...\pml\)</span> ，决定电子的轨道角动量在外磁场方向的投影 <spanclass="math inline">\(L_z=m_l\hbar\)</span></li><li>自旋磁量子数 <spanclass="math inline">\(m_s=\pm\dfrac{1}{2}\)</span>，决定电子的自旋角动量在外磁场方向的投影 <spanclass="math inline">\(S_z=m_s\hbar\)</span></li></ol><h4 id="电子壳层结构">电子壳层结构</h4><p>泡利不相容原理：同一原子中，不可能有两个或两个以上的电子具有完全相同的量子状态</p><p>主量子数为n的壳层内最多容纳 <spanclass="math inline">\(Z_n=2n^2\)</span> 个电子，l支壳层最多容纳 <spanclass="math inline">\(2(2l+1)\)</span></p><p>能量最小原理：原子系统处于正常状态时，每个电子趋向占有最低的能级</p><p>主量子数n对应 <span class="math inline">\(1s,2s,...ns\)</span>，角量子数l则对应 <span class="math inline">\(4s,4p,4d,4f...\)</span>中的spdf</p><p>经验规律： <span class="math inline">\(n+0.7l\)</span>的值越小，能级越低</p><p>填充顺序： <spanclass="math inline">\(1s,2s,2p,3s,3p,4s,3d,4p,5s,4d,5p,6s,4f,5d,6p...\)</span></p><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/df87013877101c94316fec62af77c22e.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概统笔记</title>
    <link href="/2024/01/14/%E6%A6%82%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/14/%E6%A6%82%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><span class="math inline">\(\mathcal{Author:gpf}\)</span></p></blockquote><h2 id="随机事件的概率">随机事件的概率</h2><h3 id="概念">概念</h3><p><span class="math inline">\(P(A)=0\nRightarrowA=\emptyset\)</span></p><p><span class="math inline">\(A\cap B=\emptyset\nRightarrow\)</span><span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span> 独立</p><p><span class="math inline">\(A\)</span>、<spanclass="math inline">\(B\)</span> 独立 <spanclass="math inline">\(\nRightarrow\bar{A}\)</span>、<spanclass="math inline">\(B\)</span> 独立</p><p>互不相容（交集为空）、互逆根据事件定义，独立根据概率定义</p><h3 id="公式">公式</h3><p>加法公式：<spanclass="math inline">\(P(A+B)=P(A)+P(B)-P(AB)\)</span></p><p>条件概率：<spanclass="math inline">\(P(A|B)=\dfrac{P(AB)}{P(B)}\)</span></p><p>全概率公式：<spanclass="math inline">\(P(A)=\sum\limits_{i=1}^nP(B_i)P(A|B_i)\)</span>，其中<span class="math inline">\(\sum\limits_{i=1}^nP(B_i)=S\)</span>、<spanclass="math inline">\(P(B_i)&gt;0\)</span> 且 <spanclass="math inline">\(B_i\)</span> 互不相容</p><p>另有 <span class="math inline">\(P(A)=P(AB)+P(A\bar{B})\)</span></p><p>贝叶斯公式：<spanclass="math inline">\(P(A|B)=\dfrac{P(A)P(B|A)}{P(B)}=\dfrac{P(A)P(B|A)}{P(A)P(B|A)+P(\bar{A})P(B|\bar{A})}\)</span></p><h2 id="随机变量及其分布">随机变量及其分布</h2><h3 id="一维随机变量">一维随机变量</h3><h4 id="两点分布">两点分布</h4><h4 id="泊松分布">泊松分布</h4><p><spanclass="math inline">\(P\{X=k\}=e^{-\lambda}\dfrac{\lambda^k}{k!},k=0,1,2...\)</span>其中 <span class="math inline">\(\lambda&gt;0\)</span>，记作 <spanclass="math inline">\(X\sim\Pi(\lambda)\)</span></p><p>重要公式：<spanclass="math inline">\(e^x=\sum\limits_{k=0}^{+\infty}\dfrac{x^k}{k!}\)</span></p><h4 id="几何分布">几何分布</h4><p>n次伯努利实验中，实验k次才成功一次的概率</p><p><span class="math inline">\(P\{x=k\}=(1-p)^{k-1}p,k=1,2,...\)</span>，记为 <span class="math inline">\(X\sim GE(p)\)</span></p><h4 id="超几何分布">超几何分布</h4><p>书上定义：</p><p>M件正品，N件次品，从中任意取n件，取到的次品数X。</p><p><spanclass="math inline">\(P\{X=k\}=\dfrac{C_N^kC_M^{n-k}}{C_{M+N}^n},k=0,1,2...l,l=\min\{n,N\}\)</span></p><p>讲义、高中、百度百科定义：</p><p>N件产品，M件次品，从中任意取n件，取到的次品数X。</p><p><spanclass="math inline">\(P\{X=k\}=\dfrac{C_M^kC_{N-M}^{n-k}}{C_N^n},k=0,1,2...l,l=\min\{n,M\}\)</span>，记为 <span class="math inline">\(X\sim H(n,M,N)\)</span></p><p>N、M较大时，可用二项分布逼近，<spanclass="math inline">\(p=\dfrac{M}{N}\)</span></p><h4 id="二项分布">二项分布</h4><p><span class="math inline">\(P\{X=k\}=C_n^kp^k(1-p)^{n-k}\)</span>，记作 <span class="math inline">\(X\sim B(n,p)\)</span></p><p>当n很大、p较小时，二项分布近似于泊松分布，且有 <spanclass="math inline">\(C_n^kp^k(1-p)^{n-k}\approx\dfrac{e^{-\lambda}\lambda^k}{k!}\)</span>，其中<span class="math inline">\(\lambda=np\)</span></p><h4 id="均匀分布">均匀分布</h4><h4 id="指数分布">指数分布</h4><p><span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambdax}&amp;x\geqslant0\\0&amp;x&lt;0\end{cases}\)</span> ，其中 <spanclass="math inline">\(\lambda&gt;0\)</span> 为常数，称服从参数为 <spanclass="math inline">\(\lambda\)</span> 的指数分布</p><p>指数分布具有无后效性</p><h4 id="正态分布">正态分布</h4><p><spanclass="math inline">\(f(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{-\tfrac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty\)</span>，记作 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span></p><p>重要公式：<spanclass="math inline">\(\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}\)</span></p><p><spanclass="math inline">\(F(x)=\Phi(\frac{x-\mu}{\sigma})\)</span></p><p><spanclass="math inline">\(\Gamma(x)=\int_0^{+\infty}t^{x-1}e^{-t}dt\)</span>，<span class="math inline">\(\Gamma(x+1)=x\Gamma(x)\)</span> ，<spanclass="math inline">\(\Gamma(n)=(n-1)!\)</span> ，<spanclass="math inline">\(\Gamma(\frac{1}{2})=\sqrt{\pi}\)</span></p><h3 id="二维随机变量">二维随机变量</h3><p>二维正态分布：</p><p><spanclass="math inline">\(f(x,y)=\dfrac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\tfrac{1}{2(1-\rho^2)}[(\tfrac{x-\mu_1}{\sigma_1})^2-2\rho\tfrac{x-\mu_1}{\sigma_1}\tfrac{y-\mu_2}{\sigma_2}+(\tfrac{y-\mu_2}{\sigma_2})^2]}\)</span>，<span class="math inline">\((X,Y)\simN(\mu_1,\sigma_1^2;\mu_2,\sigma_2^2;\rho)\)</span></p><p>条件分布：<spanclass="math inline">\(F_{X|Y}(x)=\int_{-\infty}^{x}\dfrac{f(u,y)}{f_Y(y)}du,f_{X|Y}(x)=\dfrac{f(x,y)}{f_Y(y)}\)</span></p><p>X、Y独立：<spanclass="math inline">\(F(x,y)=F_X(x)F_Y(y),f(x,y)=f_X(x)f_Y(y)\)</span>，并且任意<span class="math inline">\(U=g(X),V=f(Y)\)</span>，U,V相互独立</p><h3 id="复合随机变量">复合随机变量</h3><h4 id="一般方法">一般方法</h4><ul><li>一维：记 <span class="math inline">\(Y=g(X),D_y=\{x|g(x)\leqslanty\}=g^{-1}\{(-\infty,y]\}\)</span>，则有</li></ul><p><span class="math display">\[\begin{aligned}F_Y(y)&amp;=p\{Y\leqslant y\}=P\{g(X)\leqslant y\}\\&amp;=P\{X\in D_y\}=\int_{D_y}f(x)dx\\f_Y(y)&amp;=F_Y(y)&#39;\end{aligned}\]</span></p><ul><li>二维：记 <spanclass="math inline">\(Z=g(X,Y),D_z=\{(x,y)|g(x,y\leqslantz)\}\)</span>，则有</li></ul><p><span class="math display">\[\begin{aligned}F_Z(z)&amp;=p\{Z\leqslant z\}=P\{g(X,Y)\leqslant z\}\\&amp;=P\{(X,Y)\in D_z\}=\iint\limits_{D_y}f(x,y)dxdy\\f_Z(z)&amp;=F_Z(z)&#39;\end{aligned}\]</span></p><h4 id="特殊方法">特殊方法</h4><ul><li><p>一维概率密度，<span class="math inline">\(Y=g(X)\)</span>且g严格单调，有 <spanclass="math inline">\(f_Y(y)=f(g^{-1}(y))\cdot|(g^{-1}(y))&#39;|\)</span></p></li><li><p><span class="math inline">\(Z=X+Y\)</span></p></li></ul><p><span class="math display">\[\begin{aligned}F_Z(z)&amp;=P\{Z\leqslant z\}=P\{X+Y\leqslant z\}\\&amp;=\iint\limits_{D_z}f(x,y)dxdy\\&amp;=\int_{-\infty}^{+\infty}[\int_{-\infty}^{z-x}f(x,y)dy]dx\\&amp;=\int_{-\infty}^{+\infty}[\int_{-\infty}^{z}f(x,t-x)dt]dx\\&amp;=\int_{-\infty}^{z}[\int_{-\infty}^{+\infty}f(x,t-x)dx]dt\\f_Z(z)&amp;=\int_{-\infty}^{+\infty}f(x,z-x)dx\end{aligned}\]</span></p><ul><li><span class="math inline">\(Z=\max\{X,Y\}\)</span></li></ul><p><span class="math display">\[\begin{aligned}F_{\max}(z)&amp;=P\{Z\leqslant z\}=P\{\max\{X,Y\}\leqslant z\}\\&amp;=P\{X\leqslant z,Y\leqslant z\}=F(z,z)\\&amp;=\int_{-\infty}^z\int_{-\infty}^zf(x,y)dxdy\\&amp;=F_X(z)\cdot F_Y(z)（X与Y独立）\end{aligned}\]</span></p><ul><li><span class="math inline">\(Z=\min\{X,Y\}\)</span></li></ul><p>法一：</p>$$<span class="math display">\[\begin{aligned}F_{\min}(z)&amp;=P\{Z\leqslant z\}=P\{\min\{X,Y\}\leqslant z\}\\&amp;=P(\{X\leqslant z\}+\{Y\leqslant z\})\\&amp;=P\{X\leqslant z\}+P\{Y\leqslant z\}-P\{X\leqslant z,Y\leqslantz\}\\&amp;=F_X(z)+F_Y(z)-F(z,z)\end{aligned}\]</span><p>$$</p><p>法二：</p>$$<span class="math display">\[\begin{aligned}F_{\min}(z)&amp;=P\{Z\leqslant z\}=P\{\min\{X,Y\}\leqslant z\}\\&amp;=1-P\{\min\{X,Y\}&gt;z\}=1-P\{X&gt;z,Y&gt;z\}\\&amp;=1-\iint\limits_{x&gt;z\atop y&gt;z}f(x,y)dxdy\\&amp;=1-[1-F_X(z)]\cdot[1-F_Y(z)] （X，Y独立）\end{aligned}\]</span><p>$$</p><h4 id="特殊分布">特殊分布</h4><p>若 <span class="math inline">\(X_i\simN(\mu_i,\sigma_i^2)\)</span>，且<strong>相互独立</strong>，则有 <spanclass="math inline">\(Z=\sum\limits_{i=1}^nk_iX_i+b\simN(\sum\limits_{i=1}^nk_i\mu_i,\sum\limits_{i=1}^nk_i^2\sigma_i^2)\)</span></p><p>若 <span class="math inline">\(X\sim\Pi(\lambda_1),Y\sim\Pi(\lambda_2)\)</span>，且<strong>相互独立</strong>，则有<spanclass="math inline">\(Z=X+Y\sim\Pi(\lambda_1+\lambda_2)\)</span></p><h2 id="随机变量的数字特征">随机变量的数字特征</h2><h3 id="期望">期望</h3><h4 id="基本定义">基本定义</h4><p>离散：<spanclass="math inline">\(E(X)=EX=\sum\limits_{k=1}^{+\infty}x_kp_k\)</span></p><p>连续：<spanclass="math inline">\(EX=\int_{-\infty}^{+\infty}xf(x)dx\)</span></p><p>二维：<spanclass="math inline">\(E(XY)=\sum\limits_i\sum\limits_jx_iy_jp_{ij}=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xyf(x,y)dxdy\)</span></p><h4 id="性质">性质</h4><ul><li><p><spanclass="math inline">\(Y=g(X),则EY=\int_{-\infty}^{+\infty}g(X)f(x)dx\)</span>*要求积分绝对收敛</p></li><li><p><span class="math inline">\(C\)</span> 为常数，则 <spanclass="math inline">\(E(C)=C\)</span></p></li><li><p><span class="math inline">\(E(CX)=CE(X)\)</span> <spanclass="math inline">\(E(X+Y)=EX+EY\)</span></p></li><li><p>若X,Y<strong>独立</strong>，则 <spanclass="math inline">\(E(XY)=EX\cdot EY\)</span></p></li></ul><h3 id="方差">方差</h3><h4 id="基本定义-1">基本定义</h4><p><span class="math inline">\(DX=D(X)=E(X-EX)^2\)</span> ，<spanclass="math inline">\(\sqrt{DX}\)</span> 称标准差（均方差）</p><h4 id="性质-1">性质</h4><ul><li><p><span class="math inline">\(DX=EX^2-(EX)^2\)</span>非常重要，经常使用！！！</p></li><li><p><span class="math inline">\(C\)</span> 为常数，<spanclass="math inline">\(D(C)=0\)</span></p></li><li><p><span class="math inline">\(D(CX)=C^2DX\)</span></p></li><li><p>X,Y<strong>独立</strong>，则 <spanclass="math inline">\(D(aX+bY+c)=a^2DX+b^2DY\)</span></p></li><li><p>若 <span class="math inline">\(EX^2\)</span> 存在，则 <spanclass="math inline">\(k=EX\)</span> 时，有 <spanclass="math inline">\(\min\{E(X-k)^2\}=DX\)</span></p></li></ul><h3 id="其他特征">其他特征</h3><h4 id="协方差">协方差</h4><p><span class="math inline">\(cov(X,Y)=E(X-EX)(Y-EY)\)</span> ，可记为<span class="math inline">\(\sigma_{XY}\)</span></p><ul><li><p>计算：<spanclass="math inline">\(cov(X,Y)=E(XY)-EXEY\)</span></p></li><li><p>对称性：<span class="math inline">\(cov(X,Y)=cov(Y,X)\)</span>，且 <span class="math inline">\(cov(X,X)=DX\)</span></p></li><li><p>线性：<spanclass="math inline">\(cov(aX,bY)=abcov(X,Y)\)</span></p></li><li><p>求和：<span class="math inline">\(cov(\sum X_i,\sumY_j)=\sum_i\sum_jcov(X_i,Y_j)\)</span></p></li><li><p><span class="math inline">\(D(\sum X_i)=\sumD(X_i)+\sum\sum_{i\ne j}cov(X_i,Y_j)\)</span></p></li></ul><h4 id="相关系数">相关系数</h4><p><spanclass="math inline">\(\rho(X,Y)=\dfrac{cov(X,Y)}{\sqrt{DXDY}}\)</span>，记为 <span class="math inline">\(\rho_{XY}\)</span></p><ul><li><p>独立一定不相关，不相关不一定独立</p></li><li><p>二维正态分布下，不相关=独立</p></li></ul><h3 id="矩矩母函数协方差矩阵">*矩、矩母函数、协方差矩阵</h3><p><spanclass="math inline">\(EX^n=\int_{-\infty}^{+\infty}x^nf(x)dx\)</span>为X的n阶矩，<span class="math inline">\(E(X-EX)^n\)</span>称X的n阶中心矩</p><p>X的期望存在，则X的矩母函数定义为 <spanclass="math inline">\(M_X(s)=E(e^{sX})\)</span> ，记为 <spanclass="math inline">\(M(s)\)</span></p><p><spanclass="math inline">\(EX^n=\dfrac{d^nM(s)}{ds^n}|_{s=0}\)</span></p><p>正态分布 <span class="math inline">\(X\sim N(0,\sigma^2)\)</span>，则有</p><p><spanclass="math inline">\(EX^k=\dfrac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^{+\infty}x^ke^{-\tfrac{x^2}{2\sigma^2}}dx=\sqrt{\frac{2}{\pi}}\sigma^k2^{\frac{(k-1)}{2}}\Gamma(\frac{k+1}{2})=\sigma^k(k-1)(k-3)...1\)</span></p><p>对n维随机向量 <span class="math inline">\((X_1,X_2,...,X_n)\)</span>，若 <spanclass="math inline">\(C_{ij}=Cov(X_i,X_j)=E[(X_i-EX_i)(X_j-EX_j)]\)</span>存在，则矩阵 <span class="math inline">\(C=(C_{ij})_{n\times n}\)</span>称n维随机向量的协方差矩阵</p><p>设 <spanclass="math inline">\(X=(x_1,x_2,...,x_n)^T,U=(\mu_1,\mu_2,...,\mu_n)^T,C\)</span>，且n维随机变量 <span class="math inline">\((X_1,X_2,...,X_n)\)</span>概率密度满足 <spanclass="math inline">\(f(x_1,x_2,...,x_n)=\dfrac{1}{(2\pi)^{\tfrac{n}{2}}(\detC)^{\tfrac{1}{2}}}\exp[-\dfrac{1}{2}(X-U)^TC^{-1}(X-U)]\)</span>，则称n维正态随机变量</p><h3 id="常见分布的数字特征">常见分布的数字特征</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">形式</th><th style="text-align: center;">分布律/概率密度</th><th style="text-align: center;">EX</th><th style="text-align: center;">DX</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">两点分布</td><td style="text-align: center;"></td><td style="text-align: center;"><spanclass="math inline">\(P(x=0)=1-p,P(x=1)=p\)</span></td><td style="text-align: center;">p</td><td style="text-align: center;">p(1-p)</td></tr><tr class="even"><td style="text-align: center;">二项分布</td><td style="text-align: center;"><span class="math inline">\(X\simB(n,p)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P(x=k)=C_n^kp^n(1-p)^{n-k}\)</span></td><td style="text-align: center;">np</td><td style="text-align: center;">np(1-p)</td></tr><tr class="odd"><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><span class="math inline">\(X\sim\Pi(\lambda)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{X=k\}=e^{-\lambda}\frac{\lambda^k}{k!}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\lambda\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\lambda\)</span></td></tr><tr class="even"><td style="text-align: center;">几何分布</td><td style="text-align: center;"><span class="math inline">\(X\simGE(p)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{x=k\}=(1-p)^{k-1}p\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{p}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1-p}{p^2}\)</span></td></tr><tr class="odd"><td style="text-align: center;">超几何分布</td><td style="text-align: center;"><span class="math inline">\(X\simH(n,M,N)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(P\{X=k\}=\dfrac{C_M^kC_{N-M}^{n-k}}{C_N^n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{nM}{N}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{nM}{N}(1-\dfrac{M}{N})\dfrac{N-n}{N-1}\)</span></td></tr><tr class="even"><td style="text-align: center;">均匀分布</td><td style="text-align: center;"><span class="math inline">\(X\simU(a,b)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{b-a}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{a+b}{2}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{(b-a)^2}{12}\)</span></td></tr><tr class="odd"><td style="text-align: center;">指数分布</td><td style="text-align: center;"></td><td style="text-align: center;"><span class="math inline">\(f(x)=\lambdae^{-\lambda x},x\geqslant0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{\lambda}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{1}{\lambda^2}\)</span></td></tr><tr class="even"><td style="text-align: center;">正态分布</td><td style="text-align: center;"><span class="math inline">\(X\simN(\mu,\sigma^2)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{\sigma\sqrt{2\pi}}e^{-\tfrac{(x-\mu)^2}{2\sigma^2}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\mu\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\sigma^2\)</span></td></tr><tr class="odd"><td style="text-align: center;">卡方分布</td><td style="text-align: center;"><span class="math inline">\(X\sim\chi(n)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(x)=\dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}x^{\tfrac{n}{2}-1}e^{-\tfrac{x}{2}}\)</span></td><td style="text-align: center;">n</td><td style="text-align: center;">2n</td></tr><tr class="even"><td style="text-align: center;">t分布</td><td style="text-align: center;"><span class="math inline">\(X\simt(n)\)</span></td><td style="text-align: center;"><spanclass="math inline">\(f(t)=\dfrac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\dfrac{t^2}{n})^{-\tfrac{n+1}{2}}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><spanclass="math inline">\(\dfrac{n}{n-2}\)</span></td></tr></tbody></table><h2 id="不等式与大数定律">不等式与大数定律</h2><h3 id="概率不等式">概率不等式</h3><p>柯西-许瓦茨不等式：<spanclass="math inline">\(EX^2EY^2\geqslant(EXY)^2\)</span></p><p><spanclass="math inline">\((E|X+Y|^2)^{\frac{1}{2}}\leqslant(EX^2)^{\frac{1}{2}}+(EY^2)^{\frac{1}{2}}\)</span></p><p>琴生不等式：若 <span class="math inline">\(g(x)\)</span> 是凸函数，则<span class="math inline">\(Eg(X)\geqslant g(EX)\)</span></p><p>马尔可夫不等式：设随机变量X非负，则任意a&gt;0，k&gt;0，<spanclass="math inline">\(P(X&gt;a)\leqslant\dfrac{EX^k}{a^k}\)</span></p><p>切比雪夫不等式：设随机变量均值 <spanclass="math inline">\(\mu\)</span>，方差 <spanclass="math inline">\(\sigma^2\)</span>，则任意a&gt;0，<spanclass="math inline">\(P(|X-\mu|\geqslantk)\leqslant\dfrac{\sigma^2}{k^2}\)</span></p><p>弱大数定律：设 <span class="math inline">\(X_i\)</span>是独立同分布的随机变量列，期望方差存在，则对任意 <spanclass="math inline">\(\epsilon&gt;0\)</span>， <spanclass="math inline">\(\lim\limits_{n\to\infty}P(|\overline{X_n}-\mu|\geqslant\epsilon)=0\)</span>。其中，<spanclass="math inline">\(\overline{X_n}=\dfrac{1}{n}\sum\limits_{i=1}^{i=n}X_i\)</span></p><p>强大数定律：有限四阶矩存在，<spanclass="math inline">\(P(\lim\limits_{n\to\infty}\overline{X_n}=\mu)=1\)</span></p><h3 id="随机变量的极限">*随机变量的极限</h3><p>依概率收敛：<spanclass="math inline">\(P(|X_n-X|\geqslant\varepsilon)\to0\)</span>，记为<span class="math inline">\(X_n\xrightarrow{P}X\)</span></p><p>以概率1收敛：<span class="math inline">\(P(\lim X_n=X)=1\)</span>，记为 <span class="math inline">\(X_n\xrightarrow{as}X\)</span></p><p>依分布收敛：<span class="math inline">\(\lim P(X_n\leqslantx)=F_X(x),\lim F_{X_{n}}(x)=F_X(x)\)</span> ，记为 <spanclass="math inline">\(X_n\xrightarrow{d}X\)</span></p><h3 id="中心极限定理">中心极限定理</h3><p>独立同分布随机变量序列 <span class="math inline">\(X_n\)</span>，期望方差存在，定义 <spanclass="math inline">\(S_n=\sum\limits_{i=1}^{i=n}X_i,\xi_n=\dfrac{S_n-n\mu}{\sqrt{n\sigma^2}}\)</span>，则<span class="math inline">\(\xi_n\xrightarrow{d}N(0,1)\)</span></p><p>即对充分大的n，可用 <span class="math inline">\(S_n\simN(n\mu,n\sigma^2)\)</span> 逼近</p><h2 id="统计总体与样本">统计总体与样本</h2><h3 id="样本矩与统计量">样本矩与统计量</h3><p>简单随机样本：样本之间相互独立，且与总体同分布</p><p>设 <span class="math inline">\(X_1,X_2,...X_n\)</span>为来自于总体X的一个样本</p><p>样本均值：<spanclass="math inline">\(\overline{X}=\dfrac{1}{n}\sum\limits_{i=1}^{n}X_i\)</span></p><p>样本方差：<spanclass="math inline">\(S^2=\dfrac{1}{n-1}\sum\limits_{i=1}^n(X_i-\overline{X})^2\)</span></p><p>样本k阶矩（原点矩）：<spanclass="math inline">\(A_k=\dfrac{1}{n}\sum\limits_{i=1}^nX_i^k\)</span></p><p>样本k阶中心矩：<spanclass="math inline">\(B_k=\dfrac{1}{n}\sum\limits_{i=1}^n(X_i-\overline{X})^k\)</span></p><p>以上四个都是随机变量，若用观察值代替，则分别是对应随机变量的观察值</p><p>总体矩：<spanclass="math inline">\(\mu=EX,\mu_k=EX^k,\nu_k=EX^k\)</span> ，且有 <spanclass="math inline">\(A_k\xrightarrow{P}\mu_k\)</span></p><h3 id="常用统计量的分布">常用统计量的分布</h3><h4 id="正态分布-1">正态分布</h4><p>总体 <span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span></p><p><span class="math inline">\(\overline{X}\simN(\mu,\dfrac{\sigma^2}{n})\)</span></p><p><spanclass="math inline">\(\dfrac{(n-1)}{\sigma^2}S^2\sim\chi^2(n-1)\)</span>，且样本均值与样本方差相互独立</p><p><spanclass="math inline">\(\dfrac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}\simt(n-1)\)</span></p><h4 id="卡方分布">卡方分布</h4><p>设 <span class="math inline">\(X_1,X_2,...X_n\)</span>相互独立且都服从标准正态分布，则 <spanclass="math inline">\(Y=\chi^2=\sum\limits_{i=1}^nX_i^2\sim\chi^2(n)\)</span></p><p>概率密度为 <spanclass="math inline">\(f(y)=\dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}y^{\tfrac{n}{2}-1}e^{-\tfrac{y}{2}},(y&gt;0);EY=n,DY=2n\)</span></p><p>若 <spanclass="math inline">\(X_1\sim\chi^2(n_1),X_2\sim\chi^2(n_2)\)</span> 且<span class="math inline">\(X_1\)</span> 与 <spanclass="math inline">\(X_2\)</span> 相互独立，则 <spanclass="math inline">\(X_1+X_2\sim\chi^2(n_1+n_2)\)</span></p><h4 id="t分布">t分布</h4><p><span class="math inline">\(X\sim N(0,1),Y\sim\chi^2(n)\)</span>，且X、Y相互独立，则 <spanclass="math inline">\(T=\dfrac{X}{\sqrt{\frac{Y}{n}}}\sim t(n)\)</span>，n为自由度</p><p>概率密度为 <spanclass="math inline">\(f(t)=\dfrac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}(1+\dfrac{t^2}{n})^{-\tfrac{n+1}{2}}\)</span></p><p>满足 <span class="math inline">\(F(t_{\alpha}(n))=\alpha\)</span>的点 <span class="math inline">\(t_{\alpha}(n)\)</span> 称t分布的 <spanclass="math inline">\(\alpha\)</span> 分位点，<spanclass="math inline">\(t_{1-\alpha}(n)=-t_{\alpha}(n)\)</span></p><p>当n很大时，t分布接近于标准正态分布</p><h4 id="f分布">F分布</h4><p><spanclass="math inline">\(X\sim\chi^2(n_1),Y\sim\chi^2(n_2)\)</span>且相互独立，则 <spanclass="math inline">\(F=\dfrac{\frac{X}{n_1}}{\frac{Y}{n_2}}\simF(n_1,n_2)\)</span></p><p>概率分布为 <spanclass="math inline">\(f(u)=\dfrac{\Gamma(\frac{n_1+n_2}{2})}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})}(\frac{n_1}{n_2})(\frac{n_1}{n_2}u)^{\tfrac{n_1}{2}-1}(1+\frac{n_1}{n_2}u)^{-\tfrac{n_1+n_2}{2}},u&gt;0\)</span></p><p><spanclass="math inline">\(F_{1-\alpha}(n_1,n_2)=\dfrac{1}{F_\alpha(n_2,n_1)}\)</span>（分位点，非概率）</p><h2 id="经典统计推断">经典统计推断</h2><h3 id="参数点估计">参数点估计</h3><h4 id="矩估计">矩估计</h4><p>用样本矩估计总体矩，即有</p><p>$$ =_{i=1}^nX_i=\</p><p>=_{i=1}<sup>n(X_i-)</sup>2=S^2 $$</p><p>方法：先求对应的矩，然后用样本均值等矩估计随机变量表示参数，最后把样本值代入即可得到估计值</p><h4 id="极大似然法mle">极大似然法（MLE）</h4><p>对于连续型总体，记 <spanclass="math inline">\(L(\theta)=L(x_1,x_2,...,x_n;\theta)=\prod\limits_{i=1}^nf(x_i;\theta)\)</span>为似然函数，选取使 <spanclass="math inline">\(L(\hat{\theta})=\max\limits_{\theta\in\Theta}L(\theta)\)</span>成立的 <span class="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的极大似然估计</p><p>方法：求 <spanclass="math inline">\(\dfrac{d}{d\theta}L(\theta)=0\)</span> 或 <spanclass="math inline">\(\dfrac{d}{d\theta}\ln L(\theta)=0\)</span></p><h4 id="常见分布的估计值">常见分布的估计值</h4><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">矩估计</th><th style="text-align: center;">极大似然估计</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">二项分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{p}=\dfrac{\bar{x_n}}{N}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{p}=\dfrac{\bar{x_n}}{N}\)</span></td></tr><tr class="even"><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\bar{x_n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\bar{x_n}\)</span></td></tr><tr class="odd"><td style="text-align: center;">均匀分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{b}=2\bar{x}_n\)</span></td><td style="text-align: center;"><span class="math inline">\(\hat{b}=\maxx_i\)</span></td></tr><tr class="even"><td style="text-align: center;">指数分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\dfrac{1}{\bar{x_n}}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\lambda}=\dfrac{1}{\bar{x_n}}\)</span></td></tr><tr class="odd"><td style="text-align: center;">正态分布</td><td style="text-align: center;"><spanclass="math inline">\(\hat{\mu}=\bar{x_n}\)</span></td><td style="text-align: center;"><spanclass="math inline">\(\hat{\sigma^2}=\dfrac{1}{n}\sum(x_i-\hat{\mu})^2\)</span></td></tr></tbody></table><p>*除均匀分布外，表中估计值二者都一样</p><h3 id="点估计的评价">点估计的评价</h3><h4 id="无偏估计">无偏估计</h4><p>设 <span class="math inline">\(\hat{\theta}(x_1,x_2,...,x_n)\)</span>是未知参数 <span class="math inline">\(\theta\)</span> 的估计量，若<span class="math inline">\(E(\hat{\theta})=\theta\)</span> ，则称 <spanclass="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的无偏估计</p><p>样本均值和样本方差是总体均值、方差的无偏估计。但方差的矩估计、MLE估计<spanclass="math inline">\(\dfrac{1}{n}\sum(X_i-\overline{X_n})^2\)</span>不是无偏估计。均匀分布下MLE的估计不是无偏估计</p><h4 id="最小方差无偏估计">最小方差无偏估计</h4><p>设 <span class="math inline">\(\hat{\theta_1}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的一个无偏估计，若对 <spanclass="math inline">\(\theta\)</span> 的任一无偏估计 <spanclass="math inline">\(\hat{\theta_2}\)</span> ， <spanclass="math inline">\(D(\hat{\theta_1})\leqslantD(\hat{\theta_2})\)</span> 成立，则称 <spanclass="math inline">\(\hat{\theta_1}\)</span> 是 <spanclass="math inline">\(\theta\)</span> 的最小方差无偏估计</p><p>正态总体下，<span class="math inline">\(\mu\)</span>的最小方差线性无偏估计为样本均值</p><p>均匀分布的MLE估计比矩估计更有效</p><h4 id="一致估计">一致估计</h4><p>设 <span class="math inline">\(\hat{\theta}(X_1,X_2,...,X_n)\)</span>是未知参数 <span class="math inline">\(\theta\)</span> 的估计量，若<span class="math inline">\(\hat{\theta_n}\xrightarrow{P}\theta\)</span>，则称 <span class="math inline">\(\hat{\theta}\)</span> 为 <spanclass="math inline">\(\theta\)</span> 的一致性估计（相合估计）</p><p>所有矩估计均为相合估计（事实上以概率1收敛，也称强相合估计），样本方差是相合估计</p><h3 id="区间估计与置信区间">区间估计与置信区间</h3><p>设总体分布有一未知参数 <span class="math inline">\(\theta\)</span>，且 <span class="math inline">\(x_1,x_2,..x_n\)</span>为来自总体的样本，若对给定的 <spanclass="math inline">\(\alpha(0&lt;\alpha&lt;1)\)</span> ，统计量 <spanclass="math inline">\(\theta_1(x_1,...,x_n)\)</span> 和 <spanclass="math inline">\(\theta_2(x_1,...,x_n)\)</span> 满足 <spanclass="math inline">\(P\{\theta_1\leqslant\theta\leqslant\theta_2\}=1-\alpha\)</span>，则称区间 <span class="math inline">\([\theta_1,\theta_2]\)</span> 是<span class="math inline">\(\theta\)</span> 置信度为 <spanclass="math inline">\(1-\alpha\)</span> 的置信区间，<spanclass="math inline">\(\theta_1\)</span> 和 <spanclass="math inline">\(\theta_1\)</span> 分别为置信上限和置信下限，<spanclass="math inline">\(1-\alpha\)</span> 称置信度</p><p>方法：求参数的估计，找到服从的分布，根据置信度确定上下限，代入具体样本值进行计算。具体类型如下</p><h4 id="正态总体均值和方差的区间估计">正态总体均值和方差的区间估计</h4><p>设总体 <span class="math inline">\(X\simN(\mu,\sigma^2)\)</span>，<spanclass="math inline">\(x_1,x_2,...,x_n\)</span> 为来自于总体的样本</p><p>方差DX已知，对EX进行区间估计：</p><p>统计量 <spanclass="math inline">\(\dfrac{\bar{x}-\mu}{\frac{\sigma}{\sqrt{n}}}\simN(0,1)\)</span> ，则置信区间为 <spanclass="math inline">\([\bar{x}-z_{1-\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}},\bar{x}+z_{1-\tfrac{\alpha}{2}}\dfrac{\sigma}{\sqrt{n}}]\)</span></p><p>方差DX未知，对EX进行区间估计：</p><p>用样本方差代替总体方差，则有 <spanclass="math inline">\(\dfrac{\bar{x}-\mu}{\frac{s}{\sqrt{n}}}\simt(n-1)\)</span> ，置信区间为 <spanclass="math inline">\([\bar{x}-t_{1-\tfrac{\alpha}{2}}(n-1)\dfrac{s}{\sqrt{n}},\bar{x}+t_{1-\tfrac{\alpha}{2}}(n-1)\dfrac{s}{\sqrt{n}}]\)</span></p><p>方差DX的区间估计：</p><p><spanclass="math inline">\(\dfrac{(n-1)s^2}{\sigma^2}\sim\chi^2(n-1)\)</span>，置信区间 <spanclass="math inline">\([\dfrac{(n-1)s^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)},\dfrac{(n-1)s^2}{\chi^2_{\frac{\alpha}{2}}(n-1)}]\)</span></p><h4 id="假设检验">假设检验</h4><p>第一类错误：原假设正确，但抽样得到的结论否定原假设</p><p>第二类错误：原假设错误，抽样得到的结论不拒绝原假设</p><p>记第一类错误的概率为 <span class="math inline">\(\alpha\)</span>（显著性水平），第二类错误的概率为 <spanclass="math inline">\(\beta\)</span> ，</p><p>方差已知，正态总体均值的假设检验</p><p><span class="math inline">\(H_0:\mu=\mu_0;\ H_1:\mu\ne\mu_0\)</span>检验用的统计量 <spanclass="math inline">\(U=\dfrac{\bar{x}-\mu_0}{\frac{\sigma}{\sqrt{n}}}\simN(0,1)\)</span> ，设检验水平 <span class="math inline">\(\alpha\)</span>，则有 <spanclass="math inline">\(P\{|\dfrac{\bar{x}-\mu_0}{\frac{\sigma}{\sqrt{n}}}|&gt;z_{1-\frac{\alpha}{2}}\}=\alpha\)</span>，因而拒绝域为 <spanclass="math inline">\(D=(-\infty,-z_{1-\tfrac{\alpha}{2}}]\cup[z_{1-\tfrac{\alpha}{2}},+\infty)\)</span></p><p>方差未知，均值检验</p><p><spanclass="math inline">\(U=\dfrac{\bar{x}-\mu_0}{\frac{s}{\sqrt{n}}}\simt(n-1)\)</span></p><p>方差的假设检验</p><p><spanclass="math inline">\(W=\dfrac{(n-1)s^2}{\sigma_0^2}\sim\chi^2(n-1)\)</span>，拒绝域为 <spanclass="math inline">\(D=(0,\chi_{1-\tfrac{\alpha}{2}}^2(n-1)][\chi_{\tfrac{\alpha}{2}}^2(n-1),+\infty)\)</span></p><h2 id="随机过程">随机过程</h2><h3 id="基本概念">基本概念</h3><p>给定参数集 <spanclass="math inline">\(T\subset(-\infty,+\infty)\)</span> ，如果对于每个<span class="math inline">\(t\in T\)</span> ，对应有随机变量 <spanclass="math inline">\(X(t)=X(e,t)\)</span> ，则称随机变量族 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 为随机过程</p><p>对于参数集中任意n个元素，过程的n个状态为 <spanclass="math inline">\(X(t_1)=X(e,t_1),X(t_2)=X(e,t_2)...\)</span>，这n个随机变量的联合分布函数 <spanclass="math inline">\(F(x_1,...,x_n;t_1,...,t_n)=P\{X(t_1)\leqslantx_1,...,X(t_n)\leqslant x_n\}\)</span> 称随机过程 <spanclass="math inline">\(X(t)\)</span> 的n维分布函数，<spanclass="math inline">\(n=1,2,3...\)</span></p><p>类似有n维概率密度</p><p>若对于任何正整数n，随机过程的任意n个状态都是相互独立的，称此过程为独立过程，<spanclass="math inline">\(F(x_1,x_2,...,x_n;t_1,t_2,...,t_n)=\prod\limits_{i=1}^nF(x_i;t_i),n=1,2,3,...\)</span></p><h3 id="数字特征">数字特征</h3><p>均值（函数） <spanclass="math inline">\(\mu_x(t)=E[X(t)]\)</span></p><p>均方值（函数） <spanclass="math inline">\(\Psi_X^2(t)=E[X^2(t)]\)</span></p><p>均方差 <spanclass="math inline">\(\sigma_{X}^2(t)=D[X(t)]=E[X(t)-EX(t)]^2=E[X(t)-\mu_X(t)]^2=E[X^2(t)]-\mu_X^2(t)\)</span></p><p>（自）相关函数 <spanclass="math inline">\(R_X(t_1,t_2)=E[X(t_1)X(t_2)]\)</span></p><p>（自）协方差函数 <spanclass="math inline">\(C_X(t_1,t_2)=E\{[X(t_1)-EX(t_1)][X(t_2)-EX(t_2)]\}\)</span></p><p>其中，数字特征间的关系有：</p><p><span class="math inline">\(\Psi_X^2(t)=R_X(t,t)\)</span></p><p><spanclass="math inline">\(C_X(t_1,t_2)=R_X(t_1,t_2)-\mu_X(t_1)\mu_X(t_2)\)</span></p><p><spanclass="math inline">\(\sigma_X^2(t)=\Psi_X^2(t)-\mu_X^2(t)\)</span></p><p>两个随机过程的互相关函数 <spanclass="math inline">\(R_{XY}(t_1,t_2)=E[X(t_1)Y(t_2)]\)</span></p><h3 id="平稳过程">平稳过程</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\in T\}\)</span>，如果对任意 <span class="math inline">\(t_1,t_2,...,t_n\in T\)</span>和任意实数 <span class="math inline">\(\varepsilon\)</span> ，有 <spanclass="math inline">\(t_1+\varepsilon,t_2+\varepsilon,...,t_n+\varepsilon\inT\)</span> ， <spanclass="math inline">\(F(x_1,x_2,...,x_n;t_1,t_2,...,t_n)=F(x_1,x_2,...,x_n;t_1+\varepsilon,t_2+\varepsilon,...,t_n+\varepsilon)\)</span>对任意n维分布函数都成立，则称 <span class="math inline">\(X(t)\)</span>为严平稳过程</p><p><strong>伯努利序列</strong>：独立重复进行某项试验，每次成功概率为p，失败为1-p，以<span class="math inline">\(X_n\)</span> 表示第n次试验成功的次数，则<span class="math inline">\(\{X_n,\ n=1,2,3\}\)</span>是严平稳过程。（样本空间 <span class="math inline">\(S=\{0,1\}\)</span>）</p><p>平稳过程（广义平稳过程）：</p><ol type="1"><li><span class="math inline">\(E[X^2(t)]\)</span> 存在且有限</li><li><span class="math inline">\(E[X(t)]=\mu_X\)</span> 是常数</li><li>任意 <span class="math inline">\(t+\tau\inT,E[X(t)X(t+\tau)]=R_X(\tau)\)</span> 仅依赖于 <spanclass="math inline">\(\tau\)</span> ，而与t无关</li></ol><p>正态过程：任意n，<spanclass="math inline">\((X(t_1),X(t_2),...,X(t_n))\)</span>均服从正态分布</p><p>存在二阶矩的严平稳过程必为广义平稳过程，正态平稳过程是严平稳过程</p><h3 id="遍历过程">遍历过程</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\inT=(-\infty,+\infty)\}\)</span></p><p>时间均值： <spanclass="math inline">\(\overline{X(t)}=\lim\limits_{l\to+\infty}\dfrac{1}{2l}\int_{-l}^lX(e,t)dt\)</span></p><p>时间相关函数： <spanclass="math inline">\(\overline{X(t)X(t+\tau)}=\lim\limits_{l\to+\infty}\dfrac{1}{2l}\int_{-l}^lX(e,t)X(e,t+\tau)dt\)</span></p><p>若 <spanclass="math inline">\(P\{\overline{X(t)}=E[X(t)]=\mu_X\}=1\)</span>，则称过程 <span class="math inline">\(X(t)\)</span>的均值具有各态遍历性。若 <spanclass="math inline">\(P\{\overline{X(t)X(t+\tau)}=E[X(t)X(t+\tau)]=R_X(\tau)\}=1\)</span>，则称过程 <span class="math inline">\(X(t)\)</span>的自相关函数具有各态遍历性。均值和自相关函数都具有各态遍历性的平稳过程称遍历过程</p><p>设随机过程均方值存在且有限，则称二阶矩过程。设 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 为二阶矩过程</p><ol type="1"><li>对 <span class="math inline">\(t_0\in T\)</span> ，若 <spanclass="math inline">\(\lim\limits_{t\to t_0}E|X(t)-X(t_0)|^2=0\)</span>，则称 <span class="math inline">\(X(t)\)</span> 在 <spanclass="math inline">\(t_0\in T\)</span> 处均方连续</li><li>若 <span class="math inline">\(X(t)\)</span> 在每一个 <spanclass="math inline">\(t_0\in T\)</span> 处都均方连续，则称 <spanclass="math inline">\(\{X(t),t\in T\}\)</span> 是均方连续的</li></ol><p>设 <span class="math inline">\(\{X(t),t\inT=(-\infty,+\infty)\}\)</span>是一均方连续的平稳过程，则时间均值具有各态遍历性的条件是 <spanclass="math inline">\(\lim\limits_{t\to+\infty}\dfrac{1}{l}\int_0^{2l}(1-\dfrac{\tau}{2l})[R_X(\tau)-\mu_X^2]d\tau=0\)</span></p><h3 id="马尔可夫链">马尔可夫链</h3><p>设随机过程 <span class="math inline">\(\{X(t),t\in T\}\)</span>的状态空间S为有限集或可列集，若对任意正整数n，T内任意n+1个参数 <spanclass="math inline">\(t_1&lt;t_2&lt;...&lt;t_n&lt;t_{n+1}\)</span>和S内任意n+1个状态 <spanclass="math inline">\(j_1,j_2,...,j_n,j_{n+1}\)</span> ，条件概率 <spanclass="math inline">\(P\{X(t_{n+1})=j_{n+1}|X(t_1)=j_1,X(t_2)=j_2,...,X(t_n)=j_n\}=P\{X(t_{n+1})=j_{n+1}|X(t_n)=j_n\}\)</span>恒成立，则称此过程为马尔可夫链，反映出的性质为无后效性。</p><p>状态空间符合要求的独立过程是马尔可夫链</p><p><spanclass="math inline">\(P\{X(t_{m+1})=j|X(t_m)=i\}=p_{ij}(t_m)\)</span> 称<span class="math inline">\(X(t)\)</span> 在时刻 <spanclass="math inline">\(t_m\)</span>时由状态i一步转移到状态j的（一步）转移概率。n步为 <spanclass="math inline">\(P\{X(t_{m+n})=j|X(t_m)=i\}=p_{ij}^{(n)}(t_m)\)</span></p><h4 id="齐次马尔可夫链">齐次马尔可夫链</h4><p>若一步转移概率不依赖于参数，即任意两个不相等的参数 <spanclass="math inline">\(t_m,t_k\)</span> ，有 <spanclass="math inline">\(P\{X(t_{m+1})=j|X(t_m)=i\}=p_{ij}(t_m)=P\{X(t_{k+1})=j|X(t_k)=i\}\)</span>，称齐次马尔可夫链</p><p>对于参数离散的齐次马尔可夫链，由转移概率 <spanclass="math inline">\(p_{ij}\)</span> 排序得转移概率矩阵（行和为1）<span class="math display">\[P=\begin{pmatrix}p_{00}&amp;p_{01}&amp;\cdots&amp;p_{0j}&amp;\cdots\\p_{10}&amp;p_{11}&amp;\cdots&amp;p_{1j}&amp;\cdots\\\vdots&amp;\vdots&amp;\ &amp;\vdots\\p_{i0}&amp;p_{i1}&amp;\cdots&amp;p_{ij}&amp;\cdots\\\vdots&amp;\vdots&amp;\ &amp;\vdots\end{pmatrix}\]</span> 马尔可夫链的多步转移公式： <spanclass="math inline">\(P_{ij}^{(n+l)}(t_m)=\sum\limits_kp_{ik}^{(n)}(t_m)p_{kj}^{(l)}(t_{m+n})\)</span></p><p>齐次情况下， <span class="math inline">\(P^{(n)}=P^n\)</span></p><h4 id="平稳分布">平稳分布</h4><p>对齐次马尔科夫链，若存在概率分布 <spanclass="math inline">\(\pi=(\pi_0,\pi_1,...,\pi_j,...)\)</span> 满足<spanclass="math inline">\(\pi_j\geqslant0,\sum\limits_{j=0}^{+\infty}\pi_j=1\)</span>和 <spanclass="math inline">\(\pi_j=\sum\limits_{i=0}^{+\infty}\pi_{ij}p_{ij},\j=0,1,2,...\)</span> 则称 <span class="math inline">\(\pi\)</span>为平稳分布， <span class="math inline">\(X(t)\)</span>是平稳齐次马尔可夫链</p>]]></content>
    
    
    <categories>
      
      <category>数理基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
